var store = [{
        "title": "从零开始 Ruby on PHP",
        "excerpt":"关于什叶派 PHP 教徒 PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。 Ruby on PHP 考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码 require 'sinatra' get '/' do redirect '/index.php' end get /^\\/(.*?)\\.php$/ do |c| erb c.to_sym end post /^\\/(.*?)\\.php$/ do |c| erb c.to_sym end...","categories": [],
        "tags": ["编程","Ruby","PHP"],
        "url": "/2016/06/10/ruby-on-php",
        "teaser": null
      },{
        "title": "关于 eval 是否 evil 的一些想法",
        "excerpt":"对于大多数动态语言，都支持 eval 这个神奇的函数。这打他们太爷爷 Lisp 开始就支持这种方法。虽然写法（eg: (eval '(+ 1 2 3)) ）有稍许不同，但语义是一样的，就是说 eval 函数接受一个字符串类型作为参数，将其解析成语句并混合在当前作用域内运行。但我想大家也都听过这么一句话： eval is evil. 但是 How evil is eval？那么既然 eval 如此罪恶，那么为什么它仍被那么多动态语言作为接口暴露呢？我们不妨来仔细探讨一下 eval 在使用中究竟会产生什么问题，在日常编程中究竟该不该使用 eval，如果要用，那么又该如何使用。 字符串安全 说到 eval 第一个会被讨论的当然就是其安全性。比如说，我们现在来实现一个四则运算器： loop do print('Expression: ') puts(\"result: #{eval gets.chomp}\") end Expression: 1+1 result: 2 Expression: 2+2 result: 4 Expression: 3*4 result: 12...","categories": [],
        "tags": ["编程","Ruby"],
        "url": "/2016/10/29/is-eval-evil",
        "teaser": null
      },{
        "title": "花了半个月捡垃圾",
        "excerpt":"引 这半个月开源项目拖更，啥事没干成，主要要感谢我的 MacBook Pro。大年二十五，风扇异响；大年二十六，更换风扇；大年二十七，更换风扇后无法通过屏幕自检；大年二十九，更换主板；正月十二，主板短路，浓郁的线路烧焦的气味从风扇口传出；正月十三，机器第五次返厂维修，问题分类「安全性第一问题」，维修后需要返售前检测，预计需要到周四才能修好。这一下子家里一台能用的机器都没有。除了安装着 Windows 的一台机器，还有一台是 NAS，唯一装着 Linux 的是一台软路由。于是决定捡垃圾捡台新机器来写代码。 捡垃圾思路 Q: 为什么是捡垃圾？ A: 因为是备机，不想花太多钱。穷。 Q: 从哪里捡？ A: 本来打算从闲鱼捡，后来想想闲鱼二手可靠性太差，最后还是打算主要零件从淘宝捡，一些配件从京东捡。 Q: 需要满足的需求？ A: 完美的日常编码和跑机器学习。 主要是最近写了点卷积神经网络，放 CPU 上跑实在太慢。一开始试图接了个 GTX970，然后我这个数据预处理又太慢，最好能搞个核心数足够多的机器，这样才能爽。 一说到核心数多，第一反应就是二手服务器。1800 元收了个 IBM 的二手服务器，一代志强 E5645 双路，64GB 内存，2 块 SATA 的 1TB 机械硬盘。本来想把机器拆了，改装到家用主机上。因为服务器风墙实在太吵，实测 70db 噪音，受不了。 Q: 为什么服务器二手那么便宜？ A: 很多服务器都是过了保修期就白菜价卖出来的，比如我手上的机器是百度卖出来的，开机自检还有百度 Logo。服务器的内存由于是 ECC 的，和 PC 内存不通用，更是便宜，这半个月翻遍淘宝，ddr3 reg...","categories": [],
        "tags": ["生活"],
        "url": "/2017/02/14/build-up-x79-workstation",
        "teaser": null
      },{
        "title": "量产型炮灰工程师",
        "excerpt":"在吗 写这篇文章之前我的顾虑非常多，因为它很得罪人而我却捞不到一点好处。但反过来说我写这篇文章并不是针对说「达○」这样的培训机构，或者「李○○」老师的一些言论，也不是针对说 Ruby China 上最新一些类似的培训帖。我是说在座的，都是○○。 我要针对的甚至都不是培训行业，反过来，我认为对于整个软件行业而言，培训整件事情就不靠谱。这不是说我心血来潮，我想诸位的公司只要不是沙丁鱼罐头类型的外包公司，对于培训这件事本身都多少抵触。至于高端的培训班，我想你们也有自己的看法，只是有时候不方便说出来。但我最近了解了一些底层劳苦人民悲惨的事实，使我实在看不下去，只能出来批判一番了。 丢人玩意，退群吧 我们先抛开培训班的问题，我们先来讨论一个经典的面试题，它叫做「FizzBuzz」。输出数字 1-100，逢 3 的整倍数输出 Fizz，逢 5 的整倍数输出 Buzz，又是 3 又是 5 的整倍数输出 FizzBuzz。那么稍有常识的人都知道，无论你学习什么语言，学的水平有多糟糕，这道题都很容易实现。但我们来看一下最常见的一些错误是怎么出现的： for i in 1..100 if i / 3 == # 写不下去了 for i in 1..100 if i % 3 == 0 puts 'Fizz' elsif i % 5 == 0 puts...","categories": [],
        "tags": ["编程"],
        "url": "/2017/05/22/mass-produced-engineers",
        "teaser": null
      },{
        "title": "如何读文档？",
        "excerpt":"今天收到一份微博私信，问我之前 量产型炮灰工程师 中说一个良性的学习循环需要自己寻找线上资源学习、读文档等等，这些都没有在培训班中被学到。那怎样才能比较好的读文档呢？不分享一下的话，老说我是光破不立，光批评别人自己却没有任何解决。那么我来分享一下我读文档的思路吧。 大局入手 首先，这里的读文档并不局限于接口文档，接口文档更像是工具书，这里的文档泛指围绕代码周边的文字说明。你要学习一门语言、框架或者某个工具，肯定不是因为它是一个工具所以你就学。框架的开发者也不会是因为想写一个框架所以就写一个框架。凡事都一定有它的理由，一个语言、框架、工具的存在一定是为了解决某一个或某一类特定的问题而存在的。同一个类型的不同的语言、框架、工具之所以会不同，是因为他们试图在解决不同的问题，或者某个工具正在解决另一个不能解决的某种问题。这时候作者的想法是尤为重要的，如果弄清楚这方面想法对于你的学习自然是事半功倍的。 作者的想法在哪里？ 在官方的教程、官方的概述里。对于 Ruby 来说，其官网的关于页短短一页就几乎解释了什么是 Ruby，Ruby 和其他语言的不同： Ruby 从多门语言中学习了经验，注重其平衡性 兼具函数式编程和命令式编程特色 Ruby 试着让语言更自然，而不是更简单 Ruby 将一切视为对象 Ruby 允许用户修改语言自身 Ruby 的闭包具有极强表现力 Ruby 对象只提供单继承，但支持混入 Ruby 的变量系统 Ruby 的其他细节 有了这些大纲，这对于你理解 Ruby 中的很多表现就有了很大的认识。接着再去看 Ruby User’s Guide 或者 Programming Ruby 就会有很大的帮助。 了解变化 在学习了一个东西的大纲和入门教程之后，大版本的更新记录是文档中非常重要，却是最容易被忽略的部分。 比如 Qt 在 4.8 版本中引入了 QML。我相信很多公司都号称使用 Qt 做跨平台界面开发，却很少注意 Qt 本身的变化。很多公司...","categories": [],
        "tags": ["编程","Ruby"],
        "url": "/2017/07/16/how-to-read-the-fxxking-manual",
        "teaser": null
      },{
        "title": "程序员必看！中秋前后绝对不能做的 0x08 件事",
        "excerpt":"   0x00. 开发中秋活动相关页面（时间太急，可能有 BUG）   0x01. 开发与现实货币直接相关的比如电商、抢购业务（后果严重，容易在假期前后被攻击）   0x02. 匿名表达对老员工，特别是对彭姓员工不满（大老板可能含沙射影地让你滚）   0x03. 草率入职某开曼群岛注册公司的北京分公司（公司可能不会帮你办暂住证）   0x04. 开发公司 HR 工具的离职谈话功能（会说是你的问题）   0x05. 截图公司内网论坛（网站可能有数字水印）   0x06. 公开打包票没问题，否则赔你十万（可能会破产）   0x07. 用脚本在公司网站抢月饼（可能违反价值观）  ","categories": [],
        "tags": ["阿里巴巴"],
        "url": "/2017/08/31/mid-autumn-2017",
        "teaser": null
      },{
        "title": "Rack/Rails 服务器获取用户 IP 问题分享",
        "excerpt":"引 由于最近论坛发生了某些讨论，出现了一个恶意攻击的账号。然而去查用户 IP 时，却发现没有拿到用户的 IP。这个问题非常诡异，几经排查，终于发现了问题，问题同时发生在 Rack 和 Rails 的实现上，这意味着这个问题可能影响几乎所有 Ruby Web 服务器。故有必要写下此文，分享这一问题。 代理 我们先做一个假设问题，如果你是 Rack 的作者，你会如何获取客户端的 IP 地址？ 最容易想到的就是直接获取 TCP 连接的 IP。这个在 Rack 中已经被 parse 成 env['REMOTE_ADDR'] 了，于是直接获取这个值就可以了。这个做法基本上是对的，但是很快就遇到了问题。如果我的服务器躲在 HTTP 反向代理或者负载均衡之后，那么我获取到的岂不是都是代理的 IP 而不是真正的用户 IP 了吗？ 早年有一些公司会自己设置 HTTP header 来解决这一问题。2004 年 IETF 通过了 RFC 7239 标准，为这样的问题制定了通用的标准。简单来说，就是用 X-Real-IP header 标记用户的真实 IP，用 X-Forwarded-For header...","categories": [],
        "tags": ["编程","Ruby"],
        "url": "/2017/12/26/rack-rails-user-ip-bug",
        "teaser": null
      },{
        "title": "MySQL 惊险恢复记",
        "excerpt":"昨天接到朋友的一个电话，说服务器被攻击了。上去一看，Windows 主机弱密码，直接被远程登录中了勒索病毒，要价就是好几十比特币。所有文件都被加密。遇到这个问题，第一反应就是完蛋，直接恢复备份吧。然而这是台物理机，而不是云主机，备份没有那么方便，所以这台机器 没有备份。 这基本上已经基本判了死刑了，当时的解决是立刻切断服务器电源，挂载到安全的电脑上找一些还没来得及被加密的文件抢救。 初探 由于朋友当时不知道怎么拆 RAID 阵列，所以就直接把服务器整机搬到了我家里。🤦‍ 不过后来我拆开一看，其实只是一个 RAID 1，所以任何一块盘的内容是一样的，随便拔一块下来。联想收购 ThinkServer 后干的最大的大好事就是把硬盘架上的 T6H 螺丝换成了标准的十字螺丝。（我之前在 ThinkServer 螺丝问题上的坑爹遭遇参考此贴） SATA 连上电脑检查文件。硬盘的核心文件是一个 MySQL 数据库，其它文件都是 stateless 的代码，倒是很容易恢复。根据恢复 MySQL 数据库的经验，第一反应是去找 MySQL 二进制日志文件。许多数据灾难最后都是通过二进制日志恢复的，而且这些已经都有非常成熟的工具可以直接使用。 然而找到 log 的目录的时候发现所有的 .bin 文件已经变成了 .bin.RESERVE，显然是已经被加密没救了。 转机 然而接下来，我突然发现，这个病毒的实现有个 Bug，一个实实在在的 Bug，为这个事情发现了转机。病毒没有加密所有文件，因为如果这样，它也无法发送自己的勒索信息，所以它保留了其自己生成出来文件名的文件不被加密。然而为了方便判断这个「自己生成」的概念，病毒是直接依靠后缀的。病毒保留了 .html .txt 和 .log 后缀的所有文件。 .log？这个通用的日志格式不也是 MySQL General Query Log 用的吗？虽然一般情况下，我们不会打开 MySQL General...","categories": [],
        "tags": ["编程","运维","MySQL","Ruby"],
        "url": "/2018/01/05/mysql-recover-from-general",
        "teaser": null
      },{
        "title": "关于学习编程的一箩筐问题",
        "excerpt":"两个月前和 16 岁 JK 美少女 @-顾兮- 一起吃饭的时候聊到了计算机教育入门的话题。之前虽然我写过一些批判培训班的文章，但是所谓只破不立，至于到底怎么学习是对的，很难有个界定标准。想到今天睡不着觉，于是想到以后如果再有微博私信问计算机教育空洞而广泛的问题的话，这篇文章将是我想说的全部答案。 为什么需要编程？ 以前我喜欢把这个问题表达成「为什么要学习编程？」在收到了不少「为了钱」这样的答案之后，我决定换个方式来问这个问题。「为什么需要编程？」如果你提供编程的服务，而别人为此付钱。别人为什么付钱？别人为什么要从你这里购买服务？这个答案最宽泛的回答就是「我们用编程来解决问题。」 人们的日常工作生活有大量的问题，比如低下的沟通效率、低下的执行效率等等。而我们使用编程的技术，来帮助人类解决这其中的 一部分 问题。而这，是编程的根本意义。 学习编程的前置条件 显然地，编程不是魔法。要想写代码，事实上随便学习一下，几个月能写出一些东西我想是没有问题的。这也是为什么那么多培训班能存活下来的原因。但要想写好代码，两个必不可少的因素是对数学的敏感和放洋屁的能力。这两点既需要人的一些天赋，亦需要长时间的训练才能达到。 对于数学的敏感性不是指对算术的敏感性。中国人扎实的基础教育让大家对算术都很敏感，去买个菜从来不会算错找零钱。但事实上，在编程中，算术问题是极易通过计算机来解决的。人所要做的，是如何让计算机解决问题。要想做到这一点，要有能很好地将现实中的问题转换成清晰、直观的数学模型的能力。 而放洋屁的能力关键落在编程的社会性上。我知道不少因为英语问题而被严重困扰的码农们的日常。虽然大多数东西都能找到「中文文档」，但在大多数情况下，中文文档往往不是一手资料，甚至有可能是过时资料。英文是假设每个不在使用易语言的程序员都应该掌握的能力。当你使用的库遇到了 bug，跑到 GitHub 上狂开一通中文，且不说礼貌问题，对于解决问题本身亦会造成极大的困难。 这两点对于很多人来说可能是灾难性的。大学 CS101 写个求水仙花数的题目，对于一些人来说，就像是说话一样在描述问题，而对另一些人完全找不到下手的地方。还有我非常喜欢讨论的 FizzBuzz 问题，亦是考察描述模型时考虑是否周全的好例子。而另一些人看到英文字母就头晕，完全没有读下去的能力。对于这些人来说，我的建议是我不太推荐你来学习编程。这不是说你不能通过学习来通过编程谋生，而是你的职业道路会非常坎坷，你会因为基础的不牢固而还债。 计算机科学 今天看到一个知乎上的问题： 「既然终究要成为码农，那么大学计算机系的意义何在？」 此问题，源于 Hacker News 上的一个帖子：Are you working on interesting technical problems? 题主对此也是很有感触，今年刚换了工作，令我惊讶的是身边的同事有一批二本毕业的（没有歧视，就事论事），有几个比我还小，题主的大学虽然只是普通 211 但是我一直在努力地学习技术，毕业两年下班之后几乎没有过多的娱乐时间，都在看内核相关的东西，可是结果却是两年过后我依然和他们在同一个水平线上。四年的大学生涯并没有为自己增加多少能力，所谓的离散数学，所谓的算法，所谓的计算机原理，到现在为止都没有用上，至于那些 Linux 操作之类的完全没必要早接触，还不如那些在工作中临时学的人节省时间。工作中的用到的大部分知识基本都可以在工作中逐渐学会，大学努力所学的一切，所花费的精力都在一瞬间成为了泡影。感觉自己正在失去信念，越来越觉得大学计算机系和培训机构没什么太大区别，学出来都是做码农的，知乎上大神们谈论的高深的计算机科学到底在哪里，为什么这么难以见到？ 事实上这个问题的前提「既然终究要成为码农」就有一些问题，显然不是所有人都会成为码农。我现在的工作，和 Linux 底层、算法就强相关。写代码，可以做业务强相关的码农。但计算机科学，有很多与业务相对无关，非常重视底层技术的工作需要做，而且这些工作还很难找到适任的人。 「都在看内核相关的东西，可是结果却是两年过后我依然和他们在同一个水平线上。」这一点我是相当怀疑的，所谓看内核的东西，究竟是看看博客当小说，还是带着问题，特别去深究一些功能究竟在干什么，要解决什么问题。这些信息往往在解决特定问题的时候会变得非常实用。 高德纳说过：「在大概 97% 的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。」 很多人把这句话视为教条，但这句话的后半句紧跟着就是「我们不能放弃剩下的...","categories": [],
        "tags": ["编程"],
        "url": "/2018/06/06/coding-tutorial",
        "teaser": null
      },{
        "title": "Ruby 内联私有方法与原理",
        "excerpt":"孔乙己有一回对我说道，“你学过 Ruby 么？”我略略点一点头。他说，“学过 Ruby，……我便考你一考。private 私有方法，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些字应该记着。将来做 CTO 的时候，写码要用。”我暗想我和 CTO 的等级还很远呢，而且我们 CTO 也从不在 Ruby 里写 private 方法；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是 private 换行之后就是 def 的都是私有方法么？”孔乙己显出极高兴的样子，将两个指头的长指甲敲着柜台，点头说，“对呀对呀！…… private 的三种写法，你知道么？”我愈不耐烦了，努着嘴走远。孔乙己刚用指甲蘸了酒，想在柜上写字，见我毫不热心，便又叹一口气，显出极惋惜的样子。 孔乙己这里说的 private 的三种写法其中有两种是非常常见的，第一种是： class Test private def a 'a' end end 另一种则是： class Test def a 'a' end private :a end 这两种各有优劣，第一种 private 后的方法都是私有方法，有效组织了方法顺序。而第二种则可以随意定义方法，之后再定义哪些是 private 方法。 之前在看 Rubocop 的代码风格的一些...","categories": [],
        "tags": ["编程","Ruby"],
        "url": "/2018/07/03/ruby-inline-private-method",
        "teaser": null
      },{
        "title": "在 Ruby 中实现一个 WebSocket 掩码",
        "excerpt":"引 在 WebSocket 协议中有一个重要的实现就是 masking（掩码），根据 RFC 6455 10.3 章节 的讨论，客户端连接服务器必须要打开掩码功能，当服务器收到一个客户端帧没有打开掩码时，应到立刻终止这一连接。关于为什么必须有一方开启 mask，可以参见 这个回答。 一个 WebSocket 帧长成下面这样： 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0...","categories": [],
        "tags": ["编程","Ruby"],
        "url": "/2018/07/10/ruby-websocket-in-c-lang",
        "teaser": null
      },{
        "title": "使用字体，怎样不惹官司",
        "excerpt":"近来，知名 up 主敖厂长因为在视频中使用了「造字工房」家的某些字体，使得惹上了官司，被求偿十多万的赔偿费用。在字体行业内，其实这样的事情屡见不鲜。从 2011 年方正诉保洁的「飘柔」商标字体案，到 2015 年造字工房诉湖南卫视《歌手3》节目字体侵权案，字体公司的名字似乎和侵权官司脱不开关系。那么今天我们就来聊一聊中文字体行业的发展现状，以及作为一个用户，怎样使用字体，不容易惹上官司。 字体行业现状 字体行业的生存相当困难，目前国内其实混得比较好的字体公司只有那么几家。大家熟悉的简体字的字型逃不开北大方正、常州华文，还有台湾的威锋数位（也就是之前的华康字体）、文鼎字体和蒙纳字体这几家公司的设计。这些品牌几乎都是伴随中国计算机发展从无到有的几十年过程中的重要见证。而这次的主角造字工房，虽然也是一家成立了十年的老公司了，但比起这些公司，还算是比较年轻的。 首先设计中文字体的过程，不得不说是比较艰辛的。一个完整的西文字体通常需要拉丁字母、希腊字母、西里尔字母以及常见的符号，这样就已经有近千个字型需要设计了。而中文字形则更多，根据中国 GB2312-80 中华人民共和国国家标准简体中文字符集规范，包括 6763 个汉字（其中一级汉字 3755 个，二级汉字 3008 个）。而即使这样，也只能覆盖中国大陆 99.75% 的使用频率。一旦使用到一些偏僻字，我们还有 GB18030 国家标准来涵盖偏僻字，其收录汉字 70,244 个。像是政府公文喜欢用的仿宋、楷体，都有对应的 GB18030 标准实现，来保证尽可能地不会缺字。这还不算上各种 hinting、ligature 之类细节调教所需要的工时，甚至还要面向不同操作系统使用的不同渲染方式进行微调。 而在这种情况下，付出了大量的设计师成本后，字体公司的盈利模式又是如何的呢？ 我们可以大致把常见的字体公司盈利模式，分成下述几类： 研发授权 字体定制 字体销售 诉讼收入 像是微软雅黑就是微软委托给方正和蒙纳设计的；而 Adobe 和 Google 合作研发的思源黑体的中文部分，是委托给常州华文设计的；而像苹果新的 iOS 和 macOS 中内置的苹方字体则是委托威锋数位设计的。这是字体公司盈利的很大来源，这些国际大厂有着广泛的字体设计的评价标准，属于比较懂事的甲方。以微软雅黑为例，据坊间传闻，微软雅黑的平均每个汉字的价格是 100 美元，也就是说一个 2 万个汉字的字体，微软付出了 200 万美元的合作价格，以获取微软雅黑能在 Windows...","categories": [],
        "tags": ["字体","法律"],
        "url": "/2018/11/24/how-to-use-fonts",
        "teaser": null
      },{
        "title": "部署家中网络的流水帐",
        "excerpt":"我今年 9 月搬家到了藤泽，签了一个非常恶心人的 Softbank 的网络合约之后，花了大半个月才搞清楚这个网络的状况。于是就基于自己的需求，在家中部署了多项服务。今天写这篇文章就是来分享一下部署过程中遇到的困难以及解决的方案。 需求 能够有稳定的有线、无线网络 每个设备都有 IPv6 支持 访问学校资源时自动通过 VPN 连接学校内网 在局域网内提供 NAS 服务 在局域网内提供私有 git 服务来维护代码 支持通过 VPN 访问家中网络 对外提供 Web 网络服务 之所以定成这样有几个理由。一个是我从来不相信所谓的云网盘，一定要自己存文件才是安全的。其次是经过测试，我的网络基于 IPv6 的传输速度比 IPv4 快不少，上下行都能稳定在 600Mbps 左右。这也使得家中不止要有无线网络，千兆有线网络对于压榨性能也是必不可少的。 为了达成这个网络部署，前后也是经历了两三个月时间细心打磨方案，下面就是具体的过程。 网络拓扑 光纤自 NTT 的 GPON 接入 Softbank 的路由。之所以要接入 Softbank 的路由而不是直接接在自己的路由上，是因为 Softbank 使用了一个非常诡异的 IPoE + IPv6 的网络分配形式。其 IPv4...","categories": [],
        "tags": ["生活","网络"],
        "url": "/2018/11/26/home-network-fujisawa",
        "teaser": null
      },{
        "title": "十分钟速通 Y Combinator",
        "excerpt":"引 这学期在学校选了一门讲可计算性（Computability）的计算机科学基础课程。过程中也把很多概念给自己重新复习了一下，不过从这课课堂的反馈来看，可以说同学都听得非常吃力。我想到几年前我有尝试写过一篇通过 Y 组合子来讨论 Lambda 演算的文章，考虑到当时写得很不完善，我打算拿出来重新炒一下冷饭。顺便改使用傻子都能看懂的 JavaScript 来描述这个问题。顺便调试一下我博客系统 Markdown 引入 $\\LaTeX$ 后会遇到的坑。 循环 -&gt; 递归 我们还是从下面这个简单的循环问题开始探讨。通过写一个循环（不使用等差数列的情况下），求自然数列 1 到 n 的和（即 $1+2+3+…+n$）。一个最容易想到的实现可能如下： function sum(n) { let result = 0 for (let i = 1; i &lt;= n; i++) { result += i } return result } sum(10) // =&gt; 55 我们现在对这个问题稍作变形，如果在这个程序中不得使用...","categories": [],
        "tags": ["JavaScript","Lambda 演算"],
        "url": "/2018/12/07/y-combinator-in-ten-minutes",
        "teaser": null
      },{
        "title": "[Ruby Quiz] Base32 字母表 —— 加密猫基因解码",
        "excerpt":"刚刚在 ruby-talk 的邮件列表读到一个很有意思的 Ruby Quiz，题目可以见此。想到好久没有看到 Ruby Quiz 了，就做了并翻译了一下。 题目翻译 庆祝 CryptoKitties 一周年 —— 区块链上诞生了超过 100 万只可爱的小猫！ 我们来尝试转换 “sekretoooo” 加密猫的基因，一个 240 位的整数，以每 5 位进行分割，再通过 base32 (2^5=32) 进行转换，转至 kai 标注。 Q: 什么是 kai 标注？ Kai 标注（因为 Kai Turner 解码了加密猫的基因而命名）是一种针对 240 位整数分割成 5 位块的 base58 的变种（子集）。每个 5 位块含有 32 种可能性，240 位基因可以给分割成 12 组，每组...","categories": [],
        "tags": ["Ruby","Ruby Quiz"],
        "url": "/2018/12/08/ruby-quiz-base32",
        "teaser": null
      },{
        "title": "Ant Design 错了吗？",
        "excerpt":"Ant Design 今天的圣诞门闹得沸沸扬扬，Ant Design 内建的圣诞彩蛋在各个使用 antd 的产品中被「强制」弹出，令许多人措手不及，造成了很大的社会影响。但事实上，Ant Design 使用的是 MIT LICENSE，完全是一个使用者「后果自负」的协议。然而，Issue 里哭天喊地要开发者「负责」的舆论却又一面倒。 在此，我要问一个问题：「Ant Design 错了吗？」 ​ 就我来看，毋庸置疑，错了。 但这篇文章讨论的是以下几点： Ant Design 犯了什么错？ 开源的权利与责任的界限在哪里？ 我们应当怎么从这个事件中获取教训？ Ant Design 犯了什么错？ 从产品的角度来看，这个彩蛋，连彩蛋的定义都不符合。彩蛋（Easter Eggs）是一个隐藏在程序中的信息，而不是突然糊在你脸上的定时炸弹。所以从想出这个问题的那个人就已经不太对劲了。但我们抛开这个产品的问题，从实现上，这个 Santa.jsx 文件也同样是非常糟糕。作为一个组件级项目，很多人会对组件样式做二次开发，这一坨硬编码（Hardcoded）并没有起到它彩蛋的作用，相反还把很多网站弄得一团糟。如果你试图阅读过 Ruby 的代码，你往往会发现 Ruby 有那么多错误命名的 C API 为什么一直不把它改对呢？因为这种语言级别的东西，你无法确定用户是怎么使用的时候，就必须保持最低限度的兼容。Ant Design 也是如此。 然而「人主之患在莫之应，故曰：一手独拍，虽疾无声。」导致 Ant Design 问题的，不单单是彩蛋本身的错，更大的是 Ant Design 开源社区开发流程的问题。或者换一句话说：是软件工程的问题。 如果我们现在要往一个开源项目中加入一个不合适的东西，其实并不那么容易。Ant Design 有基于 GitHub...","categories": [],
        "tags": ["阿里巴巴","前端","开源"],
        "url": "/2018/12/25/is-antd-wrong",
        "teaser": null
      },{
        "title": "平成最后的烂尾游戏——东京地下铁 2018 解谜游戏设计分析",
        "excerpt":"这个几年来久闻东京地下铁解谜游戏的大名，一支没有完整地体验一下这个游戏。终于在去年年底的时候尝试了一下这款游戏。体验下来的感觉褒贬不一，所以我打算从游戏设计的角度，系统地来聊一聊这款游戏。 游戏简介 游戏的基本流程就是在你购买完游戏套件（Kit）后，从你所在的车站开始，利用套件里提供的道具与车站及附近的现实场景进行交互，从而获得线索一步一步解开谜题。 游戏的设计公司是「SCRAP」，这家公司设计了大量类似的现实解谜游戏「リアル脱出ゲーム」。游戏的监督是毕业于京都大学的「堺谷 光」，在查阅资料的过程中找到了他的一篇游戏设计论文，这篇论文对简单的 Tic Tac Toe 游戏进行发展，实现了一个策略复杂的棋类游戏，并对游戏数值进行了建模和演算。在游戏过程中，我感到了一种非常类似的「模进（Sequentia）」发展的感觉，游戏设计了一些最基本的谜题思路（动机），通过在重复、变换和组合实现一个非常激动人心的游戏体验。 分支与引导设计 游戏的一个 Puzzle 是一个基于鬼脚图（阿弥陀籤）变化的游戏。和鬼脚图不同的地方是，每个连接处都有一个图形。而游戏提示有一个图形不能被通过，而这时就引入了游戏中的第一个引导设计。在游戏的描述中希望你在 MINITIA 糖上找到一个黑色的图形，而这个图形就是那个不能被通过的图形。游戏的第二个谜题则是和网站上的「練習問題」类似的设计，通过メトロ的站名与编号之间的转换来解开谜题。 这里给出了游戏第一个设计上的巧思。第一、因为这个 MINITIA 糖就出现在了游戏提供的套件中，隐含了游戏的第一个要点「你需要巧妙使用套件里的东西」。第二、游戏套件封面上有站点的地图，并标出了游戏所有可能发生的车站站名，查询车站编号时无疑这里查起来更快。然而，对于鬼脚图谜题实际上一共只有 4 个图形，试一下就做出来了；而车站名谜题 Google 一下也有了。于是这两处引导显得非常不必需，而一旦错过，却在之后会非常痛苦。 经过了第一、第二个谜题，游戏进入了分支路线。玩家可以从三对地点中选择自己的分支。由于我从新宿站出发，我选择的是四谷和千駄木。这一点很好照顾了不同出发地点的玩家。与其说是分支，不如说是聚合，把不同地方开始的玩家，通过不同的引导方式，最终指引到唯一的地方去。这种设计非常值得 Ingress Mission Day 设计，Ingress 目前的线下活动，要么是线性的，要么就是无顺序的，使得游戏体验很难在乐趣和多元间达到平衡，而这处分支引导，则是一个非常柔性却非常有效的多路线设计。 i18n 设计 需要提到的是，这个游戏设计了双语的版本，提供了日本语和英语两个游戏选项。我手上的谜题是英文版的。游戏的设计者试图在抹平这两者的差异，但实际上两者的游戏难度却有很大的不同。这一点从我面临的第三、第四个难题（Mission 1）中有很大的体现。游戏设计者在此处大量设计了字谜，而日语字谜和英语字谜的原理有很大的不同。 日语的每个字母（仮名）都是一个音节，而英语的每个音节长短不一，且字母到音位并不是一个严格的映射关系。（P.S 谁真的严格按照 Google Tacotron 2 论文里描述的方法去训练 TTS AI 的，都尝过苦头吧）这使得凡是涉及字谜的部分，英文都变得简单很多。因为你非常容易通过排列组合上的尝试排除掉大量的选项。 这个问题最严重的地方就在于 Mission 2，直接把一个现实游戏变成了一款「云游戏」。虽然我知道我要去「京橋駅」解这个谜题，然而只需简单排列组合一下，我就直接解开了这个谜题。这一点在最终谜题（Final Mission）时也会得到体现。这一点我会在之后进一步提及。 渐强设计 随着解开 Mission 2，游戏会通过一个过渡任务将你引向一个非常综合性的挑战。这个过渡任务是个纸笔游戏，并且介绍了游戏中纸张与笔的妙用（这一点在之后会被进一步用到）。在完成过渡游戏后，游戏会把你带到「渋谷」。 然后，在涩谷地下大迷宫里大暴走的可怕时间就到来了。然而一上来就给我玩了一处高级的，由于渋谷マークシティ正在进行促销活动，巨幅海报遮挡住了游戏正常流程中的必备道具，只在旁边放上一个很小的告示牌。涩谷的这个谜题非常综合，几乎要用到套件里的所有道具。这似乎是一个劝退点，如果不能解出这个谜题，几乎无法进行更后面的挑战，可以直接选择放弃。（于是在某个挑战进行的自動販売機前挤满了各种试图寻找答案的人（完全是迷惑行为吧））...","categories": [],
        "tags": ["游戏","设计","混合现实","地下謎"],
        "url": "/2019/01/10/heisei-last-unfinished-game",
        "teaser": null
      },{
        "title": "「为什么我把『は』都听成『わ』了？」",
        "excerpt":"萌娘百科的「君日本语本当上手」里有这么一段描述： 现在该语句常见于目标对象的日语水平不足而引发的低级错误产生笑料时讽刺目标语言能力不足的情况。 … 个人日语知识缺乏的情况下发表高谈阔论 … 为什么我把は都听成わ了？ 「は」做助词时念作「わ」似乎是每个日语学习者遇到的第一个「特例」。似乎每个老师都这么教，读错了别人会笑你，但如果反问其原因，多半只能得到一个形如「约定俗成」这样循环论证的话。 另外假名的「ハ段」本身听起来就怪怪的，ハヒヘホ发的都是清喉擦音 /h/ 的音，唯独フ却是接近 /ɸ/ 的清双唇擦音。 然而这个「は」字的来头其实并不小，小小一个字实际上是日语从「上古日语」「中古日语」再到「中世日语」的语音大变革的见证者。 万叶假名与反切 有一句话叫「研究语法多看古代日语，学习词汇多看现代日语」，这一句话在这里非常适用，要想了解「は」特殊语法含义时的特殊语音现象，我们却是需要多看一些古代日语。我们翻一下《万葉集 巻第十》二一四五（759 年） Shot By ReijiYamashina. CC 3.0 BY-SA [原文]秋芽子之 戀裳不盡者 左鹿之 聲伊續伊継 戀許増益焉 [訓読]秋萩の恋も尽きねばさを鹿の声い継ぎい継ぎ恋こそまされ [仮名]あきはぎの こひもつきねば さをしかの こゑいつぎいつぎ こひこそまされ 这里的「恋」并没有读成我们熟悉的「こい」而是读成了「こひ」。如果我们查「ひ」的万叶假名（万葉仮名），我们会得到 甲类 乙类 比必卑賓日氷飯負嬪臂避匱 非悲斐火肥飛樋干乾彼被秘 我们知道万叶假名是利用汉字的音读和训读来标记日文读音的，那么大致来说，引入时这些汉字的读音应该是和需要读的日文发音是接近的。虽然万叶假名的时间比隋唐更早，但更早我们很难找到相关中文语音资料，我们在这里查这些字在《廣韻》《正韻》等书中的反切读法。 类别 汉字 《廣韻》反切 拟音（王力） 甲类 比 卑履 pi   必...","categories": [],
        "tags": ["日语","语言学"],
        "url": "/2019/01/18/why-i-hear-all-ha-into-wa",
        "teaser": null
      },{
        "title": "推广方言正字的意义",
        "excerpt":"正字，也就是「正体字」，从正俗的角度来看，与「异体字」相对。虽然台湾的繁体中文常被标榜成「正体中文」，但实际上日常的使用中充斥了各种俗字。比如「群」字「《五經文字》羣，俗作群。」，其实是「羣」的异体字。对于繁体中文的正字化有很多人推动。但我今天有觉得，面对我们使用的方言，比如吴语、粤语、闽南话等正字化的推动是一个更重要的问题。为什么我认为推广方言正字比起官话更重要，我想从我熟悉的一个吴语俗字说起。 从一个吴语俗字说起 吴语中有一个词叫「劜闹猛」： 词语 钱乃荣式上海话拼音方案 IPA 劜闹猛 ghak nok mang /gɐʔ noʔ mᴀ̃/ 是「凑热闹」的意思。 无论是电视媒体，还是平时使用，都常常被写成「轧闹忙」。这个字和「劜」的读音是一致的，但从意思上来说不太对。根据《康熙字典》：「《廣韻》於黠切《韻會》《正韻》乙黠切，𠀤音扎。《說文》車輾也。《六書故》車載重，蹍軋有聲也。」这里的热闹，怎么想，都和车辗过好像没有什么关系吧。 一般来说，认为这个正字是「劜」，「《玉篇》勜劜，屈强也。」这个解释就很符合凑热闹的特性。《吴下方言考》卷十一：「吴中以人众不得出而用力挤排为『劜』。」则更是确认了这一观点。然而也并不是没有这么用的，比如用苏白写成的《海上花列传》第 021 回：「俄延多時，翠鳳忽說道：『耐自家算算看，幾花年紀哉。再要去軋姘頭，阿要面孔！』」中的「軋姘頭」就使用了「軋」字。 使用俗字带来的问题 我们知道杰哥的房里有一些「好康」的。这个「好康」到底指的是什么？如果很多没有接触过闽南语的人甚至会误以为是「好看」的意思。然而这里的「好康」指的是「有好处的」，比如一些特卖资讯也常被叫作「好康资讯」。之所以会有这样的误解，很大程度上就是这里的「康」是个除了读音以外完全无关的俗字。其正确写法是「好空」。 词语 方音符号 台罗拼音 好空 ㄏㄜˋㄎㄤ hó‑khang 歹空 歹ㄆㆮˋㄎㄤ pháinn‑khang 空，细缝。好空，就是基于词的衍生义，有好处的。相应地，歹空就是有坏处的。 汉字是同时具有意义和读音的，俗字往往只是借用了读音，而失去了汉字本身的意义。这在很多时候也许问题没有那么大，但对于现在各个岌岌可危的方言保护来说，则变得非常严重。 如果我们的方言只剩下音，而没有了文字本身的意义，那么本质上就是汉语的拉丁化，如果我们还承认那是方块字的话，那其实也只是汉语的「谚文化」而已。在使用谚文的韩语中，「고사」可以指代「故事」、「古寺」、「告祀」、「枯死」等等，在缺乏上下文的情况下，无法理解单词的意思。换句话说，几乎所有反对汉语拉丁化的理由都可以应用于此来反对方言不使用正字上。 使用正字带来的好处 事实上，一旦使用正字，我们对方言的理解会变得简单很多。下面是一些闽南话的例子： 词语 俗字 方音符号 台罗拼音 練痟話 練肖話 ㄌㄧㄢ˫ㄒㄧㄠˋㄨㆤ˫ liān‑siáu‑uē 哭爸 靠北 ㄎㄠ˪ㄅㆤ˫ khàu‑pē 像是「練肖話」听到后，你可能很难反应过来练的到底是什么话，如果望文生义，可能还以为是什么好话。但「痟」是病字头的，指「疯病」。例如「痟人」就是「疯人」，那么「練痟話」毋庸质疑是「练疯话」的意思。 再比如「靠北」，正字写法是「哭爸」。什么场合下会哭？这里指代的自然是「丧父」的场合。所以非常显而易见，这就是一个以丧父为比喻的骂人语。 同样的理论，在其它方言中也很适用。比如粤语中，你知毋知道乜係「唔知」呀？（你知道「唔知」是什么吗？）但如果写成本字，「唔」其实是「毋」。 本字...","categories": [],
        "tags": ["语言学","方言","汉语","吴语","闽南话","粤语"],
        "url": "/2019/02/07/chinese-dialect-orthography",
        "teaser": null
      },{
        "title": "微信红包背后的赌博游戏",
        "excerpt":"序 今天坐车的时候，看到司机的微信在玩一个叫「红包接龙」的游戏，让我提起了兴趣。游戏的规则很简单：群里有 100 个人，首先群主发一个 100 元的红包，然后大家去抢。抢到最多钱的那个人（手气最佳）必须再发一个 100 元的红包，依次类推。乍一听，如果每个人都遵守规矩，那么这就是一个零和游戏。但仔细品品感觉并不那么简单。在这个情况下，是不是资产很容易两极分化，然后其中一些人破产呢？又或者，存不存在一种玩法，使得可以必胜呢？于是我想来好好讨论一下这个问题。 随机算法 要想探讨这个游戏，首先我们需要知道微信红包是怎么进行随机算法的。根据这个知乎回答，答主给出了一个微信红包的算法。由于具体的算法是一个黑盒，那么我们就先建立在这个算法下进行好了，也就是： 每个人随机从 0.01 和剩余平均值两倍之间取一个值，最后一个人拿走剩余全部。 我写了一个小 Ruby 脚本来实现这个功能： require 'descriptive_statistics' require 'securerandom' class RedEnvelope def initialize(money, size) @size = size @money = money end def draw raise 'Empty Envelope' if @size &lt; 1 if @size == 1 @size -= 1 return @money...","categories": [],
        "tags": ["微信","数学","赌博","Ruby"],
        "url": "/2019/03/26/wechat-red-envelope-analyze",
        "teaser": null
      },{
        "title": "关于丼的读音",
        "excerpt":"看到这样一条微博，仔细想了想，其实还挺有趣的。      类比唐扬鸡块就没见到有人读 からあげ 鸡块的，牛肉丼汉日发音混着来，不止是拿日文汉字冒充汉语的问题。还有个问题是，丼在汉语中本来就是多音字，《广韻》《集韻》《韻会》《正韻》同井。又《集韻》都感切，音黕。投物井中聲。也就是说，作井异体字时念 jǐng，作投物井中的声音念 dǎn。那么问题来了，作盖浇饭的时候念啥？   国家语委语言文字信息管理司 2009 年发表过一个叫《日本汉字的汉语读音规范》[1]的文件，里面讨论了许多日语汉字在中文中读音的问题，即讲了拟音的规则，同时也给了一个读音列表，其中丼给出了 dǎn 的读音。   要理解这个问题，我们还是要回到日文「丼」的词源上来。「丼」所指的意思本身并不是盖饭本身。我们现在感觉上盖饭这个词，对应的日语词汇应该是「丼物」，其解释是「ご飯とおかずを一つの丼鉢に盛った日本の料理形式の一つである」，是一种用丼鉢陈放的米饭和配菜。这个丼鉢指的是江户时代「慳貪振り鉢」的一个缩写，以物体投入水中的拟声词「丼」[2]作为缩写。而这个物体投入水中的拟声词确实是个汉语词源的字。   这个字并非我们熟悉的「井」的异体字，这一义项在辞书《集韻》中有相关解释「都感切，音黕。投物井中聲。」按反切法标注了读音「都感切」，中古汉语拟音 /tɒm/，以此推导，我们很容易得出为什么这个字在日文音读会发展成ドン，同时，以此中古音推导现代汉语读音，我们就自然得到了 dǎn。而这便是这份文件中建议将日文盖饭意义的汉字「丼」在汉语中念成 dǎn 的原因。   参考资料     日本汉字的汉语读音规范（草案）   丼／どんぶり - 語源由来辞典  ","categories": [],
        "tags": ["汉语","日语","语言学"],
        "url": "/2019/05/04/donburi-in-chinese",
        "teaser": null
      },{
        "title": "休闲魔蓝玩家的湘南单人四重蓝笋",
        "excerpt":"作为一个蓝笋教徒，上一次也是唯一一次做蓝笋就是 @ngiamzsjit 设计的复旦单人完全四重任务。 那个任务我做了两次，第一次做到一半，被突然出现的绿军炸了。而且那个绿军确实是无心的，一边上课一边随手甩了两个炸。由于那个炸同时涉及一类点和二类点。让修复工作变得异常困难，最后随便连了一通就回家了。 第二次是在夜里做的，当时复旦内部正在施工，有好几个 po 非常难摸，但是做到凌晨还是顺利完工，只不过出校门的时候被复旦的保安问了半天。 然后我就咸鱼了一年。本来以为到了日本 portal 密度变高应该可以多玩玩，结果一年下来连家门口 50 米远的 IFS 都没去。于是就考虑在暑假趁着做个单人四重竹笋把学校盖了。 规划 我大概一个月前开始规划。我们庆应大学湘南藤泽校区在山上，又是休校时间，上山的唯一公共交通工具是公交车，最近的车站分别是 30 分钟车程的湘南台站和辻堂站。这意味着行动一旦开始，绿军就算要来阻挡，至少也需要大概半个小时的机动时间。 校区很小，校区内大约有 20 个左右的 portal，密度很高，理论上应该会好做，但是实际情况形状不够好，在这些 portal 中找不到可能的四重解。最后考虑引入大学在坡下入口处的纪念碑和学校后门几个神社，最后找到了一组解。 我一开始使用的是 @NanoApe 开发的 Konano/Ingress-Field-Design 工具进行规划在。运行过程中发现两个问题，一个是这个项目一开始设计给 Windows 执行的，程序完全由 GB2312 编码编写和编译。实际运行后发现由于我的 portal 名中有日语字符，直接 crash 了整个程序。最后我把编码都换成了 UTF-8 重新编译，输出了四重规划。 然后是输出单人四重的路径，Konano/Ingress-Field-Design 希望用户手动上传一个经过所有 portal 的路径。而我嫌麻烦，用 Mathematica 随手写了个脚本随手写了个枚举所有点 Dijkstra 找最短路的程序，算法时间复杂度是 O(N^2)。结果就被自己写的程序坑了，因为选定的好几组 portal 在两个坡上，这使得我之后行动时不停上坡下坡。...","categories": [],
        "tags": ["Ingress","完全四重"],
        "url": "/2019/08/12/ingress-resistance-shonan-homogeneous-field",
        "teaser": null
      },{
        "title": "日本語字形「关」字攷",
        "excerpt":"我的手機使用的是英文系統，Android 在漢字 fallback 的時候會優先 fallback 到日文字形上，這使得一些簡體漢字的顯示非常奇怪。其中一個特別突出的就是「关」U+5173 字。「关」在我的理解中一般作「関」U+95A2、「關」U+95DC 或「闗」U+95D7 的簡化字。但是在日文字形中，U+5173 是一個只有一半字寬的奇怪字形，甚至不符合一般漢字的原理、放在文章裏非常奇怪。      Weblio 上的 KANJIDIC2 漢字辭典說這是「日本語ではあまり使用されない漢字です。」這顯然不能解答我們的問題。   字源探究   正在我一籌莫展的時候，日本的漢字字源網站 jigen.net 提供了靈感。這個字源字典收錄了「关」字，給出的解釋非常有意思「笑の初文」，也就是說「笑」字最早的寫法，但是網站沒有給出任何參攷資料。如果是這樣的話，我們顯然能在漢語的字源資料中找到相應的蛛絲馬跡。      說起「笑」的異體字，我們第一反應，可能是「咲」字。於是我們以此入手，可以在《康熙字典》中找到：「《集韻》笑古作咲。註詳竹部四畫。或省作𠇄 U+201C4。」這個字今天還是日語的常用字。   於是我直接去找了《集韻》（四庫全書本）的影印資料，內容比《康熙字典》裏的要詳細很多：         笑咲关仙妙切喜也古作笑或省俗作㗛非是文十一    從這裏我們確認，「关」確實在歷史上可以作爲「笑」的意思。   但是把「关」稱爲「笑」的初文的證據卻不好找。1999 年復旦大學中文系張虹倩、劉斐在《中國文字研究》雜誌上發表了一篇論文。認爲：      “笑”字字形流变中”从艸从犬”早于”从竹从犬”,”从竹从犬”又早于”从竹从夭”。然而”从艸从犬”也非”笑”的最早字形,”艸”是”八”的篆形讹变。    這篇文章的立論建立在《說文》中對於「笑」字的原始記載已經遺失。但是這一說法和之後的出土文物不符。隨着更早的楚系簡牘和帛書的出土，我們可以看到在《說文》以前，「笑」字是「从艸从犬」的𦬦 U+26B25 字，「关」作「笑」字初文並沒有有效的證據。      除了這一解釋，還有一個解釋，認爲「关」是「芖」讹變而來。「芖」在 1920 年代出土東漢《熹平石经》周易殘碑顯示是「笑」的省文。而「咲」是「关」加上「口」字旁的俗字。這一說法在邏輯上講得通，而且也可以解釋爲什麼日本語的「关」字形使用了一半的字寬，因爲把這個字視作「咲」的一部分。但這一說法沒有實際的證據證實，所以也只能作爲一個推測來看。   總結   其實深入研究到後半段就發現，無論原因是什麼，日文字形裏的「关」和簡化字的「关」完全就是兩個字。   根本不知道爲什麼 Unicode 分配到了同一個編碼上。   雖然 Unicode 的實作很髒，但是它確實構成了我們每天生活的必需。  ","categories": [],
        "tags": ["日语","语言学"],
        "url": "/2019/08/15/japansese-kanji-5173-research",
        "teaser": null
      },{
        "title": "量子算命，在线掷筊 —— IBM 量子云计算机使用入门",
        "excerpt":"背景 自古以来算命离不开随机现象。古代人使用龟壳的裂纹来进行占卜，但出于动物保护主义，现代社会使用裂纹之类的自然混沌来预测变得不人道。现代算命会使用洗牌等手段产生随机数，但这样的随机很多时候可以得到人为控制，无法真正体现神明的意思。 作者在此提出一个方法，利用量子力学现象进行随机数的发生。我们对于一个量子位（qubit），使其通过一个阿达马门（Hadamard gate）。这个门可以将 $\\vert0\\rangle $ 转换成 $\\frac{ \\vert0\\rangle + \\vert1\\rangle } {\\sqrt{2}} $，即进行状态叠加。当我们此时测量这一量子的状态，那么其波函数会发生塌缩，变为其中一个本征态。且在我们所设计的量子电路中，观察到 0 和 1 的概率应该都是 50%。如果我们今天对量子力学的认识是正确的，那么随机性应该是量子物理的内禀性质，所以我们在邀请真正的上帝来为我们掷骰子，能真正表达量子神明的意愿。 实现 我们采用 IBM 的量子云计算机 IBM Q 进行实现。IBM 提供了丰富好用的量子程序开发的 SDK，并且可以在设计调试完成后，交给线上真正的云量子计算机进行运算，让你足不出户，不需要亲自前往土地庙，也可以听到神明的解答。 我们以「掷筊」为例， 掷筊是一种道教与民间信仰中问卜的仪式；又称掷筶、掷杯、博杯，普遍流传于华人民间传统社会。「筊杯」是一种占卜工具，是世俗之人所用以与神明指示的工具。 我们同时观测两个处于叠加态的量子。若它们都是 0，那么就是「阴筊」；如果都是 1，那么就是「笑筊」；如果两个状态相反，那么则是「圣筊」。具体的量子电路如下： 使用 Qiskit 实现起来非常便利： # Setup Dependencies from qiskit import * # Setup Poe Dictionaty POES = ['陰筊',...","categories": [],
        "tags": ["量子计算","量子物理","物理"],
        "url": "/2019/11/13/quantum-poe",
        "teaser": null
      },{
        "title": "真的走不动了！魔蓝 MD 千叶新城徒步制霸记",
        "excerpt":"点错了 人来日本一年多，这一次 Ingress 社区活动都没有参加过，那叫一个惨。这不是 12 月要到了，赶紧上去看一看最近有什么 Events？诶，这不是有千叶 IFS 嘛，不错，坐电车过去跳个广播体操，刷一下经验回家，开心。赶紧报名。点完报名，不对，我刚刚是不是点的不是 IFS？再一确认，我报名的竟然是千叶新城 MD？！ 那么竟然报名了，那就规划一下怎么制霸吧。 规划一下 思路是这样，所有的任务大体都围绕在三个车站：千叶新城、牧之原、印旛日本医大周围。千叶新城的南面 1、2、6、5、4 围成了一个圈可以回到车站，但是任务 11 和其它任务都连不起来，需要单独往返一次。 千叶新城车站北面的 3、9、10 在一条路上，而 7 8 在另一条路上，两个都必须往返跑。但是我提前查了下 Google 地图，说是可以从 10 的终点步行到 8 的终点，全程 3.8km。 牧之原的 4 个任务几乎都要折返，但是距离都很短。但是其中有一个 BIGHOP 商店的任务，早上 10 点前是不会开门的。 印旛日本医大车站附近有三个任务，其中任务 18 山田桥必须折返，往返 6.4km。我严重怀疑这是因为这个任务的终点是本次 Ingress 的赞助商之一，一家农产品店。 于是，我的想法很简单，先在千叶中央新城把所有南面任务做了，夜里上山比较危险，直接坐出租车去印旛日本医大，完成全部任务后，往回坐一站到牧之原，做完后再往回坐一站到千叶新城上山把剩下全部任务做完。具体的规划如图： 于是就这么愉快地开始吧。 夜间注意？ 我在 0:30 分抵达了千叶新城，绕成圈圈的...","categories": [],
        "tags": ["Ingress","Mission Day"],
        "url": "/2019/12/08/chiba-new-town-mission-day",
        "teaser": null
      },{
        "title": "大猩猩的乐谱有多少错误？—— 13 Archetypes: Listener 解谜翻船记",
        "excerpt":"北京时间 2019 年 1 月 6 日夜间开始了 13 Archetypes 解谜的 Listener 篇。游戏一开始还因为文件名里有 Mfb（某脏话的缩写），导致线索没有如期发布。在一番折腾后，终于看到了这次的谜面，一份乐谱。 这次的解法有多狗血暂且不论，这里就来谈谈这简简单单 9 个小节的乐谱犯了多少个错误，以及这些错误是如何把我带进沟里的。 拍子怎么数？ 五线谱中，我们会看到音符和音符中间会有纵线相隔，这些纵线叫作「小节线」，两条小节线之间叫作「小节」。通常而言，每个小节的节拍数量是固定的。一般在乐谱的开始，或者要变换节拍的时候在小节的一开始写上一个分数，表示之后小节的节拍，这个分数叫作「拍号」。分母表示小节以几分音符为一拍，而分子表示每小节为一拍。比如流行音乐常见的 $ \\frac{4}{4} $ 拍，指的就是以四分音符为一拍，一个小节放 4 个四分音符。 猩猩的这份谱子是 $\\frac{2}{4}$ 拍的，也就是说，以四分音符为一拍，一个小节放 2 个四分音符。就算乐谱的开始和结束的节拍数可以有一定例外，那么聪明的你告诉我，高音部的第 4、6、8 小节，低音部的第 2、5、7、8 小节都是一些什么妖魔鬼怪。 站在事后诸葛亮的角度，我们知道要把两个部的音符直接合在一起看就能产生一个 20 个字符的序列，但问题是，按照这样的写法，这几个小节谁写在前谁写在后是完全不能判断的，除非完全根据图像上的前后关系来写，这对于乐谱来说完全是莫名其妙的。 十二平均律与调 钢琴的调律法称为十二平均律。也就是说从一个 C 到下一个八度里的 C 之间隔了 12 个音。音和音之间的频率的倍率是 $\\sqrt[12]{\\frac{1}{2}}$。我们熟悉的 do re mi fa sol...","categories": [],
        "tags": ["游戏","设计","Ingress"],
        "url": "/2020/01/07/archetypes-listener",
        "teaser": null
      },{
        "title": "从 bopomofo 说起 —— 学习注音符号后对拼音系统的一些新体悟",
        "excerpt":"众所周知，我从小接受的用于标记现代标准汉语的系统是「汉语拼音」。两年前，我决定学习一下「注音符号」。注音符号是以章太炎编创的「纽文」、「韵文」为蓝本，设计的一套汉语拼音方案。其实最早决定去学的原因还是好奇好玩，用一套完全不熟悉的拼读系统来学习自己已经掌握的汉语发音，可以很好从另一个方面来认识汉语的发音系统。最后也证明这样的形式确实帮助我从某种角度重新认识了汉语发音，特别是当这套系统和汉语拼音符号本身产生差异的时候，通过深究差异产生的原因，极大提高了我对汉语发音的理解，可以说是受益良多。下面就来分享一些，我学习过程中遇到的一些有意思的事情。 先放一个我在 YouTube 上看到的「注音符号歌」，让没有听说过这个系统的人有个大概的印象。 （比较可怕的是这个影片播放完后的推荐影片里都是一些真的不明所以非常奇怪的儿童影片） 前四个声母 一个有意思的现象是，虽然「注音符号」的英文叫「Bopomofo Symbols」。但显然，背诵注音符号表的时候，这四个音用的都不是 /o/ 的韵母，而是使用 /ɤ/。「ㄅㄆㄇㄈ」念成 /pɤ/ /pʰɤ/ /mɤ/ /fɤ/。相反，我们在背诵汉语拼音表的时候，倒是真的拼成了 /o/，bo po mo fo /po/ /pʰo/ /mo/ /fo/ 。 不过突然发现，bo po mo fo 小时候老师教的都是发成闭口呼，也就是 ㄅㄨㄛ buo ㄆㄨㄛ puo ㄇㄨㄛ muo ㄈㄨㄛ fuo。但是无论是查大陆的使用拼音的字典，还是台湾的教育部国语辞典，都不会拼入ㄨ，坚持使用开口呼。而且看一些比较权威的汉语拼音或者注音的教学录音，都是录的开口呼，和学得并不一样。 查了一下发现，北京音的「波（ㄅㄛ）坡（ㄆㄛ）摸（ㄇㄛ）佛（ㄈㄛ）」一直到新国音还一直开口呼。拼成 bo po mo fo 很好保留了当时的语音。一直到近几十年，才有人开始不区分开口呼和闭口呼，把「菠菜」念成ㄅㄨㄛ ㄘㄞˋ，这不是什么省略 ㄨ (u) 的结果。 而北京音在晚清到民国早年「多（ㄉㄛ）拖（ㄊㄛ）挪（ㄋㄛ）罗（ㄌㄛ）」虽然也是开口呼，到新国音的时候就已经逐渐转换成闭口呼，也就是 ㄉㄨㄛ ㄊㄨㄛ...","categories": [],
        "tags": ["语言学","汉语","官话"],
        "url": "/2020/01/10/from-bopomofo",
        "teaser": null
      },{
        "title": "元胞自动机 101 —— 13 Archetypes: Humanist",
        "excerpt":"前一晚改论文改睡着了，结果错过了。早上醒来发现题目还挺简单的，来聊一聊谜题的出题思路吧。 一种新科学 元胞自动机是一种由元胞、元胞状态、领域、和状态更新规则构成的一个自动机，其数学表达为： \\[A = (L, d, S, N, f)\\] 换成人话就是说，对于一个 d 维度的有限状态矩阵，每次每个格点的状态更新取决于其上一次中周围格点的状态。元胞自动机是研究混沌现象的一个重要模型，在 Wolfram 出版的书籍《一种新科学》（我个人对这是不是一种新科学持保留态度）中被进行了非常深入的探讨。 Wolfram 把初等一维元胞自动机的全部 256 种规则进行了分类，分成了四类：平稳型、周期型、混沌型、复杂型。 平稳型就是无论初始局面如何，最后终会变成稳定均匀状态。 周期性则是无论初始局面如何，最终会变成稳定的震荡结构，随机性会被过滤。 混沌型指初始局面会演化成一个伪随机或混沌状状态。 复杂型则是上面的一系列组合，可能会出现混沌，而一部分的初始结构会稳定保留，结构于结构会相互作用。（比如像规则 110 被证明是图灵完备的，那么其局面自然会随着初始输入变化有很大变化，可能稳定可能混沌了。） 但这个分类有个很大的问题，就是每一个类别几乎都能找到例外。所以这到底是一种新科学还是一种伪科学还是有点迷幻的。 最有名的元胞自动机 最有名的元胞自动机是 1970 年由英国数学家约翰·何顿·康威提出的康威生命游戏（Conway’s Game of Life）其规则如下： 元胞自动机的维度是 2（运行在 2 维平面上） 状态只有两种，存活和死亡 当周围存活元胞是 0 个或 1 个时，其会死亡（太孤独了，无聊死了） 当周围存活元胞是 2 个或 3 个时，保持原样 当周围存活元胞是 4...","categories": [],
        "tags": ["元胞自动机","混沌","游戏","设计","Ingress"],
        "url": "/2020/01/14/archetypes-humanity",
        "teaser": null
      },{
        "title": "硬核解谜 Prolog 入门 —— 13 Archetypes: Skeptic",
        "excerpt":"13 Archetypes: Skeptic 的谜题由三个单独的谜题组成。这三个谜题唯一的共同点就是，它们都有一个错误。 第二个谜题是「数迷」，第三个就是个数学的填字游戏（crossword），其实没什么好讲的，我们来好好讲一下第一个谜题。 起因 第一个谜题是一个可以完全用一阶谓词逻辑来描述的问题，也就是使用「断言」「量化」和命题的组合来描述。 上了一年我们学校萩野達也教授的计算理论 + 逻辑课。萩野教授是日本研究第五代计算机时候成长出来的计算机科学家，数学基础异常过硬，和现在天天写 JavaScript、Python 还叫苦不迭的这些 CS 学生完全不在一个级别上。 上了萩野一年课之后，我觉得我翅膀也硬了。既然这玩意可以用一阶谓词逻辑来描述，那么应该可以用 Prolog 来解决。第一个题目因为答案选项里有 E、1、3、A、R，因为 13 Archetypes 所有题目都以 13AR 结束，所以显然根本不用看题就知道答案是 E13AR。但如果仔仔细细做一做的话你会发现，其实 10 分钟也做完了。 但是我不管，我就要用 Prolog 来解决，重现一下上世纪 90 年代人工智能研究的荣耀。 Prolog 是什么？ Prolog 是 Programming in Logic 的缩写。Prolog 程序基于一阶谓词逻辑理论。基本就是描述逻辑，然后让 Prolog 解释器来求解。我这里使用的 Prolog 解释器是 SWI-Prolog。SWI-Prolog 是一个从 1987 年开始开发的自由的 Prolog 解释器。我毕竟也不是...","categories": [],
        "tags": ["Prolog","逻辑学","游戏","设计","Ingress"],
        "url": "/2020/01/18/archetypes-skeptic",
        "teaser": null
      },{
        "title": "「Keyboard Moe」从零开始自制键盘（一）：硬件设计",
        "excerpt":"需求探究 我从去年就考虑做一把自己的键盘。其需要满足下面的需求： 便携性：提供不少于 70 键的键盘矩阵，支持蓝牙连接。 电池管理：能够对锂电池进行充放电，并监控电池电量状态。 接口现代：支持 Type-C 接口，可以自动在蓝牙和 USB HID 模式切换（方便装机等场景）。 矢量控制：提供一个类似于小红点的推杆，可以临时替代鼠标。 人体工学布局：由于我的打字键位并不是非常标准，导致现有的人体工学布局用起来非常难受。所以我考虑做一个有两排重复按键的人体工学配列。 一个简单的想法就是基于开源的 GH60 方案二次开发。我手上有一把白嫖来的 Chicory，其设计基本还是和 GH60 一致的围绕 Atmega32u4 设计的方案，蓝牙部分再单独连接到 MDBT40 模组（nRF51822）。这个方案的优缺点很明显，优点是可以很好沿用 AVR 相关的软件栈（特别是 tmk_keyboard）。缺点方面一个是贵，官方套件卖到了 120 美金，光 MDBT40-256RV3 模组就要 7 美金；另一方面 GH60 方案已经几乎把 Atmega32u4 的 I/O 口用完了，要想再加一些我上面的那些功能就很困难。 于是本着吃螃蟹的想法，我决定自己设计一个键盘方案出来。我自己没有专业学习过模拟电路、数字电路，所以也是一遍做一遍学，折腾了大半个月，在去年的 9 月左右进行了第一次的打样。打样的结果非常失败，由于一些设计缺陷，导致最后连上电都存在问题。 芯片方案这边选的是 ESP32，虽然这芯片本职是做 WiFi 的，但是作为蓝牙芯片也是非常便宜的。但是 ESP32 不支持 USB 主控，于是最后又迫不得已加了...","categories": [],
        "tags": ["键盘"],
        "url": "/2020/02/16/moe-keyboard-log-1",
        "teaser": null
      },{
        "title": "「Keyboard Moe」从零开始自制键盘（二）：蓝牙连接与原型键盘矩阵",
        "excerpt":"前情回顾 「Keyboard Moe」从零开始自制键盘（一）：硬件设计 开发板 由于之前设计的主控是 ESP-WROOM-32，而且自动刷机口用的 CP210x 芯片。理所当然，开发板就会买 ESP32-DevKitC ESP-WROOM-32。最近日本疫情也是越来越重了，我就从秋月电子通商网站上买了一片。说实话这网站的硬件也不是特别全，如果最后配 BOM 可能还是要亲自去跑秋叶原。ESP32 自己的官方库不是特别好用，好在已经有兼容的 Arduino 库。PlatformIO 对 ESP32 开发板也做了支持，所以一键就能建出基本的工程结构。 蓝牙连接 我对蓝牙一窍不通，就上网参考一下。我上网看了看找到一个 Gist 样例。跑了一下很容易跑通了。比较奇怪的是，一引入蓝牙的协议栈，Flash 就吃掉 73% 了，其它部分程序可能要省着用了。 Advanced Memory Usage is available via \"PlatformIO Home &gt; Project Inspect\" RAM: [= ] 11.0% (used 35960 bytes from 327680 bytes) Flash: [======= ] 73.6%...","categories": [],
        "tags": ["键盘"],
        "url": "/2020/02/21/moe-keyboard-log-2",
        "teaser": null
      },{
        "title": "「Keyboard Moe」从零开始自制键盘（三）：分区",
        "excerpt":"ESP32 的片上 Flash 应该有 4MB，但是我之前刷入 ROM 的时候，提示可用的空间只有 1280KB，这让我非常困扰。引入一个 BLE 库就已经吃掉了 75% 的 Flash 空间，我一度怀疑我是不是能在有限的空间里完成程序。ESP32 的一个很有意思的特性就是非常容易实现基于 WiFi 的 OTA 固件升级系统。于是我今天研究了一下，结果一研究明白了之前问题的原因，简单来说就是分区表。 PlatformIO 默认的分区表如下： # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x5000, otadata, data, ota, 0xe000, 0x2000, app0, app, ota_0, 0x10000, 0x140000, app1, app, ota_1, 0x150000,0x140000, spiffs, data, spiffs,...","categories": [],
        "tags": ["键盘"],
        "url": "/2020/03/11/moe-keyboard-log-3",
        "teaser": null
      },{
        "title": "一天折腾两个散热系统",
        "excerpt":"我家有两个东西的散热我非常不满意。 一个是我去年买的 Ryzen 2700x。之前看评测都说自带的风扇就挺好用，但是我实际用下来吵不吵已经不是最大的问题了，随便超频到全核 4.0GHz 就打温度墙重启了。最魔幻的是这风扇上还有个 H/L 拨片。查了一下，调到 H 会提高转速上限。这转速就差把风扇塞进服务器机箱来整个暴力扇起飞了。 还有一个是我用了 5 年的 PS4，最近玩点新作风扇就狂转。我原来以为是新游戏比较吃性能。但我最近回去玩了《风之旅人》，结果也狂转。我知道这事麻烦了。头几个批次的 PS4 有散热问题会导致芯片损坏无限蓝灯。虽然我这机器三年质保，但我玩的频率低，所以一直没用坏。如果现在坏了，基本就是重新买了。 材料 坊间传闻过段时间各种电脑配件都要涨价，那么就早买早享受吧。散热器我买了 Antec K240 一体化水冷。这个是我 ITX 机箱能放下的最大尺寸了。而 PS4 我估计是硅脂干了，风扇堵了。买了一罐压缩空气和 MX-4 硅脂。MX-4 的纸面数据很好看，热传导率 8.5W/mK，但一直有传闻说干起来很快。不过我觉得应该能撑到我买 PS5 吧。 搞机箱 换这个散热器还是非常一波三折的。首先先要把旧的散热器拆下来，结果我这一拔直接把 CPU 粘在散热器上一起拔下来了，把我吓了一大跳，我还以为针脚断在卡座里了。结果上网一搜，都说这是个常见问题，要扭一扭，舔一舔才能取下来。 第二个遇到的问题是机箱空间。ITX 机箱太小了，除了要把散热器接上，还需要有 RGB 的排线。我原来还非常小心地给 ITX 搞出了背线理线，这次是把几个机箱风扇拆来拆去挪来挪去，忙活了两个小时终于给装上了。 点亮无法开机，查了一下故障灯是 DRAM 错误。重新插拔后正常开机，但是风扇异响。一个个风扇拔电测试，最后发现某一个机箱风扇轴承里发出了奇怪的噪音。应该机箱风扇是免维护的，轴承是坏了。不过我先试着把轴承密封橡胶圈拆了喷了点 WD-40 进去，结果完美润滑，声音没了，先这样凑活用吧。 搞 PS4 搞完机箱睡不着，就一并把 PS4...","categories": [],
        "tags": ["散热","PS4","游戏","维修"],
        "url": "/2020/03/15/one-day-two-fans",
        "teaser": null
      },{
        "title": "6 小时重构一个字幕工具",
        "excerpt":"某位来自伊朗，现居住在加拿大温哥华的翻译人员曾说过：「ass 能解决所有问题，对于我来说。」 Aegisub 确实是一个非常好用的工具，提供了非常丰富的字幕特效，以及相对高的字幕效率，除了程序很容易崩溃。但对于简单的纯文本字幕，其实流程是可以进一步被优化的。 字幕流程 字幕流程其实就三个部分：文字稿整理（听写或翻译）、打轴、校对。我们可以围绕这三个流程来设计一套最简单最高效的工作流。昨天看 NiceChord 好和弦的时候发现 wiwi 老师写了个类似想法的工具，主要是围绕提高打轴效率的一套程序。我尝试用了一下这套工具，想法是很好，但这代码是写的有点糟糕，介面也基本没有。 于是我考虑重构。重构主要目的如下： 用 Vue.js 实现一套可用的 UI 默认提供视频的播放控制 移除运行时的 Node.js 和 http-server 依赖 基于 File API 读取字幕文件和视频文件 基于 GitHub Actions 和 GitHub Pages 实现自动部署 基于 MIT 开源协议 提供 ESLint 代码风格 Linting 新增动态响应实现控制 新增 i18n 支持 新增字幕的实时预览功能 新增 SRT 字幕编辑有效性校验 新增对 WebVTT 格式的支持...","categories": [],
        "tags": ["字幕","YouTube"],
        "url": "/2020/03/15/fast-srt-subtitle",
        "teaser": null
      },{
        "title": "一些关于音乐游戏的想法",
        "excerpt":"Stanley Parable 中通过对 Stanley 工作的描写，讽刺了一些电子游戏的本质。「屏幕上让 Stanley 按一个键，Stanley 就按下那个键」许多电子游戏事实上就是如此，本质上就是一些充满了 QTE 的播片。如果延伸到音乐游戏上，事实上就延展出了对于音乐游戏「音乐性 (musicality)」的探讨。 如果让我找个音乐游戏中最没有音乐性的，应该就是劲舞团（Audition, X-BEAT）。这东西背后放什么音乐和你敲下去什么东西基本没有任何关系，除了你需要在合拍 (multiple-levels) 上敲空格以外。如果我们追溯音乐游戏的早期，其实音乐游戏制作人对于音乐游戏本身的思考其实是很多样的，像是 1996 年发售的 パラッパラッパー 基本上是一个对节奏的 call and response，从最基本的正拍节奏开始，慢慢引入各种复杂的节奏型。同样类型的其实还有 1999 年的 Space Channel 5，这款游戏甚至没有视觉上即将到来音符的任何提示，完全需要依靠听力和对节奏的记忆来完成游戏。不过这些依赖说唱发展的节奏游戏必然逃不开对唱和模仿的形式。设计得更加精妙的类型是节奏天国（リズム天国），通过把各种节奏型转换成一系列小游戏，视觉反馈是滞后的，用户需要在一些简单练习后通过掌握音乐本身的节奏来自行完成对游戏内按键的判断。 现在比较流行的音乐游戏，主要还是受启发于 1997 年发售的 beatmania 比较大。这类游戏本质上模拟乐器发出声音的节奏，有提前的视觉提示，几乎不会在没有声音的地方按键，相对来说对于节奏感的要求是很低的，上手的难度低。但这类游戏好模仿的一个原因是，简单调整演出和按键方式就可以相对容易做出新游戏，也很容易将现有的歌曲做成游戏内的关卡便于长期运营。增加难度的方法也比较容易，只需要增加音符出现的密度。像是 Space Channel 5 Part 2 最后大决战的演出里搞过一些密集的 16 分音符以外，通常都没有快到按不出来的按键，但是这样的现象在现在的音乐游戏中极其常见。同时，这样游戏也还可以通过提高判定严格程度来提高难度。在节奏天国这样的游戏里，把判定难度放到 10 个 frame 左右大多数人就会很难算准节奏了，而在视觉和听觉实际演奏音符的双重刺激下，经过练习，现代音游里动不动就可以把判定放到 6 个 frame 甚至更低。这也让玩家在通关后的成就感大幅提升。但这样的难度提升其实不是「音乐性」上难度的提升，其实就是单纯「恶心」人而已。当然这里「恶心」不是什么贬义词，我也很吃恶心这套。 但这类游戏有个问题是，这样的游戏对于音乐的理解是很有问题的。因为音乐中不是这里大声就一定是重拍，这种对于节奏的理解实在太过肤浅，基本就是把人当成背谱机器。这就像我们不能通过科幻小说来学习科学知识。你不能看完大刘的《球形闪电》就真的认为「盯着东西看，波函数会塌缩」。但是音乐本身不是一个艰涩的科学知识，它本来就是充满了人天生的对节奏的内在感受，是一个每个人都能享受的东西。所以我们才已经有一些游戏做到了真正把音乐游戏做成围绕「音乐」本身设计的游戏，而不是一个换了皮的 QTE...","categories": [],
        "tags": ["游戏","音乐","随笔"],
        "url": "/2020/04/05/ideas-about-music-game",
        "teaser": null
      },{
        "title": "用 Ruby 学习基本乐理（一）：音高",
        "excerpt":"音乐很有趣，理解音乐很难。但音乐背后的物理、数学原理并没有那么复杂，此所谓乐理。Ruby 是一门编程语言。编程编的是程序，所谓程序，是计算机执行的指令，是阐明计算过程的方式。我们在此使用 Ruby 语言描述乐理，以简单的例子提高自己对乐理的理解，也可以精进自己的 Ruby 编程技能。 从基本音高定义开始 关于音高的基本定义如下： 标准音高 A4 = 440Hz 一个八度有 12 个半音：C, C#, D, D#, E, F, F#, G, G#, A, A#, B 两个八度之间的频率关系差 2 倍 以十二平均律调音，两个相邻音的频率关系差 $ 2^\\frac{1}{12} $ 倍。 我们先设计一个根据到 A4 半音数量计算音高频率的 Ruby 程序： STANDARD_TUNING = 440.0 def frequency_by_offset(offset) STANDARD_TUNING * (2.0 ** (1.0 /...","categories": [],
        "tags": ["音乐","乐理","编程","Ruby","教程"],
        "url": "/2020/04/11/learn-music-theory-with-ruby-1",
        "teaser": null
      },{
        "title": "用 Ruby 学习基本乐理（二）：音程",
        "excerpt":"在上一篇文章里，我们认识了音高。这相当于学会了怎么数数。学完数数的小朋友就要学习加减法了，而音高之间的加减法就叫音程。说到「音程」，最类似的日常词语是「路程」。路程是两点间的距离，音程也是两个音高之间的距离。描述音程有两种方法，一种简单的，一种常用的。 音数 简单的方法就是我们执行数学上的减法运算，也就是所谓「半音数差」。比如 C 和 D 之间隔了 2 个半音。 我们把上次的代码稍稍改一下就可以计算音数差了。既然是音数就是个减法运算，我们就可以通过在 Ruby 中实现一个减法方法，从而可以实现 Tone 类之间的减法运算。 class Tone STANDARD_TUNING = 440.0 attr_reader :frequency, :name, :offset def initialize(name) @name = name @offset = parse_name(name) @frequency = frequency_by_offset(@offset) end def parse_name(name) raise AugumentError unless name.match?(/^[CDEFGAB][#,b]*\\d$/) tone = name[0] sharps = name[1...-1] range = name[-1].to_i...","categories": [],
        "tags": ["音乐","乐理","编程","Ruby","教程"],
        "url": "/2020/04/11/learn-music-theory-with-ruby-2",
        "teaser": null
      },{
        "title": "在我完成了「确定申告」后，讲讲日本的官僚",
        "excerpt":"我真的某种意义上很佩服日本的 paperwork。我原来以为像中国那么官僚的体制下，每次跑政府办点什么事都累得要命。结果我「确定申告」跑下来，真的见识到了更高水平的官僚，把我深深震撼到了。首先「确定申告」是日本的一个税务制度，用来修正一年的个人所得税情况。每个日本居民都需要在来年 3 月前完成，今年因为 COVID-19 的原因延后到了 4 月。   之前宣传说日本的确定申告已经可以在电脑上完成，非常方便。但是非常可惜，这是做不到的。因为「确定申告」需要验证个人番号卡。如果你没有去办这张卡，那么你只要拿着你的待办理的编号和密码就能申办。而像我为了方便开住民票把这张卡办下来的，对不起，除非你的电脑有 NFC 的读卡器，否则你根本没有办法在电脑上办理。   好吧，虽然电脑办不了，手机可以啊，手机天生有 NFC 读卡机啊。在我安装两个国税的 App 和把浏览器换成 Chrome 后，终于可以开始用手机报税了。不过你要小心了，卡读取和验证过程都不能移动卡片，也就是你在不移动你卡片的状态下还要输入密码，一旦中间断开就提示读取失败。好不容易在手机上把申报表格都填好了，然后你要提交的时候，还要用个人番号卡数字签名。然后签名密码和读取密码是不一样的，位数更长，还有英文大小写，你同样要在不移动卡片的情况下输入完这个密码。我前三次没看清要输入的是这个密码，后面发现了，但后面不小心输错了大小写。然后就完美地把我的卡锁掉了，我需要去市役所重新解锁卡片才能继续用个人番号卡申报了。至于在市役所怎么重设密码呢？把新密码写在纸上，让工作人员来帮你重设。真的是「完美」的安全实践。   既然把我卡片锁了，还有什么别的方法可以替代个人番号卡来完成对身份的校验的呢？答案是印章。虽然我不排斥印章可以作为一个 2FA 的选项。但是在日本印章是有着和签名一样的法律效力的。如果放在 100 年前，这个制度可能可以接受。但是现在印章是可以由全自动 CNC 加工出来的时候，完全没有安全性可言。你拿着印章图片去找一个 CNC 的厂就可以轻松制作出能通过日本印章验证的伪造印章。而我的印章甚至根本没有在市役所登记过，但是这个印章就是可以用来申报税务。   然后我一开始是按学生打工的税务减免申报的，但是我收入太高，提示我不适用于这个减免了。但是最后寄送材料里还是提示我要寄送证明我是学生的材料，完全搞不懂这是系统的错误，还是我确实要寄送。然后在我把表格准备好印下来，敲上印章，再邮寄到税务局，终于完成了。   这么想来，日本花了那么大精力推行的个人番号卡有任何用吗？当然有，你邮寄的时候还要记得把个人番号卡复印了一起寄过去，来证明你是你自己。说实话，日本的个人番号卡技术上确实还挺好的，又有 NFC 介面，又可以进行 RSA 签名，应该可以把大多数的 paperwork 给数位化了。就是不知道实际的应用推广怎么做得这么糟糕。   哦对了，在日本负责数字化的 IT 大臣竹本直一同时还是反对数字化的「日本の印章制度・文化を守る議員連盟」（はんこ議連）的会长。这感觉就像你觉得韩国瑜歧视女性把韩国瑜移送性平会，但是高雄性平会主委就是韩国瑜一样。这不就难怪还是把纸印下来，敲上印章来得方便简单了嘛。  ","categories": [],
        "tags": ["日本","政治","生活"],
        "url": "/2020/04/16/after-i-did-my-kakuteishinko",
        "teaser": null
      },{
        "title": "喊麦的音乐性",
        "excerpt":"起因   说实话我对国内的流行音乐非常不熟悉，但最近杨坤批评《惊雷》的事实在是铺天盖地地出现在各种地方，这极大引起了我的好奇。我就去听了一下这首作品，我听完一度不知道怎么评价这个作品。说实话，我个人是一个音感很差的人，我每周都要抽几个小时来迫使自己做一些音感训练和曲式分析的练习。但是我从来没有想过一个作品，可以在 5 秒之内就让我对接下来会发生所有内容在大脑内给出清晰的判断。如果让我给一个主观上的判断说这个东西的音乐性怎么样，我认为真的很差。但是要让我给出理由，其实却并不那么简单。   什么是音乐性？   关于音乐性 (musicality) 本身，我们就不能下一个很明确的定义。不过我们可以拆解一下对音乐的理解。基本上如果单从听觉出发（忽略视觉或者舞蹈之类的因素），音乐可以拆解成作曲、编曲、作词这三个部分。其中作曲还可以进一步的拆分出节奏性、调性、和声等一系列的指标。就我们能想出来的指标，《惊雷》的表现，确实都是很烂的。节奏就是全部都在正拍上的规律节奏，没有任何变化；和声非常单一；词基本没有所谓诗性或者哲学性，甚至我都怀疑这是不是一个合法的中文句子；编曲的话主要就一个电音鼓的 loop，一些合成器采样，土嗨特有的反拍贝斯以及一些音效，毫无技术性可言。   但把这些东西单独列出来，是不是可以直接反推音乐性的高低，我觉得可能是不可以的。比如民谣的节奏也通常是很规律的，某些摇滚和声也是很单一的，流行歌曲的歌词也不一定是有哲学性的，编曲也并不一定要是越复杂越好的。就算我们把这些问题都结合起来，像是一些先锋派作品，甚至是随机音乐、噪音音乐，比如《4 分 33 秒》，我们也可以说它没有节奏，没有和声，没有歌词，没有编曲，但对于《4 分 33 秒》的争议从来不是在这是不是一首缺乏音乐性的作品上。   如果让我来解释音乐性，那么我认为是借由音乐的载体所能呈现的信息量。在古典音乐里，这种信息量体现在精巧的音乐设计；在爵士里，是高超的和声与节奏技巧；在流行音乐中，是音乐工业丰富技术烘托的氛围；在先锋派作品中，是对音乐调性和本质的拷问。那喊麦所要呈现的音乐信息在哪里？说实话我编不太出来。很多人拿这首作品去和数来宝、和说唱做比较。至少数来宝也有很多韵律上的规则，说唱的节奏性以及基于形式的对社会议题的探讨则更是完全不在一个级别上了。   音乐体裁与传播载体   我们换句话说，像杨坤这样从上世纪 90 年代过来的流行音乐人，曾经也是被批判缺乏音乐性的典型。如果我们从今天的角度来审视，当时很多的音乐制作技术放在今天，也可以随随便便来批判技术性上的不足。甚至我之前还点名批评过杨坤在演绎某首作品时表现非常糟糕。但另一种角度上来看，我们的音乐传播载体，其实极大地限制了音乐体裁的发展，从而进一步衍生出这些音乐的创作。像是在夜店中流行的电子舞曲，那些单一的节奏，被滥用的侧链抽吸，其实是为了调动气氛的功能性需要。我很难想象我在家里放这玩意，也很难想象大家在夜店里听舒曼。流行音乐伴随着电视和广播的流行而流行，当我们需要在电视戏剧节目前后放一些主题音乐，如果我们在这里来段爵士，让观众享受于音乐本身高超的和弦技巧，显然不符合我们的需求。这时候曲式结构简单的、朗朗上口的流行音乐就成为了很好的选择。   如果说是什么让喊麦这样的形式流行的话，可能还是短视频。非常惭愧的是，在我写这文章的时候，我没有用过短视频软件。我对短视频的印象还停留在坐高铁时候可怕的外放，在我记忆里是和小孩的哭声在一个级别的。于是我去下载了一个「抖音」用了十五分钟，我大概理解了这种形式在短视频中特有的效果了。   首先这些短视频有着和西方上世纪八十年代「音量竞赛 (loudness race)」一样的问题，软件本身不会对所有视频进行一个合适的压限和响度均衡。这音量忽大忽小的。在短时间内，响度更大的音乐让一般听众感觉声音更好听。所以大家就要比大声，比到把动态范围压成一块砖头。我用了十五分钟，我的耳朵已经极度疲惫，实在受不了这玩意了。做长视频的 YouTube 反而在这块做得很好，在连播的时候很少会当心音量本身的问题，从而几乎终结了「音量竞赛」，没想到同样的灾难在大洋彼岸的中国又开打了。   另一方面，短视频的载体需要让视频在几秒内抓住观众的眼球。因为观众划走这个视频的成本是远远低于其它视频软件的。而这时候这种音量大、节奏猛的东西就有了用武之地。反正一个视频也就几十秒，要想展现什么曲式结构到哪展现啊？你的奏鸣曲连发展部还没写到视频都完了。   总结   其实对喊麦的音乐性的讨论最后还是归结到了快餐文化上了。说到底，其实喊麦和流行音乐一样，还是以娱乐和商业性主导的东西，只是哪个更重。我觉得娱乐本来没有什么错，但是艺术教育的时候，不要混为一谈就行。都知道吃快餐没有吃营业丰富均衡的食物好，但这就是一种发展趋势。搁以前，知道双缝干涉实验的都能理解量子物理的大概；谁能想到一本小说再加上一系列以讹传讹，十个人里有五六个能和你说只要眼睛盯着双缝看干涉就会消失呢？这到底是物理科普的进步，还是退步呢？   去掉这些问题，我希望大家最后想一下这样一个主观问题：   你希不希望你的孩子在幼儿园里学的儿歌都是《方舱医院真神奇》？你希不希望你的孩子从小听的音乐是这样的喊麦？  ","categories": [],
        "tags": ["音乐"],
        "url": "/2020/04/18/musicality-of-hanmai",
        "teaser": null
      },{
        "title": "83 行 Ruby 的蓝调即兴生成器",
        "excerpt":"刻板印象的蓝调 如果让我用代码来生成音乐，我可能优先的类型就是爵士。像是流行音乐，要是来几颗不和谐音，这听起来可就一点都不流行了。但爵士不一样，弹错一次是弹错，如果能连续弹错两次，那就是真正的爵士艺术家了（逃）。但爵士对乐理的要求太高，要想完全靠代码把逻辑理清楚那也不是一件容易的事。一个好的爵士即兴实在是太难了，不过我们可以根据一些刻板印象来做一做。我就想到了十二小节蓝调和声进行以及蓝调音阶，单靠这两个就一下子把需要的伴奏和旋律的模式给提供了一个大概，也许可以试试用代码来自动生成看看。 合成器方面我用的是 Sonic Pi，一款基于 Ruby 的实时编码音乐合成器。其实我之前用过一两次，也不算太会用这个库，也是突发奇想然后现学的。 节奏生成 首先还是要有一个节奏生成器，由于是蓝调音乐，节奏其实可以比较随性。我的基本想法很简单，在给定一个小节里随机填充四分、八分音符。 FOURTH = 0.5 EIGHTH = FOURTH / 2 SIXTEENTH = EIGHTH / 2 def generate_rhythms(candidates=[EIGHTH, FOURTH], remaining_time=FOURTH*4) rhythms = [] while remaining_time &gt; candidates.min rhythm = choose(candidates) rhythms &lt;&lt; rhythm remaining_time -= rhythm end rhythms &lt;&lt; remaining_time if remaining_time &gt; 0...","categories": [],
        "tags": ["音乐","Ruby"],
        "url": "/2020/04/23/auto-blues-generator",
        "teaser": null
      },{
        "title": "女朋友问你「我是不是世界上最好看的女人？」怎么办",
        "excerpt":"如果你女朋友问你「我是不是世界上最好看的女人？」 错误回答： 是的。（除非你见过世界上所有女人） 不是。（会没命） 我不知道。（太虚伪，你女朋友真的比电视上的明星都好看吗？） 正确回答： 我觉得美貌不是一个全序关系 (total order) 或偏序关系 (partially ordered)。 不小于三个标准差吧。 「好看」背后的抽象代数 什么是全序集？ 关于什么是「最好看」，我们需要理解一下序。也就是先定义一下什么是「好看」。如果让我们把好看直接量化成一个数字可能太难了。但是我们通常是可以比较两个人之间谁比较好看的问题的。于是我们可以假设一个二元关系（Binary relation），比如 $\\geq$，使得对于一个所有女人的集合 $S$ 中存在某两个元素 $a$ 和 $b$，如果 $a$ 比 $b$ 好看，我们就记作 $a \\geq b$。 全序集有三个性质： 传递性。即如果 $a \\geq b$，且 $b \\geq c$，那么蕴含 $a \\geq c$。 反对称性。即如果 $a \\geq b$ 且 $b \\geq a$，那么 $a...","categories": [],
        "tags": ["情感","数学","序理论","集合论","统计学"],
        "url": "/2020/05/21/whos-the-most-beautiful-woman-in-the-world",
        "teaser": null
      },{
        "title": "浮点数如何导致了 4.92000008 级地震？",
        "excerpt":"刚收到一个地震速报，说美国发生了一场 M4.92000008 级地震。这个数字实在太过于微妙，我们很少见到精确到小数点后那么多位的地震级数。News Digest 网站迅速删除了这篇报道，并且补上了一篇 M4.9 级的报道。 然而，这么奇怪的地震级数是怎么发生的？ 计算机如何表达小数？ 要想理解这个问题，我们还是要从计算机表达数字的方法开始说起。如果要在计算机里表达小数，有两个主流方法，定点数和浮点数。 定点数很好理解，对于一个二进制，我们人为规定其某几位是整数部分，而另外某几位是小数部分。例如我们对于下面一个 8 位无符号的数字，定义第四位是分割点。 $2^3$ $2^2$ $2^1$ $2^0$ $2^{-1}$ $2^{-2}$ $2^{-3}$ $2^{-4}$ 1 0 0 1 1 0 0 1 那么这么一个 10011001 就代表十进制的 9.5625。 我们很容易看出，这个数字里能表达的最大的数字是 11111111，即十进制的 15.9375。 定点数的点点在哪里是非常关键的，如果点在最后，那么其实就只是整数，不能表达小数，但是能表达的数字最大；如果点在太前面，那么虽然表达小数的能力很强，但是却不能表达大数。 然而浮点数小数点的位置是浮动的。我们可以根据数据的情况来调整浮点的位置。实际的浮点数还有规约和特殊值的问题，不过我们可以暂且简化一下这个问题。 比如对于下面的一个八位数字。前四位表示指数即 $2^{8-x}$ 次方，后面部分表示小数即 $1+y$。 x       y      ...","categories": [],
        "tags": ["算法"],
        "url": "/2020/05/22/how-floating-number-caused-strange-earthquake",
        "teaser": null
      },{
        "title": "BCD、COBOL、千年虫和昭和 100 年问题",
        "excerpt":"上篇文章 里我们讲到了定点数和浮点数的区别，我们认识到这两个数字在精度对待上的差异。但是这两个类型的数字都是二进制数，而有些数字本身就是很难用二进制表达的。 比如我们有一个十进制数 $0.1234$，要将其转换成二进制。如果我们采用 32 位 IEEE 754，其结果是 $00111101111111001011100100100100$，转换回十进制是 $0.1234000027179718017578125$ 造成了一个 $2.717 \\times 10^{-9}$ 的误差。而如果我们定点数，我们先尝试直接转换： 我们至少需要一个 503 位的二进制数才能表达到其开始循环的位数。而且这个在十进制中非常容易表达的数字，在二进制中却变成了非常复杂的循环小数。在一些情况下，我们对于数字在十进制下的精度非常敏感（比如银行），在这种情况下我们应该如何处理数字呢？ BCD (二进码十进数) 对于一个 N 位二进制数，我们很容易知道，其能表达的最大数字量是 $2^N$ 个。十进制数的每一位需要能表达 10 个不同的数字。于是我们有方程 $log_{10}2^N = 1, \\lceil N \\rceil = 4$，我们可以用 4 个二进制数表达 1 个十进制数（忽略多出来的 6 个数字）。也就是如下表的对应关系： 十进制数 8 4 2 1 0 0 0 0...","categories": [],
        "tags": ["算法","日本","COBOL","昭和"],
        "url": "/2020/05/24/bcd-cobol-showa-100-years-problem",
        "teaser": null
      },{
        "title": "证明 tan1° 是无理数",
        "excerpt":"互联网上有一道有名的据说是京都大学的入学题（未经考证），证明 tan1° 是无理数。   看大多数的解法都是反复用二倍角公式和和角公式推到一个 60° 上，归约过程很长。还不如和角公式加数学归纳法一下直接就能证明对所有正整数 tanx° 都是有理数，然后就矛盾了。   特别对于我这种四则运算日常算错的人，少算一个具体数字是一个。   证明过程   证明 $tan1°$ 是无理数，即证明 $tan1°$ 是有理数这一结论为假。   假设存在一个 $x, x\\in \\mathbb{Z^{+}}$，使得 $tanx°$ 是有理数；那么 $tan(x+1)° = \\frac{tanx° + tan1°}{1 - tanx°tan1°}$ 也是有理数。   假如 $tan1°$ 是有理数，由数学归纳法可得，对于所有 $x, x\\in \\mathbb{Z^{+}}$，$tanx°$ 都是有理数。   我们知道 $tan60° = \\sqrt{3}$，而 $\\sqrt{3}$ 是无理数，因此 $tan1°$ 是有理数的假设是错误的。   因此 $tan1°$ 是无理数。   证明完毕。  ","categories": [],
        "tags": ["数学","三角函数"],
        "url": "/2020/06/23/proof-tan1-irrational",
        "teaser": null
      },{
        "title": "Ruby 3 Fiber 变化前瞻",
        "excerpt":"随着 GitHub #3032 的合并，从 Feature #13618 开始的，关于 Ruby Fiber 调度器的讨论取得了实质性的进展。但相关的变化还没有结束。目前正在被讨论与还没有合并的 Issue 还包括 Feature #16786、Feature #16792。这些 Issue 正在围绕 Ruby Fiber 调度器剩余的一些实现进行讨论，这些围绕着 Fiber 技术展开的对并发的实现，将作为 Ruby 3 并发提升的重要来源之一。 Ruby 3 Fiber 调度器会给我们带来什么？如何理解 Ruby 3 Fiber 调度器的引入？如何面对 Ruby 3 Fiber 的新变化？本文就此些问题进行一些讨论。 为什么要有 Fiber？ 现代操作系统一个基本的特性就是允许多任务的执行。这个「多任务」可能是多线程或者多进程系统。对于一个 CPU，一个典型的情况是拥有 8 个左右的核心数，所以理论上只能同时执行 8 个任务。但操作系统同时执行的进程数往往有数千个，并不能「真正」同时运行。而操作系统需要在不同进程中快速切换从而实现多任务的同时运行。 现代操作系统使用的调度系统称为抢占式调度系统。简单理解，就是任务运行过程中，如果其它任务急需运行，操作系统会强制停止当前任务来执行其它任务。更传统的操作系统会使用协作式多任务（cooperative multitasking）系统来实现。也就是一个正在执行的任务必须主动宣布自己可以暂停运行，系统才会把执行权交给其它任务。Windows 3.1x、Mac OS 9...","categories": [],
        "tags": ["Fiber","Ruby"],
        "url": "/2020/07/26/whats-new-in-ruby-3-fiber",
        "teaser": null
      },{
        "title": "拯救老婆 —— MacBook Pro 维修计划",
        "excerpt":"我的老婆不行了 我的 MacBook Pro 15 (late-2016) 真的不行了。 作为一款 16 GB 内存，i7-7820HQ CPU 的电脑，实在是卡得不行。特别是在我搬家后，机器已经卡到一个完全不能忍受的地步。kernel_task 进程自己能吃掉 6 GB 的内存，还能吃掉 250% 的 CPU，一丁点道理都没有。我打开 Activity Monitor 仔仔细细研究着这个 kernel_task 到底在干什么。慢慢地我发现了几个问题。 软件着手研究问题 首先是内存，我的各种后台程序即使在刚刚开机的情况下也能吃掉 &gt; 20 GB 的内存。而物理内存只有 16 GB，这意味着 swap 介入了。这直接体现就是我的硬盘吞吐量惊人。运行一天 kernel_task 硬盘吞吐量高达 2TB。如果这么下去，先不说机器卡不卡，我对我 SSD 的寿命感到怀疑。特别是这一代的 SSD 并不是可更换的，一旦健康状况出问题，会变得非常麻烦。 说到硬盘我就发现了另一个问题，一旦我从 NAS 上大量拉数据到硬盘，CPU 占用也会狂飙。这时候我就想到 Mac 的一个芯片问题 —— Apple...","categories": [],
        "tags": ["Macbook Pro","散热","维修"],
        "url": "/2020/08/12/save-my-macbook-pro-2016",
        "teaser": null
      },{
        "title": "A Walkthrough of Ruby 3 Scheduler",
        "excerpt":"A Failed Proposal When preparing for RubyConf China 2020, I checked the recent patch for Fiber Scheduler in Ruby. When inspecting the example Scheduler, I found it’s using IO.select API in Ruby. IO.select API has multiple different implementations in Ruby. It may probably call poll, large-size select, or the POSIX...","categories": [],
        "tags": ["Ruby","Programming"],
        "url": "/2020/08/18/a-walkthrough-of-ruby-3-scheduler",
        "teaser": null
      },{
        "title": "尝试使用 Ruby 3 调度器",
        "excerpt":"一次失败的提案 在准备 RubyConf China 2020 的时候，我仔细检查了 Fiber 调度器 提出的补丁。当我看调度器的样例代码的时候，我发现其调用的是 Ruby 中的 IO.select API。IO.select API 在 Ruby 内部有多种实现，它可能调用 poll、大尺寸 select、POSIX 兼容的 select 取决于不同的操作系统。于是我想用一些更快的 syscall 来实现，比如 epoll kqueue 和 IOCP。 我做了一个相关的提案但是被拒绝了。主要问题是 Ruby 的 IO.select API 是无状态的。如果没有含状态的注册，这些新 API 的性能甚至会不如 poll。在 Koichi Sasada 跑了 banchmark 证明了这一点后，提案被正式拒绝。在和 Samuel Williams 在 Twitter 上讨论后，它建议我从 Scheduler 的实现上来进行注入，因为 Scheduler...","categories": [],
        "tags": ["Ruby","编程"],
        "url": "/2020/08/18/a-walkthrough-of-ruby-3-scheduler-cn",
        "teaser": null
      },{
        "title": "手写一个 LZW 压缩算法",
        "excerpt":"起因 之前需要在某个单片机下塞点阵字库，为了能多覆盖一些字，准备在字库上做一点压缩。由于常用字相邻编码通常是按形码编码的，所以形状上有很多相似性，因此应该是比较可以压缩的。读取的时候，把一整块相邻编码解压塞到内存里，在内存里做个 LRU 缓存。由于常用字的编码也比较靠近，所以可以一定程度上在覆盖生僻字的同时，达到比较好的读取性能。 不过单片机上写个压缩算法比较麻烦。单片机本身的性能就很差，压缩算法本身约简单越好。最好实现的压缩算法恐怕就是 LZW 了。由于 LZW 的字典是自解释的，也不需要单独构建霍夫曼树，one-pass 一遍读完就解决。于是就考虑写个 LZW。 LZW 基本原理 LZW 压缩需要两件东西，一个是字符集一个是字典。最常见的字符集就是 0x00 到 0xff 的 256 个字符当作字符集，即我们把所以 8-bit 数据看成一个单独字符。字典是这个字符集的组合。字典构成一个更大的空间，通常教科书上的例子的是 14-bit 的字典空间。也就是 0x0000-0x1fff，其中 0x0000-0x00ff 是基础字符集，0x0100-0x1fff 7935 个编号作为可编码的字典。这对于压缩率是比较好的，不过 14-bit 的读取实在太麻烦了，因为它不是 byte 的整倍数。于是我把可编码的字典空间放达到 2 个 bytes 也就是 0x0100-0xffff 65279 个字符，和字符集一起构成一个 65536 字符的空间。 函数签名 头文件和函数签名非常简单： #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include...","categories": [],
        "tags": ["LZW","C语言","算法","压缩"],
        "url": "/2020/09/26/write-lzw-manually",
        "teaser": null
      },{
        "title": "如果 Safari 做不到对，快有何用？",
        "excerpt":"For English version, click here 一个困扰了一周的 bug 2016 年的一天，当我们发现 iPhone 上的浏览器不能正确通过我们的 CDN 鉴权后，我们花了数天的时间来 debug。简单来说当时的情况是，我们需要同时上传 3 个文件，我们会用用户 token 来换 3 个独立的随机数 id，这三个 id 会被 CDN 服务器认为合法，用户可以直接上传到 CDN 上而无需在我们自己服务器上中转。 但 iOS 用户很快就出现了一个奇怪的问题，用户 3 个文件只能成功上传 1 个，剩下 2 个无法正常上传。再进一步调试后我们发现，在上传任意一个文件后，剩下两个 id 变成了非法。再进一步地，我们发现 Safari 获得的 3 个 id 竟然是完全相同的？！ 复现 我很快设计出了能够构建出这个问题的重现： require 'sinatra' get '/'...","categories": [],
        "tags": ["Safari","Apple","Web","W3C","JavaScript"],
        "url": "/2020/10/21/safari-is-fast-but-so-what",
        "teaser": null
      },{
        "title": "Safari is Fast, but So What?",
        "excerpt":"中文版本见此 A Mysterious Bug In a day of 2016, we found that our users could not pass the CDN authentication with their iPhones. We then took several days to debug. The situation is that we need to upload three files at the same time. We use the token of the...","categories": [],
        "tags": ["Safari","Apple","Web","W3C","JavaScript"],
        "url": "/2020/10/21/safari-is-fast-but-so-what-english",
        "teaser": null
      },{
        "title": "真的存在没有反光的眼镜吗？",
        "excerpt":"前几天看某个 YouTuber 说因为眼镜反射很厉害，导致很难打光，想去眼睛店配一副新的眼镜，能减少反光。眼睛店老板号称富士的某款镜片可以「几乎」解决所有反光，花了好几万新台币，买回来发现除了反射从绿色变成了紫色，没有明显差异。   原理   眼镜镜片减少反射的主要原理是利用镀膜。为什么镀膜可以减少反射呢？我们需要一些简单易懂的物理课。我们将光看成一束波（这里就先不讲量子力学里光的特性，太复杂了），当光打在镜片上时，大部分的光会透过去，少部分会发生反射。如果现在在镜片前还有一层镀膜，由于这是两个不同介质的物质，光线会先发生折射，再发生刚刚的透过和反射的过程。同时在镀膜的表面，还有可能再发生一次反射。于是我们得到了两束平行的反射光，反射 1 和反射 2，这两束光有一个相位差 φ，如果这个相位差恰好能使两束光线的波峰和波谷叠加（发生干涉），那么这部分能量就会被抵消，反射光减小；但是又由于能量守恒，所以透过镜片的光线就会增加。所以这一类镀膜也称为「增透膜」。      我们现在从原理上了解了增透膜如何减少反光，接下来的问题是，镀膜减少的反射光由什么决定？基本上就是膜层的折射率乘以厚度（即光学厚度）。因为这个光学厚度的两倍是光线 2 比光线 1 多走的路程，如果这个厚度恰好是半波长的一半（或者半波长的整倍数加 1/4 波长），那么这束光线就能被完全抵消。   实践分析   那么问题来了，最常见的摄影灯光是白光，白光不是单一波长的光，显然不可能由一层增透膜抵消掉。事实上镜片会使用多层镀膜，多层镀膜的效果比较难计算，但要想抵消掉全部白光里各种波长的光也是困难重重。   那么为什么配了这个减少反光的眼镜后，反光从绿色变成了紫色呢？其实也很好理解，因为 400nm 波长的紫光，比 550nm 左右的绿光半波长更短，这要求镀膜材料的厚度和反射率都要更低。波长越短的光对于材料和镀膜的技术要求都更高，自然就更难处理。   事实上，像是相机镜头中，由于通常需要多组镜片，问题会叠加，提高透光率的要求更高。但随便拿哪个再贵的相机镜头出来，放在太阳地下还是能看到绿色、紫色或者红色的反光，没有能完全抵消掉反光的镜片。   总结   不过平心而论，各个镜片厂商对于这个镀膜减反射特性的描述都是很详细的。比如说我随便找了一下蔡司的镀膜规格，说的是主要和传统镀膜比起来降低了 1% 左右的绿光反射率，由于人眼对绿光更敏感，所以比较有效果。但是看着这张图就知道在紫色光的 400nm 部分，反射率还是高达 5%，和传统镀膜并没有明显差异。      所以这个问题的最后，为什么这个几万元的眼镜明明只是降低了 1% 绿光反射，会让人觉得能降低大部分反射，最后花了冤枉钱呢？其实镜片厂没有骗人，详细的资料列得很清楚，但买镜片的客户并不是从镜片厂直接获取的资讯，经过了一层眼镜店老板。眼镜店老板又不用学习光学，他的职责就是怎么卖出更大的利润，结果就是被眼镜店老板骗了。  ","categories": [],
        "tags": ["光学","物理"],
        "url": "/2020/11/10/how-anti-reflective-coating-works",
        "teaser": null
      },{
        "title": "Ractor 下多线程 Ruby 程序指南",
        "excerpt":"什么是 Ractor? Ractor 是 Ruby 3 新引入的特性。Ractor 顾名思义是 Ruby 和 Actor 的组合词。Actor 模型是一个基于通讯的、非锁同步的并发模型。基于 Actor 的并发模型在 Ruby 中有很多应用，比如 concurrent-ruby 中的 Concurrent::Actor。Concurrent Ruby 虽然引入了大量的抽象模型，允许开发高并发的应用，但是它并不能摆脱 Ruby 的 GIL (Global Interpreter Lock)，这使得同一时间，只有一个线程是活跃的。所以通常 concurrent-ruby 需要搭配无锁的 JRuby 解释器使用。然而，直接解除 GIL 锁会导致大量默认 GIL 可用的依赖出现问题，在多线程开发中会产生难以预料的线程竞争问题。 去年在 RubyConf China 的时候，我问 matz 说 90 年代多核的小型机以及超级计算机已经变得非常普遍了，为什么会把 Ruby 的多线程设计成这样呢？matz 表示，他当时还在用装着 Windows 95 的...","categories": [],
        "tags": ["编程","Ruby"],
        "url": "/2020/11/17/ruby-3-ractor-guide",
        "teaser": null
      },{
        "title": "Developing Fiber Scheduler for Ruby 3",
        "excerpt":"中文版本 Ruby 3 Fiber Scheduler I wrote an article in July 2020, Ruby 3 Fiber changes preview (in Chinese), and followed up by another post in August A Walkthrough of Ruby 3 Scheduler. Ruby 3 has updated lots of versions during these months, including ruby-3.0.0-preview1 ruby-3.0.0-preview2 and ruby-3.0.0-rc1, which makes...","categories": [],
        "tags": ["Programming","Ruby","Fiber"],
        "url": "/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en",
        "teaser": null
      },{
        "title": "为 Ruby 3 Fiber 调度器设计事件库 Evt",
        "excerpt":"For English Readers Ruby 3 Fiber 调度器 我在 2020 年 7 月写过一篇文章 《Ruby 3 Fiber 变化前瞻》，以及后来 8 月又写过一篇文章 《尝试使用 Ruby 3 调度器》，简单介绍了 Fiber 调度器。Ruby 3 在这几个月中更新了数个版本，包括 ruby-3.0.0-preview1 ruby-3.0.0-preview2 和 ruby-3.0.0-rc1，其对于 Fiber 调度器的 API 做了更多的改进。 不过正如我之前所说，Ruby 3 调度器实现的只有接口，如果没有配套的接口实现，默认是不会启动的。最近四个月工作实在很忙，抽出了点时间来跟上 API 更新的脚步。这个项目得以进一步更新。 项目地址：Evt Fiber 调度器的使用 我们假设我们现在有一对 IO.pipe，我们往一个里写入 Hello World，然后从另一个里读出来。我们可能会写这样一份代码： rd, wr = IO.pipe...","categories": [],
        "tags": ["编程","Ruby","Fiber"],
        "url": "/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log",
        "teaser": null
      },{
        "title": "用 Ruby 实现飞机自动驾驶仪",
        "excerpt":"krpc 是一个砍巴拉太空计划（Kerbel Space Program）中的插件。可以通过 RPC 来控制游戏。同时有第三方的 Ruby 客户端：krpc-rb。和真实飞机不同的是，在砍巴拉游戏中驾驶飞机是非常痛苦的，在没有插件辅助的情况下，你看不到具体的 GPS 坐标，很多时候看到的都是和飞机驾驶无关的轨道参数，而一些关键的控制参数缺很难获取。同时游戏中也没有自动驾驶仪。特别在航天飞机降落的控制非常难，虽然手动降落不会太有问题，游戏对于重着陆的容忍度很高，但是要控制飞机飞往机场的过程漫长而痛苦。于是我们试试看利用 krpc 来实现正常商用飞机都有的自动驾驶仪的功能。 PID 控制 PID 是自动化控制中最基础也是最常用的控制算法。 我们假设我们要控制汽车油门使得汽车的速度达到某个我们预想中的速度。最直接的想法就是基于距离目标速度的大小来调整油门。也就是说越接近目标速度，我们油门踩得越轻。 但这会产生一个问题，由于我们控制的是给油，油门到加速度控制存在一个延迟，使得我们放开油门后的几毫秒内可能速度还会上升；而当我们看到速度超过放开油门的量越来越大，随着车速越来越快，我们受到的空气阻力实际在增加，车速又会很快下降，而无法与加速度达到平衡，这种情况下我们就会在目标速度附近来回震荡。根据我们按比例控制的激进程度，振幅可能有所变化，最坏情况下我们会震动幅度越来越大，使得系统完全失控。 解决这个问题最直接的方法是引入一个积分项，不单单根据目前速度的误差，也要根据当前加速度的积分，也就是速度来判断。速度越大可能我们需要的油门也要更大一些。 最后我们实际控制还会遇到扰动的问题，我们可能还要根据过去一段时间内误差变化幅度来调节油门大小，比如遇到一个晃动速度快速下降，我们就要快速补一下油门来弥补这个误差。这意味着我们还要引入一个微分项。把这三个结合起来，我们可以得到公式： \\(u(t) = K_pe(t) + K_i\\int_0^te(\\tau)d\\tau+K_d\\frac{d}{dt}e(t)\\) 形成一个通用的 P（比例）I（积分）D（微分）控制器。不过虽然说是通用，这每一项前面的系数比例要想调好也是不容易的。我们会用这个控制器来分别控制飞机的节流阀、滚转和俯仰。 用 Ruby 实现出来是这样的： class PIDController def initialize(kp, ki, kd, clip_min=0.0, clip_max=1.0) @prev_err = 0.0 @integral = 0.0 @kp = kp @ki = ki...","categories": [],
        "tags": ["KSP","Ruby","PID"],
        "url": "/2021/01/08/autopilot-with-ruby",
        "teaser": null
      },{
        "title": "三点几嚟，饮茶先啦 —— 将大马饮料名编译成汉语",
        "excerpt":"近几日马来西亚网友 Gurdip Singh 在 Facebook 发的这个「三点几嚟，饮茶先啦」非常流行。 Facebook: www.facebook.com/100009201465316/videos/2530411593942198 Bilibili 搬运：https://www.bilibili.com/video/av845257746/ 不过马来语的饮料名称非常有意思。某个目前居住在新加坡的朋友 @david92 给我解释了一下，如何在店里点茶喝。基本是一个组合式的语法，非常规律。最基础的茶底是红茶（Teh）或者咖啡（Kopi）。默认饮料是带糖和炼乳的，但你可以重新定制。如果你在后面加上 O 表示不要加炼乳，而 C 表示把炼乳换成鲜奶。类似，Kosong 是无糖，Siu Dai 是少糖，而 Gah Dai 是加更多的糖。 ebnf 语法 我查阅了一些资料进一步完善了一下这个概念，发现这个语法完全是「可编译」的，非常简单。很快，我写了一个 bnf 语法来描述这个概念： &lt;water&gt; ::= \"Kopi\" | \"Teh\" | \"Milo\" &lt;sugar&gt; ::= \"Kosong\" | \"Siu Dai\" | \"Gah Dai\" &lt;milk&gt; ::= \"O\" | \"C\" &lt;thickness&gt;...","categories": [],
        "tags": ["编译","Ruby","语言学"],
        "url": "/2021/07/05/compile-malay-tea-name",
        "teaser": null
      },{
        "title": "一个熟悉又陌生的解谜游戏 —— 东京地下铁 2023 解谜游戏设计分析",
        "excerpt":"2019 年我写过一篇《平成最后的烂尾游戏——东京地下铁 2018 解谜游戏设计分析》。2020 年因为 COVID-19 的原因，没怎么敢出门错过了 Tokyo Metro 地下谜 2019。 有人说我其实玩过 2019，并且还解得很快… 然后我想起来了，确实玩过，并且谜题极其简单，很快速就过了，以至于我甚至没有回家写 review。而 2021 年的地下谜又被取消了，乘着 2023 年地下谜延长了举办时间，当然是务必来日本玩了这个游戏。 下面的内容不单纯是从玩家的角度在看这款游戏，很多时候是从游戏设计的角度在看问题，因此包含 大量剧透，请没有玩过这款游戏并且想要体验这款游戏的玩家，千万不要继续往下读。 国际化 2018 和 2019 两代的东京地下铁解谜是有英文和中文版本的，然而 2023 版本是只有日本语的。 看到这里的我还天真地没有意识到事情的严重性，我想我 也是 JLPT N2 日本语相关的豆知识知道一大堆，想必区区一个解谜游戏那是余裕吧。 我是从新宿歌舞伎町的 Tokyo Mystery Circus 兑换的招待状，第一章的谜题是比较简单的字谜，我大约在门口的小桌子上画了 30 分钟解完的。整体是一个类似 Crosswords 的游戏。其实大多数的谜题答案其实在「車掌さんのコラムシート」里已经给出了，我还在那里疯狂查 Google。很明显，我犯了和 2018 年一样的错误，忘记在教学关仔细查看袋子里的东西。 然后我们进入到第二章，第二章 Group A 由于 3...","categories": [],
        "tags": ["游戏","设计","混合现实","地下謎"],
        "url": "/2024/04/30/tokyo-metro-2023",
        "teaser": null
      },{
        "title": "柯洁能成为九冠王吗？",
        "excerpt":"柯洁（九段）的上一个世界冠军可以追溯到 2020 年三星杯 2-0 胜申真谞（九段），连续三年没有获得世界冠军，上一次和世界冠军失之交臂是 2023 年亚运会负許皓鋐（九段）。不由让人疑问，柯洁在职业生涯再拿一个世界冠军的概率有多少？为了回答这个问题，我们需要一个衡量棋手水平的模型。一个比较简单的方法就是通过 Elo 等级分。 Bradley-Terry 模型 今天的 Elo 等级分和 Arpad Elo 的原始假设有比较大的差异，尤其是在选择的分布上。一般我们会假设使用 Bradley-Terry 模型构造 elo 等级分模型，假设 \\(R(i,t)\\) 是 \\(i\\) 选手在 \\(t\\) 时刻的 Elo 分，即对于两个选手 \\(\\alpha\\) 和 \\(\\beta\\) 在 \\(t\\) 时刻 \\(\\alpha\\) 获胜的概率是 \\[\\begin{align} \\gamma(i,t)&amp;=10^\\frac{R(i,t)}{400}\\\\ P(\\alpha\\gt\\beta,t)&amp;=\\frac{\\gamma(\\alpha,t)}{\\gamma(\\alpha,t)+\\gamma(\\beta,t)} \\end{align}\\] 然而当两位选手下完一盘棋后，后验的结果如何反馈到 elo 分的修正上是一个比较大的问题。一个比较好的算法是 WHR Algorithm，也就是 Go Ratings 使用的算法。 举个例子来说，我们以截止到...","categories": [],
        "tags": ["统计学","Elo"],
        "url": "/2024/05/20/kejie-championship",
        "teaser": null
      },{
        "title": "为什么没有三面体？",
        "excerpt":"前几天我在桌子上放了一个骰塔，塔里放了一组 DnD 骰子。有个同事走过来看到一个正四面体的骰子问：「你这是三面骰吗？」我一愣，第一反应是，这世界上不应该存在三面体啊。不过一细想，为什么没有三面体确实是一个值得思考的好问题。 欧拉示性数 考虑到我们这需要讨论面的数量，第一个会想要用的公式显然是欧拉示性数公式，即： \\[V-E+F=2\\] 欧拉示性数是一个拓扑不变量，即对于所有和一个球面同胚的多面体（三维空间中的凸多面体），都适用于这个公式。其中 \\(V,E,F\\) 分别是顶点、棱、面的个数。带入 \\(F\\) 的数字我们得到： \\[V-E=-1\\] 不过光有这一个公式似乎不足以解释我们的问题。 凸正多面体 如果我们简化一下这个问题，由于是骰子，我们可以先考虑三维空间中的凸正多面体。这个问题古希腊人就有所研究。由于每条棱有两个顶点，且在两个面上。我们定义每个面有 \\(p\\) 条棱，经过每个顶点会有 \\(q\\) 条棱，围绕棱可以得到下面的式子： \\[pF=2E=qV\\] 带入数字 3，得到： \\[3p=2E=qV\\] 我们有三个方程，但是有四个未知数，显然这个问题还是不太好解。好消息是我们知道 \\(p,q,E,V\\) 都需要是正整数这个条件。我们将 \\(V\\) 用 \\(q\\) 代换，能得到： \\[\\frac{2E}{q}=-1+E\\] 将等式两边同处以 \\(2E\\)，得到： \\[\\frac{1}{q}=-\\frac{1}{2E}+\\frac{1}{2}\\] 不妨将 \\(2E\\) 用 \\(3p\\) 替代，我们会得到： \\[\\frac{1}{q}+\\frac{1}{3p}=\\frac{1}{2}\\] 由于，\\(p\\) 和 \\(q\\) 都是正整数，显然地，\\(p\\) 越大，\\(q\\) 越小。我们取 \\(p\\) 最小值 1，有 \\(q...","categories": [],
        "tags": ["拓扑学","欧拉","欧拉示性数"],
        "url": "/2024/06/26/trihedron",
        "teaser": null
      },{
        "title": "基于 Prolog 的 SATB 四部和声生成器",
        "excerpt":"最近在研究 SATB 四部和声，然后感觉如果完全按照和声学教材里的内容，尤其是 18 世纪的和声学概念，几乎就是给了一大堆规则，然后写的是有把人当成一个栈机 (stack machine) 不停搜索不要违背这些规则。既然如此，为什么我们不能设计一个搜索程序，直接将四部和声的配法规约出来呢？ Prolog 很多年前，我写过一篇关于 Prolog 的博客，Prolog 是一个非常方便的，给定一系列逻辑，然后让它从中规约出结果的一门语言。一开始其实我想和之前某篇博客 一样使用 Ruby 和 Sonic Pi 来实现，因为可以所见即所得的获得但发现随着规则越写越多，搜索的实现变得越来越麻烦。这时候就轮到我们 Prolog 出场了。 和弦 如果我们只考虑单个和弦，不处理和弦之间连接的话，我们先定义一个音符，是由其音名、升降调符号和所在的八度构成的，为了方便比较，我们不妨把这个音对应的 MIDI 调值算出来，于是我们可以先写一个这样的代码： % Notes key_note(c). key_note(d). key_note(e). key_note(g). key_note(a). key_note(b). semitone_offset(c, 0). semitone_offset(d, 2). semitone_offset(e, 4). semitone_offset(f, 5). semitone_offset(g, 7). semitone_offset(a, 9). semitone_offset(b, 11). note_offset(-2). note_offset(-1). note_offset(0)....","categories": [],
        "tags": ["Prolog","逻辑学","音乐","乐理","合唱"],
        "url": "/2024/07/21/satb-generator",
        "teaser": null
      },{
        "title": "半导体从入门到放弃（上）—— 半导体和数字电路",
        "excerpt":"半导体芯片是现代电子设备的核心，从电视遥控器到超级计算机，无不依赖于这些微小的硅片。然而，芯片设计和制造是一个复杂的过程，涉及深厚的物理、化学知识和精密的工程技术。本篇文章旨在为读者提供一个全景式的了解，涵盖从半导体材料的基本原理到数字电路设计，以及从芯片体系结构到生产工艺的各个环节。 需要注意的是，本篇文章并不会深入探讨具体的设计方法或实现手段，除非特别举例说明。本文的目标是帮助读者理解半导体行业的核心概念，让你在面对与芯片相关的新闻或话题时，能够辨别出无良媒体的误解或错误。然而，读完这篇文章后，读者可能不会成为半导体行业的专家，甚至连入门都谈不上。但会对芯片设计背后的原理有更清晰的认识。 目录导航 半导体从入门到放弃（上）—— 半导体和数字电路 半导体从入门到放弃（中）—— 局域性原理与芯片设计 半导体从入门到放弃（下）—— 量产技术（未完成） 半导体 在讨论芯片设计的物理基础时，我们首先要了解半导体材料，尤其是硅（Si）。硅是最常用的半导体材料之一，其电子结构对于理解它的电学性质至关重要。但在理解以硅为基础材料的半导体是什么之前，我们先要对「导电」这件事情本身进行一些基础知识的理解。 能带理论 在单个原子中，电子只能处在特定的能量水平（称为能级），而当许多原子紧密排列形成固体材料时，这些能级会相互作用，形成连续的能量带。 我们可以将能量带想象成一座楼梯，每个台阶代表不同的能量水平。电子处在这些台阶上，它们可以在不同的台阶（能量水平）之间跳跃。当你爬得越高，你的能量就会越大（如同现实中的重力势能），反之则越小。这时候我们需要引入三个概念： 价带：相当于楼梯的底部，是电子「站立」的稳定位置。这里的电子与原子核紧密结合，能量较低，移动自由度较小。电子在价带中往往是处于相对稳定的状态，无法自由移动。 导带：相当于楼梯的上方，是电子可以自由「行走」的地方。电子一旦到达导带，它们就获得了足够的能量，可以在晶体中自由移动，从而形成电流。 带隙：价带和导带之间有一段「空隙」，称为 带隙（band gap），相当于楼梯上的一大步。这一步（能量差）决定了电子从价带跃迁到导带的难易程度。材料的导电性主要取决于这个带隙的大小。 导体：没有带隙的楼梯 在导体中，导带和价带是重叠的，或是非常接近，没有明显的带隙。因此，电子不需要“跨越”任何能量差即可进入导带。例如铜的电子在最外层很容易进入导带，因为它的价带和导带几乎重叠。可以想象在铜中，电子就像是在平坦的地板上行走，不需要额外的能量跃迁到导带，因而铜能够很好地导电。 绝缘体：巨大带隙的楼梯 与导体不同，绝缘体（如玻璃、橡胶）具有非常大的带隙，这意味着电子要从价带跃迁到导带需要非常高的能量。在正常条件下，电子几乎不可能跨越这个巨大的能量差。例如石英的带隙非常大。电子被牢牢困在价带中，几乎无法进入导带。这就好像电子被困在楼梯的底部，无法跃过楼梯的高台阶，导致它无法传导电流。 半导体：微妙的中间状态 半导体位于导体和绝缘体之间，其带隙较小，因此电子在某些条件下能够跃迁到导带，产生导电现象。硅（Si）作为一种典型的半导体材料，它的价带和导带之间有一个适中的能隙，这个能隙的大小允许我们通过外部手段（如加热或施加电场）让电子越过这个「台阶」进入导带。 硅的带隙约为 1.12 电子伏特（eV），比导体的重叠带大，但比绝缘体的小。通过适当的能量输入（如施加电场或光照），硅中的电子能够从价带跃迁到导带。这使得硅在不同条件下既可以作为绝缘体使用，也可以作为导体使用，这正是半导体材料的独特之处。 掺杂 硅原子在元素周期表中位于第十四族，其最外层有 4 个价电子。这些电子通过 共价键 与邻近的其他 4 个硅原子形成强力的化学键。硅的晶体结构被称为 钻石结构，是一种立体网状结构，在这个结构中，每个硅原子与周围 4 个硅原子通过共价键相连，没有任何自由电子，形成非常稳定的结构。 在纯净的硅晶体中，这些共价键牢牢束缚着硅原子的价电子，使它们无法自由移动，因此在低温或常温下，硅的导电性较弱。但硅可以通过 掺杂（doping），即引入微量的杂质原子，来改变它的电学性质。掺杂可以显著影响硅的 能带结构，从而使其导电性能发生变化。 当硅晶体中引入 五价元素（如磷、砷）时，这些原子带有 5 个价电子，比硅的 4 个价电子多一个。这个多余的电子并不参与共价键的形成，因此成为一个自由电子，可以很容易地跃迁到导带中。由于多了一个自由电子，这样的掺杂后的半导体被称为 「N 型半导体」。...","categories": [],
        "tags": ["半导体","数字电路","芯片","电路"],
        "url": "/2024/10/05/semiconductor-01",
        "teaser": null
      },{
        "title": "半导体从入门到放弃（中）—— 局域性原理与芯片设计",
        "excerpt":"半导体芯片是现代电子设备的核心，从电视遥控器到超级计算机，无不依赖于这些微小的硅片。然而，芯片设计和制造是一个复杂的过程，涉及深厚的物理、化学知识和精密的工程技术。本篇文章旨在为读者提供一个全景式的了解，涵盖从半导体材料的基本原理到数字电路设计，以及从芯片体系结构到生产工艺的各个环节。 需要注意的是，本篇文章并不会深入探讨具体的设计方法或实现手段，除非特别举例说明。本文的目标是帮助读者理解半导体行业的核心概念，让你在面对与芯片相关的新闻或话题时，能够辨别出无良媒体的误解或错误。然而，读完这篇文章后，读者可能不会成为半导体行业的专家，甚至连入门都谈不上。但会对芯片设计背后的原理有更清晰的认识。 目录导航 半导体从入门到放弃（上）—— 半导体和数字电路 半导体从入门到放弃（中）—— 局域性原理与芯片设计 半导体从入门到放弃（下）—— 量产技术（未完成） 局域性原理 物理学家眼中 在经典电磁场理论中，电场和磁场通过 麦克斯韦方程组 描述。电磁相互作用并不是瞬时传播的，而是通过电磁波以 有限的光速 进行传播。电磁波的传播速度直接体现了局域性原理：一个物体在某个时刻产生的电磁波只会在光速允许的范围内影响其他物体，超出该范围的物体无法感知到这一相互作用。 坡印亭矢量（Poynting vector）是电磁场中描述能量传递的向量，它定义了电磁能量在空间中如何随时间传播。其公式为： \\(\\mathbf{S} = \\mathbf{E} \\times \\mathbf{H}\\) 其中 E 是电场强度，H 是磁场强度。坡印亭矢量的方向代表能量流动的方向，大小表示电磁能量的传输速率（能流密度）。电磁能量流的传播是局域的，即能量传递遵循空间中的场和场之间的相互作用，并且传递 不会超越光速。电磁场的这种 局域性 反映了能量与作用力无法瞬时传递到无限远处，而是有速度限制的，这也是因果律的体现。 在 广义相对论 中，时空中的事件只能影响位于其 光锥 内的事件。光锥定义了从某个时刻出发，光以光速传播能够到达的所有点的范围。光锥以外的区域是无法被该事件影响的，体现了相对论中的局域性。 在 量子场论 中，电磁场是一个 规范场，其量子化后的激发对应于 光子。光子是电磁力的传递者，即任何带电粒子之间的相互作用是通过光子交换来实现的。量子场论通过光子与带电粒子的相互作用解释了电磁现象。 根据量子场论的原则，电磁场的量子化意味着电磁相互作用是由光子的场量子在特定的时空点中以局域的方式激发、传播和相互作用的。也就是说，电磁场只在它所作用的局部时空区域内起作用，并且光子只能在 有限的范围内 进行传播，受 光速的限制。 在计算机科学家眼中 根据物理学中的局域性原理，信号和信息的传播速度是有限的，特别是受光速限制。这意味着在计算机系统中，处理器、内存和存储设备 之间的通信速度不能超越这些物理限制。如果处理器频繁访问远距离的存储单元（如主存或磁盘），由于信号传输时间长，系统性能将受到严重影响。因此，设计计算机系统时，必须依赖局域性原理将常用数据尽可能存储在靠近处理器的高速缓存中。 计算机的局域性原理主要体现在两个方面： 时间局域性 空间局域性...","categories": [],
        "tags": ["半导体","数字电路","芯片","电路"],
        "url": "/2024/10/05/semiconductor-02",
        "teaser": null
      },{
        "title": "sin(x) = 2 的数学对决",
        "excerpt":"这周末我在微信朋友圈搞了个有趣的数学对决。我给 24 小时内所有解出了这个谜题的人都发了 50 元的红包。题目本身其实不算很难，甚至是一道复分析书上的例题。不过试图使用 LLM 来算这道题的人表现出了很神秘的高度一致的错误… 题目 \\[\\sin(x) = 2, (x \\in \\mathbb{C})\\] 提示 欧拉公式 注意解的数量超过 1 个 二次方程求根公式 题解 \\(sin(x)\\) 在实数范围内的值域是 \\([-1,1]\\)，等于 2 这种事情想都不用想是复数。如果有背到过的话，可能会知道 \\(sin(z)=\\frac{1}{2}ie^{-iz}-\\frac{1}{2}ie^{iz}\\)。但这个式子反正每次我用的时候都背不出来，不过我们可以通过很轻松的方法推出来，并且在这题中不需要把化简都做完反而代入计算的时候更快。 欧拉公式 因为欧拉公式 \\(e^{i\\theta} = cos\\theta + isin\\theta\\)，我们将所有的 \\(\\theta\\) 替换成 \\(-\\theta\\)，我们有 \\(e^{-i\\theta}=cos(-\\theta) + isin(-\\theta)\\)。这时候我们需要利用一点点的「奇变偶不变，符号看象限」的高中数学三角函数技巧（诱导公式），当然像我连这个都差点忘了，直接画一下函数图看一眼就会了。由诱导公式（函数的奇偶性）得到 \\(e^{-i\\theta} = cos(\\theta) -isin(\\theta)\\)，将欧拉公式和这个式子相减，我们就可以得到 \\(e^{i\\theta}-e^{-i\\theta}=2isin(\\theta)\\)，把 \\(2i\\) 移动一下，就得到了我们想要的关于 \\(sin(z)\\) 函数的一般式子： \\[sin(z)...","categories": [],
        "tags": ["数学","数学分析"],
        "url": "/2024/11/18/sinx-equals-2",
        "teaser": null
      },{
        "title": "写在甲辰年末",
        "excerpt":"今天有朋友问我：「你居然没点评 DeepSeek，不习惯。」 好吧，看来大家还是喜欢看我大放厥词。 Deepseek R1 的论文[1]我上周就已经看了，当时是很震撼的。我看到那个 rule-based RL 的时候，真得有种 Aha 的感觉。一些人可能知道，受一些论文[2][3]的启发，我们在研发的系统广泛受益于 grammar-constrained sampling 下对 LLM 的调用的效果。但我也从来没有意识到过可以通过如此精巧得构造使得一个自监督的 RL 可以产生如此精妙的效果。但今天我想跳出纯学术角度来讨论一些问题。 我想我们应当确立一个基本的共识。Scaling Law[4] 和 Moore’s Law 一样，是一种结果而不是原因。科技的进步从来没有银色子弹。没有人会相信 Moore’s Law 会成立，大家不但知道晶体管密度不可能持续地翻倍下去，也知道计算机性能不可能持续地翻倍下去。但是无论是诸如 FinFET、Gate-All-Around 的半导体器件工艺的进步，或者像是 DUV、EUV、浸润式光刻等制造技术的进步，以及从微架构设计和体系结构出发的芯片设计水平的进步，是一代代人智慧和努力的结果让 Moore’s Law 看起来仍然成立。类似地，AI 水平的进步绝无可能是单纯依赖参数量、算力、数据集的进步。如果有人告诉你今天 AI 发展会逐渐停滞，因为互联网上所有数据集都被 AI 吃光了[5]，你不觉得可疑吗？如果一个人类有能力理解互联网上那么多数据，它会像这些 AI 一样笨吗？真的不是显而易见地，我们的方法出了什么问题吗？ 当然资本市场自有它自己的看法。虽然我不止一次公开说过，在我心目中 Sam Altman 就是个傻◯，但我不否认 Sam 是一位优秀的 CEO，资本市场对他的吹捧是他应得的。我认为问题的本质是政治问题。只要人类社会存在一天，就会有一天主义。归根究底是我们就无法避免对有限资源争夺的分配问题。Sam Altman 把 AI...","categories": [],
        "tags": ["AI"],
        "url": "/2025/01/28/thoughts-about-deepseek",
        "teaser": null
      },{
        "title": "当我们吹嘘量子并行计算的时候",
        "excerpt":"昨天晚上和老金聊到微软的 Majorana 1 的时候，我说了一段关于量子计算研究的评论。我觉得很有必要再说一次。 我想起 2016 年加拿大总理特鲁多给记者解释量子计算的视频在互联网上被疯传[1]。特鲁多对量子计算的解释概括来说是基于「量子并行计算」概念的，也就是说传统的比特只能同时表达 0 或 1，随着位数的增加，为了在一个庞大的搜索空间中寻找到答案，我们需要枚举所有的答案；而量子比特（qubit）可以同时表达 0 和 1，因此一组 qubits 可以同时表达所有可能的答案，并行地找到我们想要的答案。 我对「量子并行计算」概念的评价就是「正确的废话」，类似的诠释出现在许多科普读物、维基百科等地方。我认为当特鲁多背诵这段内容的时候，他必然是对量子计算一无所知的。 我们不妨考虑一个问题。如果一组量子比特（qubits）在同时表达 0 和 1，那么我们如何「找到我们『想要的』答案」呢？这个「想要」事实上是相当关键的。因为不管量子比特如何表达，基于玻恩公设（Born rule）[2] [3]，你最终只能通过测量（measurement）得到其中一个结果，这个结果还是 0 或者 1 的，其概率为量子态处于本征态的概率幅绝对值的平方。如果量子是单纯地同时表达了所有可能的答案，那么测量的结果就是在状态空间下的随机数发生器，那不叫量子计算，那个叫量子算命[4]。 秀儿算法（Shor’s Algorithm）[5]向我们展示了量子计算不是算命的关键差异。其通过引入一部分量子算法，使得其可以更快地寻找到余数循环的周期，从而帮助进行大数的因数分解。其中这个寻找余数周期的方法，被称为量子傅里叶变换（Quantum Fourier Transform, QFT）。这其中最巧妙的部分不是把量子比特看成同时表达 0 和 1 的数字，而是看成一个波函数。通过构造波和波之间巧妙的干涉作用，相干相消后使得我们「想要的答案」在其本征态的概率幅大幅上升，而其它答案大幅下降。基于这样的前提，我们才能通过测量其量子态，得到某个我们想要的答案。 这个算法充分体现了量子计算和传统计算机计算方式的根本不同，它们之间以目前的情况来看，不存在简单的替换关系。把量子计算理解成飞跃式的并行计算机是没有道理的。更何况今天量子计算机在工程上仍有大量东西值得解决。 像 Majorana 1 试图构造凝聚态物理上等效的 Majorana 费米子[6]，从而使得其具有拓扑的 qubit 性质，我个人的感觉是在量子退相干问题上可能会有更好的稳定性。首先我不太懂凝聚态，其次我不太懂拓扑，但从论文上看，好像论文作者也不太确定这是不是 Majorana 费米子。但这其实是量子计算在学界上一个很小的突破，和 PR 稿上的大鸣大放可以说是没有任何关系了。 当然以今天量子计算的进展，还是得编故事的。算了，你总不能指望投资人真的理解啥是什么量子态本征态，算个 sin...","categories": [],
        "tags": ["量子计算","量子物理","物理"],
        "url": "/2025/02/28/how-quantum-computing-works",
        "teaser": null
      },{
        "title": "上海国际电影节大卫林奇通宵场观影感受",
        "excerpt":"昨天 11 点看了上海国际电影节 6 个小时的大卫林奇通宵场散场电影连映《橡皮头》、《妖夜慌踪》、《穆赫兰道》（ Eraserhead + Lost Highway + Mulholland Drive）。观影完之后，有一位观众（下面简称 A）在电影院发表了对《橡皮头》放映非常大的意见。A 的核心观点是觉得杜比厅放映这部电影画面大量出现全黑和全白、画面闪烁的对比度实在太大；但是 A 把问题怀疑到了杜比放映技术本身上，排除了 4K 修复的问题。但其实这个问题几乎广泛存在于所有数字放映电影上，尤其是数字修复电影上，我们不妨可以来讨论一下这个问题。 亮度和量化 放映对亮度是有严格定义的。如果你购买过电视，我们知道通常我们用 nit（尼特）单位来衡量亮度，1 nit = 1 cd/m²。常见的广电标准中，sRGB 色域中的白点一般描述为一个 100nit 亮度的 6500K 色温的点表示画面中最亮的点。 数字放映下的另一个非常重要的概念是量化。一个 8bit 的量化意味着我们从最暗到最亮能区分出 256 种不同的亮度；HDR 内容通常需要 10bit 的量化，这使得我们可以区分出 1024 种不同的亮度。然而人类对亮度的认知并不是线性的。显而易见地，画面中偏暗的内容人更容易分清它们的亮度区别。这意味着我们对这 256/1024 种亮度的分配也是不均匀的，这需要通过应用 Gamma 曲线来呈现出画面的更多细节。 在今天做得比较好的电影院里，针对 DCI-P3 色域下的颜色和亮度都能给出非常严肃和准确的测量和定义。杜比放映设备的量化支持一般也都有 10bit，这其实提供了很好的色彩科学条件，只要放映的内容本身是按照这样的条件处理的。然而这根本做不到。 旧胶片的局限 然而电影归根究底是艺术，不是准确还原。这件事情在胶片时代更是尤其有难度。...","categories": [],
        "tags": ["电影","大卫林奇","色彩科学"],
        "url": "/2025/06/22/siff-david-lynch",
        "teaser": null
      },{
        "title": "1/x + 1/y = 8/79 的整数解",
        "excerpt":"刷到个视频，讲的是 $\\frac{1}{x} + \\frac{1}{y} = \\frac{8}{79}$ 的解。当然我觉得题目漏了个条件，是整数解，因为如果不加整数条件的话，该问题的解是无穷多的。 原题解 原题解发明了一种令人费解的方法叫做「扩大法」，两眼一瞪，就把 $\\frac{8}{79}$ 变成 $\\frac{80}{790}$，显然地，$x=10,y=790$ 或者 $x=790,y=10$。 我认为这个解法没有任何数学意义，也不具有任何启发性。因为它并没有给出任何数学上的证明，为什么扩大法可以得到整数解。实际上，这个方法是一个注意力惊人的凑数巧合。 我觉得教这种方式的老师根本不配当老师，除了误导学生之外，对于数学的学习没有任何帮助。数学的学习应该是严谨的，应该是有逻辑的，而不是这种「扩大法」的凑数。 思考 实际上，这是一个丢番图问题。考虑到对于一般的丢番图方程，没有通用的解法。我们不妨先将方程变形为： \\[\\frac{1}{x} + \\frac{1}{y} = \\frac{p}{q}\\] 其中 $p,q$ 是互素的整数。我们可以将方程变形为： \\[\\begin{aligned} \\frac{1}{x} + \\frac{1}{y} &amp;= \\frac{p}{q} \\\\ pxy - qx - qy &amp;= 0 \\\\ pxy − qx − qy + \\frac{q^2}{p} &amp;= \\frac{q^2}{p}...","categories": [],
        "tags": ["数学","数论","不定方程"],
        "url": "/2025/06/25/diophantine-equation",
        "teaser": null
      },{
        "title": "如何在 Godot 里跑浏览器？",
        "excerpt":"最近我们在做 CRPG 游戏项目 Engram 的时候遇到了一个很典型的痛点：游戏 UI 开发实在是太折磨人了。 用游戏引擎自带的节点系统去堆一个复杂、响应迅速、有动画、有状态管理的界面，效率低得让人想撞墙。作为对比，网页开发那边有几十年的工具链积累——HTML、CSS、JavaScript，还有 React/Vue 这些现代框架，配合 Chrome DevTools 这种神级调试工具，开发体验简直是降维打击。 当时我就在想：如果能在 Godot 里直接用网页技术写 UI 会怎样？ 市面上现有的方案我们都试了一圈，结果都不太理想： godot_wry：基于系统原生 WebView，轻量是轻量，但只能覆盖在顶层，没法融入 3D 场景，而且不同系统的浏览器内核行为不一致，调试起来能要人命。 gdcef：基于 CEF 的 C++ 集成，也是个老牌项目了，但它是纯软件渲染，帧率很难看，4K 下能稳定 15 帧都不容易。 我们在 Engram 的 Demo 版本中使用了 godot_wry。我们甚至给上游交了不少补丁。上线后大概有 50% 的启动崩溃都是因为它在旧版 Windows 上找不到 Edge WebView2，然后 Linux 支持也有问题，继续研发下去能完全改好的希望很渺茫。 既然没有好用的，那就自己造一个吧。于是就有了 Godot CEF。 什么是 Godot...","categories": [],
        "tags": ["Godot","Rust","Chromium","CEF","图形","游戏开发","UI"],
        "url": "/2026/02/14/godot-cef",
        "teaser": null
      }]
