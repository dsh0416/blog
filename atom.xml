<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://coderemixer.com/atom.xml" rel="self" type="application/atom+xml" /><link href="https://coderemixer.com/" rel="alternate" type="text/html" /><updated>2024-06-27T08:40:37+08:00</updated><id>https://coderemixer.com/atom.xml</id><title type="html">Coderemixer 代码混音师</title><subtitle>一个用来发牢骚的网站，以至于无法对所说的话负责。</subtitle><author><name>CodeRemixer</name></author><entry><title type="html">为什么没有三面体？</title><link href="https://coderemixer.com/2024/06/26/trihedron" rel="alternate" type="text/html" title="为什么没有三面体？" /><published>2024-06-26T09:22:00+08:00</published><updated>2024-06-26T09:22:00+08:00</updated><id>https://coderemixer.com/2024/06/26/trihedron</id><content type="html" xml:base="https://coderemixer.com/2024/06/26/trihedron"><![CDATA[<p>前几天我在桌子上放了一个骰塔，塔里放了一组 DnD 骰子。有个同事走过来看到一个正四面体的骰子问：「你这是三面骰吗？」我一愣，第一反应是，这世界上不应该存在三面体啊。不过一细想，为什么没有三面体确实是一个值得思考的好问题。</p>

<h2 id="欧拉示性数">欧拉示性数</h2>

<p>考虑到我们这需要讨论面的数量，第一个会想要用的公式显然是欧拉示性数公式，即：</p>

\[V-E+F=2\]

<p>欧拉示性数是一个拓扑不变量，即对于所有和一个球面同胚的多面体（三维空间中的凸多面体），都适用于这个公式。其中 \(V,E,F\) 分别是顶点、棱、面的个数。带入 \(F\) 的数字我们得到：</p>

\[V-E=-1\]

<p>不过光有这一个公式似乎不足以解释我们的问题。</p>

<h2 id="凸正多面体">凸正多面体</h2>

<p>如果我们简化一下这个问题，由于是骰子，我们可以先考虑三维空间中的凸正多面体。这个问题古希腊人就有所研究。由于每条棱有两个顶点，且在两个面上。我们定义每个面有 \(p\) 条棱，经过每个顶点会有 \(q\) 条棱，围绕棱可以得到下面的式子：</p>

\[pF=2E=qV\]

<p>带入数字 3，得到：</p>

\[3p=2E=qV\]

<p>我们有三个方程，但是有四个未知数，显然这个问题还是不太好解。好消息是我们知道 \(p,q,E,V\) 都需要是正整数这个条件。我们将 \(V\) 用 \(q\) 代换，能得到：</p>

\[\frac{2E}{q}=-1+E\]

<p>将等式两边同处以 \(2E\)，得到：</p>

\[\frac{1}{q}=-\frac{1}{2E}+\frac{1}{2}\]

<p>不妨将 \(2E\) 用 \(3p\) 替代，我们会得到：</p>

\[\frac{1}{q}+\frac{1}{3p}=\frac{1}{2}\]

<p>由于，\(p\) 和 \(q\) 都是正整数，显然地，\(p\) 越大，\(q\) 越小。我们取 \(p\) 最小值 1，有 \(q = 6\) ，此时 \(V = 1/2\) 不满足。同理，我们依次枚举调大 \(p\) 的值，直到 \(q &lt; 1\) 时，都找不到满足条件的整数解。因此不存在正三面体。</p>

<h2 id="凸多面体">凸多面体</h2>

<p>然而我们一开始想讨论的问题是是否存在三面体，而不是加上限定条件的凸正多面体，好像是答非所问了。而且并非所有的骰子都需要是凸正多面体，比如 d10 骰子就不是凸正多面体：</p>

<p><img src="/assets/images/dice-d10.png" alt="D10 骰子怎么看也不是正多面体" /></p>

<p>D10 骰子怎么看也不是正多面体</p>

<p>我们应该有一个更一般的处理三面体问题的结论。</p>

<p>和二维图形至少需要 3 个顶点类似，面为平面的多面体，至少需要 4 个顶点才能够形成有体积的三维图形。 而 4 个顶点构成的凸多边形就是凸四面体。只考虑这个问题实际上比上面的正凸多面体反而更简单了。</p>

<h2 id="多面体">多面体</h2>

<p>等等，好像我们也没有说我们的三面体得是凸的吧？我们知道所有和一个球面同胚的多面体（三维空间中的凸多面体）的欧拉示性数都是 2，但我们并没有说我们需要和球面同胚吧？比如马克杯和甜甜圈的欧拉示性数就是 0。</p>

<p><img src="/assets/images/mug-donuts.jpg" alt="拓扑学家常常分不清马克杯和甜甜圈" /></p>

<p>拓扑学家常常分不清马克杯和甜甜圈</p>

<p>我们能找到更一般地结论证明三面体不存在吧？不能，因为三面体可以存在，下面给出一个反例：</p>

<p><strong>一个截面为三角形的甜甜圈，它是不是一个三面体？</strong></p>

<p>很可惜的是「需要 4 个顶点才能够形成有体积的三维图形」的结论并没有发生改变，通过马克杯构造出来的三面体需要环面的参与才能够完成。但如果我们可以接受环面，我们能不能进一步接受曲面？也许问题可以变得更简单一些，比如圆柱体是否可以看成一个三面体？</p>

<h2 id="结论">结论</h2>

<p>好吧，其实我一开始的想法想当然了，我们可以有三面体，只是… 可能不那么容易做成骰子。</p>

<p>另外如果我们只从做骰子的角度来考虑的话，我们也并不需要三面体，比如我们将两个正四面体贴合在一起，将对称的两侧都标记为相同的数字的话，也是可以实现三面效果的骰子的。但脱离骰子本身而去重新考虑多面体的意义是一个非常不错的拓扑学训练。</p>

<h2 id="扩展阅读">扩展阅读</h2>

<ul>
  <li>https://youtu.be/YtkIWDE36qU?si=3dZG91P4wCDEgMsE</li>
  <li>https://youtu.be/VvCytJvd4H0?si=7QxzQuQHg2EvHFGj</li>
</ul>]]></content><author><name>CodeRemixer</name></author><category term="拓扑学" /><category term="欧拉" /><category term="欧拉示性数" /><summary type="html"><![CDATA[前几天我在桌子上放了一个骰塔，塔里放了一组 DnD 骰子。有个同事走过来看到一个正四面体的骰子问：「你这是三面骰吗？」我一愣，第一反应是，这世界上不应该存在三面体啊。不过一细想，为什么没有三面体确实是一个值得思考的好问题。]]></summary></entry><entry><title type="html">柯洁能成为九冠王吗？</title><link href="https://coderemixer.com/2024/05/20/kejie-championship" rel="alternate" type="text/html" title="柯洁能成为九冠王吗？" /><published>2024-05-20T02:40:00+08:00</published><updated>2024-05-20T02:40:00+08:00</updated><id>https://coderemixer.com/2024/05/20/kejie-championship</id><content type="html" xml:base="https://coderemixer.com/2024/05/20/kejie-championship"><![CDATA[<p>柯洁（九段）的上一个世界冠军可以追溯到 2020 年三星杯 2-0 胜申真谞（九段），连续三年没有获得世界冠军，上一次和世界冠军失之交臂是 2023 年亚运会负許皓鋐（九段）。不由让人疑问，柯洁在职业生涯再拿一个世界冠军的概率有多少？为了回答这个问题，我们需要一个衡量棋手水平的模型。一个比较简单的方法就是通过 Elo 等级分。</p>

<h2 id="bradley-terry-模型">Bradley-Terry 模型</h2>

<p>今天的 Elo 等级分和 Arpad Elo 的原始假设有比较大的差异，尤其是在选择的分布上。一般我们会假设使用 Bradley-Terry 模型构造 elo 等级分模型，假设 \(R(i,t)\) 是 \(i\) 选手在 \(t\) 时刻的 Elo 分，即对于两个选手 \(\alpha\) 和 \(\beta\) 在 \(t\) 时刻 \(\alpha\) 获胜的概率是</p>

\[\begin{align}
\gamma(i,t)&amp;=10^\frac{R(i,t)}{400}\\
P(\alpha\gt\beta,t)&amp;=\frac{\gamma(\alpha,t)}{\gamma(\alpha,t)+\gamma(\beta,t)}
\end{align}\]

<p>然而当两位选手下完一盘棋后，后验的结果如何反馈到 elo 分的修正上是一个比较大的问题。一个比较好的算法是 <a href="https://www.remi-coulom.fr/WHR/">WHR Algorithm</a>，也就是 <a href="https://goratings.org">Go Ratings</a> 使用的算法。</p>

<p>举个例子来说，我们以截止到 2024 年 5 月 10 日数据的最新等级分来看的话，如果我们比较柯洁和战鹰（二段）的等级分的话，柯洁的等级分是 3694 分，而战鹰的等级分是 2824 分。如果明天就有一盘柯洁和战鹰的比赛的话，那么战鹰战胜柯洁的概率是 0.66%，从中可以看出顶尖职业棋手间微妙的差距。</p>

<p>申真谞的等级分是 3877 分，所以柯洁对战申真谞胜出的概率是 25.86%。而柯洁前两天爆冷负刘宇航（六段），刘宇航的等级分是 3536 分，发生这样爆冷的概率是 28.70%。从这个角度来看，柯洁能赢申真谞本身也属于一种爆冷了。</p>

<h2 id="建模">建模</h2>

<p>然而锦标赛并不是单纯的胜率对比，一名棋手在淘汰赛中需要进行多轮比赛，即使胜率总是 90%，连续赢 8 轮的概率也只有 43%。本着「量子力学量力学，随机过程随机过」的原则，我们不如使用蒙特卡洛方法来模拟这些锦标赛的规则，从而能更好估计夺冠的分布。</p>

<p>我们考虑下面的个人世界围棋赛事：应式杯、春兰杯、三星杯、LG 杯、梦百合杯、烂柯杯。应式杯每四年举办一次，而亚运会下一届是不是正式项目不确定。北海新绎杯由于今年第一年办，不确定之后的赛制以及会不会继续办，先不纳入计算。</p>

<p>为了简化计算，我们不妨做下面的假设：</p>

<ol>
  <li>我们定义淘汰赛为跳过全部轮空轮次的淘汰赛。</li>
  <li>进入淘汰赛 n 个名额的总是世界排名前 n 名的选手。</li>
  <li>柯洁总能进入淘汰赛。</li>
  <li>进入淘汰赛的 n 名棋手的比赛顺序完全随机，忽略部分比赛的同一国家 / 地区选手回避原则。</li>
  <li>模拟过程中各选手 elo 分不再变化。</li>
</ol>

<p>于是我们简化各个杯赛模拟规则如下：</p>

<table>
  <thead>
    <tr>
      <th>杯赛</th>
      <th>本赛选手数</th>
      <th>规则</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>应式杯</td>
      <td>16</td>
      <td>单败淘汰，半决赛三番棋，决赛五番棋</td>
    </tr>
    <tr>
      <td>春兰杯</td>
      <td>16</td>
      <td>单败淘汰，决赛三番棋</td>
    </tr>
    <tr>
      <td>三星杯</td>
      <td>16</td>
      <td>单败淘汰，决赛三番棋</td>
    </tr>
    <tr>
      <td>LG 杯</td>
      <td>32</td>
      <td>单败淘汰，决赛三番棋</td>
    </tr>
    <tr>
      <td>梦百合杯</td>
      <td>32</td>
      <td>单败淘汰，半决赛三番棋，决赛五番棋</td>
    </tr>
    <tr>
      <td>烂柯杯</td>
      <td>32</td>
      <td>单败淘汰，决赛三番棋</td>
    </tr>
  </tbody>
</table>

<h2 id="胜率">胜率</h2>

<p>由于选手数量不会超过 32 人，我们可以先根据等级分计算一下世界前 32 强棋手之间的胜率矩阵来加速计算：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ELO_RATINGS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">"Shin Jinseo"</span><span class="p">:</span> <span class="mi">3877</span><span class="p">,</span>
  <span class="s2">"Ke Jie"</span><span class="p">:</span> <span class="mi">3694</span><span class="p">,</span>
  <span class="s2">"Park Junghwan"</span><span class="p">:</span> <span class="mi">3672</span><span class="p">,</span>
  <span class="s2">"Wang Xinghao"</span><span class="p">:</span> <span class="mi">3671</span><span class="p">,</span>
  <span class="s2">"Gu Zihao"</span><span class="p">:</span> <span class="mi">3660</span><span class="p">,</span>
  <span class="s2">"Li Qincheng"</span><span class="p">:</span> <span class="mi">3660</span><span class="p">,</span>
  <span class="s2">"Ding Hao"</span><span class="p">:</span> <span class="mi">3658</span><span class="p">,</span>
  <span class="s2">"Li Xuanhao"</span><span class="p">:</span> <span class="mi">3655</span><span class="p">,</span>
  <span class="s2">"Byun Sangil"</span><span class="p">:</span> <span class="mi">3653</span><span class="p">,</span>
  <span class="s2">"Yang Dingxin"</span><span class="p">:</span> <span class="mi">3652</span><span class="p">,</span>
  <span class="s2">"Zhao Chenyu"</span><span class="p">:</span> <span class="mi">3637</span><span class="p">,</span>
  <span class="s2">"Fan Tingyu"</span><span class="p">:</span> <span class="mi">3620</span><span class="p">,</span>
  <span class="s2">"Yang Kaiwen"</span><span class="p">:</span> <span class="mi">3617</span><span class="p">,</span>
  <span class="s2">"Dang Yifei"</span><span class="p">:</span> <span class="mi">3616</span><span class="p">,</span>
  <span class="s2">"Li Weiqing"</span><span class="p">:</span> <span class="mi">3608</span><span class="p">,</span>
  <span class="s2">"Lian Xiao"</span><span class="p">:</span> <span class="mi">3608</span><span class="p">,</span>
  <span class="s2">"Mi Yuting"</span><span class="p">:</span> <span class="mi">3594</span><span class="p">,</span>
  <span class="s2">"Iyama Yuta"</span><span class="p">:</span> <span class="mi">3585</span><span class="p">,</span>
  <span class="s2">"Xu Jiayang"</span><span class="p">:</span> <span class="mi">3584</span><span class="p">,</span>
  <span class="s2">"Shin Minjun"</span><span class="p">:</span> <span class="mi">3583</span><span class="p">,</span>
  <span class="s2">"Ichiriki Ryo"</span><span class="p">:</span> <span class="mi">3582</span><span class="p">,</span>
  <span class="s2">"Liao Yuanhe"</span><span class="p">:</span> <span class="mi">3581</span><span class="p">,</span>
  <span class="s2">"Xu Haohong"</span><span class="p">:</span> <span class="mi">3581</span><span class="p">,</span>
  <span class="s2">"Xie Erhao"</span><span class="p">:</span> <span class="mi">3563</span><span class="p">,</span>
  <span class="s2">"Xie Ke"</span><span class="p">:</span> <span class="mi">3562</span><span class="p">,</span>
  <span class="s2">"Shi Yue"</span><span class="p">:</span> <span class="mi">3560</span><span class="p">,</span>
  <span class="s2">"Kang Dongyun"</span><span class="p">:</span> <span class="mi">3558</span><span class="p">,</span>
  <span class="s2">"Jiang Weijie"</span><span class="p">:</span> <span class="mi">3556</span><span class="p">,</span>
  <span class="s2">"Shibano Toramaru"</span><span class="p">:</span> <span class="mi">3555</span><span class="p">,</span>
  <span class="s2">"Tan Xiao"</span><span class="p">:</span> <span class="mi">3548</span><span class="p">,</span>
  <span class="s2">"Tuo Jiaxi"</span><span class="p">:</span> <span class="mi">3541</span><span class="p">,</span>
  <span class="s2">"Kim Myounghoon"</span><span class="p">:</span> <span class="mi">3536</span><span class="p">,</span>
<span class="p">}</span>

<span class="no">PLAYERS_INDEXES</span> <span class="o">=</span> <span class="no">ELO_RATINGS</span><span class="p">.</span><span class="nf">each_with_index</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">pair</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
  <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>
<span class="k">end</span><span class="p">.</span><span class="nf">to_h</span>

<span class="no">WINNING_RATES</span> <span class="o">=</span> <span class="p">(</span><span class="no">ELO_RATINGS</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">rating_1</span><span class="o">|</span>
  <span class="no">ELO_RATINGS</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">rating_2</span><span class="o">|</span>
    <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">rating_1</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">400</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">rating_1</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">400</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">rating_2</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">400</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span><span class="p">)</span>

<span class="c1"># Returns the possibility of winning</span>
<span class="k">def</span> <span class="nf">beats</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="no">WINNING_RATES</span><span class="p">[</span><span class="no">PLAYERS_INDEXES</span><span class="p">[</span><span class="n">a</span><span class="p">]][</span><span class="no">PLAYERS_INDEXES</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="构造比赛规则">构造比赛规则</h2>

<p>我们构造一个辅助函数，能选出排名前 n 的选手：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Pick first n players</span>
<span class="k">def</span> <span class="nf">pick_players</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="no">ELO_RATINGS</span><span class="p">.</span><span class="nf">keys</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">n</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>然后我们模拟两选手下 n 番棋，返回胜者：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Emulate a game between two players</span>
<span class="k">def</span> <span class="nf">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
  <span class="n">num</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="n">beats</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">}.</span><span class="nf">count</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">?</span> <span class="n">a</span> <span class="p">:</span> <span class="n">b</span>
<span class="k">end</span>
</code></pre></div></div>

<p>然后我们先模拟一下应式杯的规则：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">simulate_yingshi_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们来模拟 1000 次，看看结果：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="mi">1000</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="n">simulate_yingshi_tournament</span> <span class="p">}.</span><span class="nf">tally</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="o">-</span><span class="n">v</span> <span class="p">}.</span><span class="nf">to_h</span>

<span class="c1"># {"Shin Jinseo"=&gt;553, "Ke Jie"=&gt;68, "Park Junghwan"=&gt;54, "Li Qincheng"=&gt;44, "Wang Xinghao"=&gt;40, "Li Xuanhao"=&gt;33, "Byun Sangil"=&gt;32, "Gu Zihao"=&gt;31, "Ding Hao"=&gt;30, "Yang Dingxin"=&gt;28, "Zhao Chenyu"=&gt;24, "Li Weiqing"=&gt;16, "Dang Yifei"=&gt;16, "Fan Tingyu"=&gt;12, "Yang Kaiwen"=&gt;11, "Lian Xiao"=&gt;8}</span>
</code></pre></div></div>

<p>申真谞赢下了其中的 553 个冠军，而柯洁赢下了其中的 68 个。</p>

<h2 id="模拟">模拟</h2>

<p>我们先试图模拟一下 2024 年的情况，也就是全部 6 个杯赛都会举行。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">simulate_yingshi_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">simulate_chunlan_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">simulate_samsung_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">simulate_lg_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">32</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 16 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winner</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">simulate_mengbaihe_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">32</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 16 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winner</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">simulate_lanke_tournament</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">pick_players</span><span class="p">(</span><span class="mi">32</span><span class="p">).</span><span class="nf">shuffle</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 16 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 8 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 4 winners</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 2 winner</span>
  <span class="n">players</span> <span class="o">=</span> <span class="n">players</span><span class="p">.</span><span class="nf">each_slice</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">emulate_game</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 1 winner</span>
  <span class="n">players</span><span class="p">.</span><span class="nf">first</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">has_kejie_won_tournament</span>
  <span class="p">[</span><span class="n">simulate_chunlan_tournament</span><span class="p">,</span> <span class="n">simulate_samsung_tournament</span><span class="p">,</span> <span class="n">simulate_lg_tournament</span><span class="p">,</span> <span class="n">simulate_mengbaihe_tournament</span><span class="p">,</span> <span class="n">simulate_lanke_tournament</span><span class="p">].</span><span class="nf">count</span><span class="p">(</span><span class="s2">"Ke Jie"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>模拟 10000 次后，柯洁期望是每年获得 0.3881 个世界冠军。如果应式杯不举行，模拟了 10000 次，柯洁获得至少一个冠军的概率是 0.3256。由于应式杯每四年举行一次，我们取其期望，也就是柯洁每年能获得 <strong>0.3412</strong> 个世界冠军。</p>

<h2 id="生涯估计">生涯估计</h2>

<p>整体来说，淘汰赛如果不采用单败淘汰制，例如在半决赛和决赛种引入三番棋和五番棋，那么其就会体现为一个方差更小的二项分布，会更能体现实力本身的差距，相对来说运气成分会变小。像应式杯和梦百合杯这种决赛五番棋的，对于柯洁来说，如果正好对上申真谞就会变得极为不利，反之就会变得极为有利。在这个大前提下，锦标赛引入的这种不确定性增大了柯洁夺冠的概率。</p>

<p>然而，对于一名围棋棋手而言，其生涯是有限的，我们无法相信柯洁会一直维持他职业生涯的巅峰状态，随着时间，他的状态会越来越差。如果我们假设柯洁能在未来 5 年内都能维持这样的表现不下滑，那么其<strong>至少再拿一个世界冠军的概率是 88.60%</strong>；如果在未来 8 年内都能维持这样的表现不下滑，那么其<strong>至少再拿一个世界冠军的概率是 96.56%</strong>。整体来说，成为九冠王的概率还是比较大的。</p>]]></content><author><name>CodeRemixer</name></author><category term="统计学" /><category term="Elo" /><summary type="html"><![CDATA[柯洁（九段）的上一个世界冠军可以追溯到 2020 年三星杯 2-0 胜申真谞（九段），连续三年没有获得世界冠军，上一次和世界冠军失之交臂是 2023 年亚运会负許皓鋐（九段）。不由让人疑问，柯洁在职业生涯再拿一个世界冠军的概率有多少？为了回答这个问题，我们需要一个衡量棋手水平的模型。一个比较简单的方法就是通过 Elo 等级分。]]></summary></entry><entry><title type="html">一个熟悉又陌生的解谜游戏 —— 东京地下铁 2023 解谜游戏设计分析</title><link href="https://coderemixer.com/2024/04/30/tokyo-metro-2023" rel="alternate" type="text/html" title="一个熟悉又陌生的解谜游戏 —— 东京地下铁 2023 解谜游戏设计分析" /><published>2024-04-30T22:39:32+08:00</published><updated>2024-04-30T22:39:32+08:00</updated><id>https://coderemixer.com/2024/04/30/tokyo-metro-2023</id><content type="html" xml:base="https://coderemixer.com/2024/04/30/tokyo-metro-2023"><![CDATA[<p>2019 年我写过一篇<a href="/2019/01/10/heisei-last-unfinished-game">《平成最后的烂尾游戏——东京地下铁 2018 解谜游戏设计分析》</a>。<del>2020 年因为 COVID-19 的原因，没怎么敢出门错过了 Tokyo Metro 地下谜 2019。</del> 有人说我其实玩过 2019，并且还解得很快… 然后我想起来了，确实玩过，并且谜题极其简单，很快速就过了，以至于我甚至没有回家写 review。而 2021 年的地下谜又被取消了，乘着 2023 年地下谜延长了举办时间，当然是务必来日本玩了这个游戏。</p>

<p>下面的内容不单纯是从玩家的角度在看这款游戏，很多时候是从游戏设计的角度在看问题，因此包含 <strong>大量剧透</strong>，<strong>请没有玩过这款游戏并且想要体验这款游戏的玩家，千万不要继续往下读</strong>。</p>

<h2 id="国际化">国际化</h2>

<p>2018 和 2019 两代的东京地下铁解谜是有英文和中文版本的，然而 2023 版本是只有日本语的。</p>

<p><img src="/assets/images/tokyo-metro-2023-japanese.png" alt="Japanese Only" /></p>

<p>看到这里的我还天真地没有意识到事情的严重性，我想我 <del>也是 JLPT N2</del> 日本语相关的豆知识知道一大堆，想必区区一个解谜游戏那是余裕吧。</p>

<p>我是从新宿歌舞伎町的 Tokyo Mystery Circus 兑换的招待状，第一章的谜题是比较简单的字谜，我大约在门口的小桌子上画了 30 分钟解完的。整体是一个类似 Crosswords 的游戏。其实大多数的谜题答案其实在「車掌さんのコラムシート」里已经给出了，我还在那里疯狂查 Google。很明显，我犯了和 2018 年一样的错误，忘记在教学关仔细查看袋子里的东西。</p>

<p>然后我们进入到第二章，第二章 Group A 由于 3 月 18 日后两个车站无法在现地进行游戏，于是改成了纯的字谜，也就是噩梦的开始。</p>

<p><img src="/assets/images/tokyo-metro-2023-chapter-2-group-a.jpg" alt="Chapter 2 Group A" /></p>

<p>从一上来的 A=幸 B=踊 C=祝，到下面一排的提示，根据音节的数量的暗示，很明显是要填某种词性变形。虽然我直观上第一反应就是填入「幸せ、踊り、祝い」因为感觉这是最常用的搭配。但不知为何，我的文法小雷达就开始响。「第一个怎么是个形容动词（な类形容词），但第二个是动词，第三个又是名词？」「如果形容动词可以的话幸い（さいわい）不也符合要求吗？」「踊る是五段动词诶，为什么在这里要用连用形？」在脑子里噼里啪啦想了半天… 最后发现一开始的想法就是对的。我觉得反而对于日本人来说我上面这些想法才是很奇怪的，因为语言本身是从上下文中学习的，而不是从语法规则中学习的。但是对于一个日语作为我第四语言的外国人来说，确实是有点难受了。</p>

<p>我们先跳过 Group B 的谜题，聊一聊第三章的谜题。这个谜题简直是上面这个谜题的升级，真的是把我折腾到身心俱疲。</p>

<p><img src="/assets/images/tokyo-metro-2023-chapter-3.jpg" alt="Chapter 3" /></p>

<p>第三章的舞台发生在根津神社。从 Metro 的地铁站出来，首先会经过一个大约高度差 8 米的坂道。STEP1 是比较简单的，就是逛一遍神社，根据内容把神社内的一些贴纸贴上。STEP2 让我从一个词推断出另一个词，我对着这玩意看了至少五分钟，才意识到其实是日语的词语接龙游戏。虽然汉语也会有类似成语接龙之类的东西，但日语的词语接龙还是有不太一样的规则的。上一次看到日语的词语接龙游戏还是在看《小林さんちのメイドラゴン》的时候。这我们バカ外人怎么能很快反应过来啊。</p>

<p>游戏设定在这里，希望你找个餐厅坐下来慢慢搞，但说句实话，由于我是中午 11 点开始的游戏，这个时候不是饭点，即使是书里推荐的合作餐厅好像也只有一家开着。作为国宝・重要文化財（建造物），根津神社那可以说游客是人山人海，完全没有地方能站或者坐下来慢慢想的。想找个星巴克之类的发现好远，那找个麦当劳吧，也要走 1km 并且还是和车站反方向。然后想找个能刷 Suica 的自动贩卖机也没找到，我身上还背着相机电脑，一个包里有 5kg+ 的负重都快脱水了。好不容易看到一个 7-11，硬灌了两瓶宝矿力后开始了这个词语接龙。折腾了半天战绩奇差，只猜出来了四个词语，还有四个都不太确定。尤其那个蝌蚪，我怎么看都像… 孑孓（蚊子的幼虫），结果是蝌蚪… 好消息是这个地方只是想要拼一个鬼脚图（阿弥陀籤），可以通过逻辑推理来弥补掉没猜出来的部分。（怎么又是阿弥陀籤，年年都设计阿弥陀籤吗？）</p>

<p>谁知道，翻到反面让我看这个「①④⑧の成長後」，还是得硬着头皮猜。然而就算你猜出来了，其实和谜题答案关系也不大，需要拿第二章的收尾谜题中用过的纸的一部分和这页拼来拼去，拼完后给你几个抽象的图形，我甚至没反应过来灰色的是皇居，九段台阶是「九段下」，两个桥是「二重橋前」，而竹子是「竹橋」，樱花是「桜田門」… 这地方是我全场唯一一次看 Hint，太离谱了。</p>

<p><img src="/assets/images/tokyo-metro-2023-chapter-3-combination.jpg" alt="Chapter 3 Combination" /></p>

<p>（来，聪明的你告诉我，上面这个图案表示什么车站？）</p>

<p>这其实就是一个国际化陷阱，就是当你写了一些司空见惯的文化符号的时候，其实没有意识到你的语言来自于一个对于上下文（语境）的整体认知。这些设计确实是会在跨文化中非常困境的，也难怪今年谜题没有其它语言，如果让我做这个翻译，我估计会气到脑中风。我不知道这些图形和符号对于以日语为母语的人能有多快的反应速度，但从中其实可以得到一些游戏设计的启示，如果我们要以国际化发行为某种目标的话，应当避免怎么样的设计。</p>

<h2 id="折纸--我最爱的一集">折纸 —— 我最爱的一集</h2>

<p>第二章 Group B 是个中规中矩的内容，和前作一样，第二章的重要目的是聚合，把不同地方开始的玩家，通过不同的引导方式，最终指引到唯一的地方去。</p>

<p>我当时从新宿出发去的最近的「九段下」，做完任务后，我们将 A 和 B 的密码拼起来后得到了一句让你把「千代田线的隔离门打开」的指示。这是个有了很久铺垫的指示，因为第一章中就反复出现了这个「千代田线的隔离门」，你马上就知道要把纸张撕开。比较不方便的是这个中缝订得很牢，我一度以为不需要整张撕下。撕下后比划了一下，发现能折出「金」「空」这样的字，和一开始说「有楽町線」和「東西線」是金色和青空色的。这是一个特别好的模进（Sequentia），我在上一篇文章中也提到过这个设计技巧。然后引入了第一个谷折、山折的概念（我也是第一次学习到这个日语用法）。折完后的形状正好能塞下发的装游戏 Kit 的包，而包上正好有个缺口，把赠的一日票放上去，就得到了下一站的目的地。这套联招下来简直酷死了，当时简直成就感爆棚。和第三章那个诡异的接龙游戏、图像对对乐不知道高到哪里去了。</p>

<p><img src="/assets/images/tokyo-metro-2023-origami.jpg" alt="Origami" /></p>

<p>第四章的谜题相对是比较简单的，由于受到了第三章的折磨，完全知道出题人的思路是什么了。于是我们走向了旅程的终章！</p>

<h2 id="终章--我最最喜欢的一集">终章 —— 我最最喜欢的一集</h2>

<p>我评价 2018 年地下铁谜题是平成最后的烂尾游戏，终章的时候给了极强的气氛渲染，然后莫名其妙就结束了。然而这次的谜题将终章的舞台搬到了东京铁塔，并且是让你一步步推到的东京铁塔！这个心境的变化是难以言说的。</p>

<p>终章中一开始那个字谜，一下子就没有第三章那种缺点了，从「神保町」出来后，一抬头「嘿，这不是到我们学校附近了吗？不会舞台要放到东京铁塔了吧」（结果还真是）。在东京铁塔收集了线索后，完成了线下的全部流程。</p>

<p>但是当你回到家继续完成线上部分的时候，游戏又给你准备了一组渐强的模进。从一个字谜开始，又转向了一个折纸谜题，最后又通过这个折纸又得到了一个东京铁塔！最后终于完成了全部的谜题。这个收尾的感觉太棒了，掩盖了很多游戏中的不足之处，2023 年的结局真的做得比 2018 年的好太多了。</p>

<p><img src="/assets/images/tokyo-metro-2023-tokyo-tower.jpg" alt="Tokyo Tower" /></p>

<h2 id="一些感想">一些感想</h2>

<p>我今天 11:30 兑换的套件，17:50 完成了全部的线下部分，共计 6 小时 20 分钟。线上部分大约又花费了 30 分钟，和 2018 年的游戏时长差不多。</p>

<p><img src="/assets/images/tokyo-metro-2023-congratulations.jpg" alt="Congratulations" /></p>

<p>讨论一下我对这个游戏的整体感想吧。我觉得第二章和终章就是神，第一章和第四章一般，第三章简直就像是因为和根津神社有合作然后胡搞的一样。某种意义上我感觉第一、第二章和终章像是同一个设计师设计的谜题，而第三、第四章是另一个设计师。</p>

<p>其实玩了两把之后还是感觉工业化痕迹挺重的，一些解谜思路在反复出现。作为年货游戏，其实还是能看得出来谜题设计时候的很多思路的。</p>

<p>不过在片尾人员字幕表中再次看到了「堺谷 光」我还是挺震惊的。在上次的文章中我有说过堺谷光的一篇论文中大量围绕动机和模进设计的游戏机制，在今天的游戏中也有不少体现。不过之前看到 Linkedin 上他已经不在 SCRAP 公司工作了，让我对今年的游戏质量多少有点担忧。</p>

<p>还有一个我感觉有点失望的是，在 2018 年游戏的最终谜题中，制作人构造了一个相当精妙的 NP 问题，使得游戏对于玩家试图枚举答案的搜索空间有一个精确的约束，可以极好地控制难度。但这样的数值设计思想没有体现在今年的游戏中。感觉一题这样的东西都没有，很奇怪。</p>

<p>整体感觉今天学到很多，不管是好的方面还是不好的方面。希望明年的游戏可以更好。</p>]]></content><author><name>CodeRemixer</name></author><category term="游戏" /><category term="设计" /><category term="混合现实" /><category term="地下謎" /><summary type="html"><![CDATA[2019 年我写过一篇《平成最后的烂尾游戏——东京地下铁 2018 解谜游戏设计分析》。2020 年因为 COVID-19 的原因，没怎么敢出门错过了 Tokyo Metro 地下谜 2019。 有人说我其实玩过 2019，并且还解得很快… 然后我想起来了，确实玩过，并且谜题极其简单，很快速就过了，以至于我甚至没有回家写 review。而 2021 年的地下谜又被取消了，乘着 2023 年地下谜延长了举办时间，当然是务必来日本玩了这个游戏。]]></summary></entry><entry><title type="html">三点几嚟，饮茶先啦 —— 将大马饮料名编译成汉语</title><link href="https://coderemixer.com/2021/07/05/compile-malay-tea-name" rel="alternate" type="text/html" title="三点几嚟，饮茶先啦 —— 将大马饮料名编译成汉语" /><published>2021-07-05T12:44:49+08:00</published><updated>2021-07-05T12:44:49+08:00</updated><id>https://coderemixer.com/2021/07/05/compile-malay-tea-name</id><content type="html" xml:base="https://coderemixer.com/2021/07/05/compile-malay-tea-name"><![CDATA[<p>近几日马来西亚网友 Gurdip Singh 在 Facebook 发的这个「三点几嚟，饮茶先啦」非常流行。</p>

<p>Facebook: www.facebook.com/100009201465316/videos/2530411593942198</p>

<p>Bilibili 搬运：https://www.bilibili.com/video/av845257746/</p>

<p>不过马来语的饮料名称非常有意思。某个目前居住在新加坡的朋友 @david92 给我解释了一下，如何在店里点茶喝。基本是一个组合式的语法，非常规律。最基础的茶底是红茶（Teh）或者咖啡（Kopi）。默认饮料是带糖和炼乳的，但你可以重新定制。如果你在后面加上 O 表示不要加炼乳，而 C 表示把炼乳换成鲜奶。类似，Kosong 是无糖，Siu Dai 是少糖，而 Gah Dai 是加更多的糖。</p>

<h2 id="ebnf-语法">ebnf 语法</h2>

<p>我查阅了一些资料进一步完善了一下这个概念，发现这个语法完全是「可编译」的，非常简单。很快，我写了一个 bnf 语法来描述这个概念：</p>

<pre><code class="language-ebnf">&lt;water&gt;     ::= "Kopi" | "Teh" | "Milo"
&lt;sugar&gt;     ::= "Kosong" | "Siu Dai" | "Gah Dai"
&lt;milk&gt;      ::= "O" | "C"
&lt;thickness&gt; ::= "Po" | "Gau"
&lt;extra&gt;     ::= "Peng" | "Bubble" | "Halia"
&lt;upsize&gt;    ::= "Nga Lat"
&lt;takeout&gt;   ::= "Bungkus" 
&lt;plastic&gt;   ::= "Ikat"
&lt;knot&gt;      ::= "Mati" | "Tepi"

&lt;drink&gt;     ::=
  (&lt;takeout&gt; (" " &lt;plastic&gt; (" " &lt;knot&gt;)?)? " ")?
  (&lt;upsize&gt; " ")?
  &lt;water&gt; (" " &lt;milk&gt;)? (" " &lt;sugar&gt;)?
  (" " &lt;thickness&gt;)?
  (" " &lt;extra&gt;)*
</code></pre>

<p>其中，Po 是清淡，Gau 是浓缩，Peng 是加冰块，Bubble 是加珍珠，Halia 是加姜汁。Nga Lat 是大杯。外带的概念比校复杂，Bungkus 是外带，通常是杯状的。像是 Bernard Tee 视频里那种塑料袋装的，叫 Ikat。Ikat 有两种不同的打结方式，一种是打死结 Mati，还有一种是侧面打结，开口的叫 Tepi。</p>

<p>比如 Bungkus Ikat Mati Nga Lat Kopi O Siu Dai Gau Peng Bubble 就是外带塑料袋装打死结大杯少糖浓缩咖啡加冰块和珍珠。</p>

<p>我们可以在 <a href="https://bnfplayground.pauliankline.com/">ebnf playground</a> 测试这个语法。这个网站甚至能生成随机的符合某个语法（比如这里 Drink）的字符串，来让我们人工检查这个语法对不对。于是截止这里我们还可以实现一个自动生成饮料名的生成器：https://www.bilibili.com/video/BV1SK4y197hc</p>

<h2 id="实现到汉语的编译器">实现到汉语的编译器</h2>

<p>Ruby 中有一个 gem 叫 ebnf 可以读取 ebnf 文件然后生成对应的 parser，然后我们写一个输出中文的 generator 即可将马来西亚语翻译成中文。</p>

<p>由于 ebnf 的语法并没有规范，Ruby ebnf 库和我们刚刚 playground 中的语法有细微不同，这里做了一些变更。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"ebnf"</span>

<span class="no">TEA_GRAMMER</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
Water     ::= "Kopi" | "Teh" | "Milo"
Sugar     ::= "Kosong" | "Siu Dai" | "Gah Dai"
Milk      ::= "O" | "C"
Thickness ::= "Po" | "Gau"
Extra     ::= "Peng" | "Bubble" | "Halia"
Upsize    ::= "Nga Lat"
Knot      ::= "Mati" | "Tepi"
Plastic   ::= "Ikat" Knot?
Takeout   ::= "Bungkus" Plastic?

Drink     ::= Takeout? Upsize? Water Milk? Sugar? Thickness? Extra*
</span><span class="no">EOF</span>
</code></pre></div></div>

<p>由于这个库执行 parse 需要先转换成解析表达文法（Parsing Expression Grammar）从而生成更多的子规则，我们先打印一下自动生成的子规则便于之后开发 generator。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">EBNF</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">TEA_GRAMMER</span><span class="p">).</span><span class="nf">make_peg</span><span class="p">.</span><span class="nf">ast</span>

<span class="cm">=begin
(rule Water (alt "Kopi" "Teh" "Milo"))
(rule Sugar (alt "Kosong" "Siu Dai" "Gah Dai"))
(rule Milk (alt "O" "C"))
(rule Thickness (alt "Po" "Gau"))
(rule Extra (alt "Peng" "Bubble" "Halia"))
(rule Upsize (seq "Nga Lat"))
(rule Knot (alt "Mati" "Tepi"))
(rule Plastic (seq "Ikat" _Plastic_1))
(rule _Plastic_1 (opt Knot))
(rule Takeout (seq "Bungkus" _Takeout_1))
(rule _Takeout_1 (opt Plastic))
(rule Drink (seq _Drink_1 _Drink_2 Water _Drink_3 _Drink_4 _Drink_5 _Drink_6))
(rule _Drink_1 (opt Takeout))
(rule _Drink_2 (opt Upsize))
(rule _Drink_3 (opt Milk))
(rule _Drink_4 (opt Sugar))
(rule _Drink_5 (opt Thickness))
(rule _Drink_6 (star Extra))
=end</span>
</code></pre></div></div>

<p>我们创建一个 generator 类，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MalayTea</span>
  <span class="kp">include</span> <span class="no">EBNF</span><span class="o">::</span><span class="no">PEG</span><span class="o">::</span><span class="no">Parser</span>
  <span class="nb">attr_reader</span> <span class="ss">:rules</span>
   <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@rules</span> <span class="o">=</span> <span class="no">EBNF</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">TEA_GRAMMER</span><span class="p">).</span><span class="nf">make_peg</span><span class="p">.</span><span class="nf">ast</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="ss">:Drink</span><span class="p">,</span> <span class="vi">@rules</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">MalayTea</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">)</span>
</code></pre></div></div>

<p>这时候输入一个句子，其会如实输出 AST 抽象语法树。而我们要做的就是根据 rule 名称来规约这些语法树直到某个特定输出。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="s2">"外带"</span>
    <span class="k">else</span>
        <span class="s2">"外带</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:Plastic</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="s2">"塑料袋装"</span>
    <span class="k">else</span>
        <span class="s2">"塑料袋装</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Plastic_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Mati</span><span class="p">:</span> <span class="s2">"打死结"</span><span class="p">,</span> <span class="no">Tepi</span><span class="p">:</span> <span class="s2">"侧面打结"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_2</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"大杯"</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:Water</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="p">{</span> <span class="no">Kopi</span><span class="p">:</span> <span class="s2">"咖啡"</span><span class="p">,</span> <span class="no">Teh</span><span class="p">:</span> <span class="s2">"红茶"</span><span class="p">,</span> <span class="no">Milo</span><span class="p">:</span> <span class="s2">"美禄"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_3</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">"炼乳"</span> <span class="p">:</span> <span class="p">{</span> <span class="no">O</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span> <span class="no">C</span><span class="p">:</span> <span class="s2">"鲜奶"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_4</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Kosong</span><span class="p">:</span> <span class="s2">"无糖"</span><span class="p">,</span> <span class="s2">"Siu Dai"</span><span class="p">:</span> <span class="s2">"少糖"</span><span class="p">,</span> <span class="s2">"Gah Dai"</span><span class="p">:</span> <span class="s2">"加糖"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_5</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Gau</span><span class="p">:</span> <span class="s2">"浓缩"</span><span class="p">,</span> <span class="no">Po</span><span class="p">:</span> <span class="s2">"清淡"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_6</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">extras</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
        <span class="p">{</span> <span class="no">Peng</span><span class="p">:</span> <span class="s2">"冰块"</span><span class="p">,</span> <span class="no">Bubble</span><span class="p">:</span> <span class="s2">"珍珠"</span><span class="p">,</span> <span class="no">Halia</span><span class="p">:</span> <span class="s2">"姜汁"</span> <span class="p">}[</span><span class="n">a</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">extras</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"加</span><span class="si">#{</span><span class="n">extras</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们规约最后一步的时候需要特殊处理鲜奶红茶和鲜奶咖啡这两个词语，因为一般我们直接叫奶茶和咖啡拿铁。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">production</span><span class="p">(</span><span class="ss">:Drink</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:merge</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"红茶"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"奶茶"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"咖啡"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"咖啡拿铁"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">end</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_1</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_2</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_4</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_5</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_6</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="成果">成果</h2>

<p>最后我们得到了一个将马来西亚语的饮料名编译到汉语的编译（翻译）器。</p>

<p>完整代码如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"ebnf"</span>

<span class="no">TEA_GRAMMER</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
Water     ::= "Kopi" | "Teh" | "Milo"
Sugar     ::= "Kosong" | "Siu Dai" | "Gah Dai"
Milk      ::= "O" | "C"
Thickness ::= "Po" | "Gau"
Extra     ::= "Peng" | "Bubble" | "Halia"
Upsize    ::= "Nga Lat"
Knot      ::= "Mati" | "Tepi"
Plastic   ::= "Ikat" Knot?
Takeout   ::= "Bungkus" Plastic?

Drink     ::= Takeout? Upsize? Water Milk? Sugar? Thickness? Extra*
</span><span class="no">EOF</span>

<span class="k">class</span> <span class="nc">MalayTea</span>
  <span class="kp">include</span> <span class="no">EBNF</span><span class="o">::</span><span class="no">PEG</span><span class="o">::</span><span class="no">Parser</span>
  <span class="nb">attr_reader</span> <span class="ss">:rules</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="s2">"外带"</span>
    <span class="k">else</span>
      <span class="s2">"外带</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:Plastic</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="s2">"塑料袋装"</span>
    <span class="k">else</span>
      <span class="s2">"塑料袋装</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Plastic_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Mati</span><span class="p">:</span> <span class="s2">"打死结"</span><span class="p">,</span> <span class="no">Tepi</span><span class="p">:</span> <span class="s2">"侧面打结"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_2</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"大杯"</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:Water</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="p">{</span> <span class="no">Kopi</span><span class="p">:</span> <span class="s2">"咖啡"</span><span class="p">,</span> <span class="no">Teh</span><span class="p">:</span> <span class="s2">"红茶"</span><span class="p">,</span> <span class="no">Milo</span><span class="p">:</span> <span class="s2">"美禄"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_3</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">"炼乳"</span> <span class="p">:</span> <span class="p">{</span> <span class="no">O</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span> <span class="no">C</span><span class="p">:</span> <span class="s2">"鲜奶"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_4</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Kosong</span><span class="p">:</span> <span class="s2">"无糖"</span><span class="p">,</span> <span class="s2">"Siu Dai"</span><span class="p">:</span> <span class="s2">"少糖"</span><span class="p">,</span> <span class="s2">"Gah Dai"</span><span class="p">:</span> <span class="s2">"加糖"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_5</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Gau</span><span class="p">:</span> <span class="s2">"浓缩"</span><span class="p">,</span> <span class="no">Po</span><span class="p">:</span> <span class="s2">"清淡"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_6</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">extras</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
      <span class="p">{</span> <span class="no">Peng</span><span class="p">:</span> <span class="s2">"冰块"</span><span class="p">,</span> <span class="no">Bubble</span><span class="p">:</span> <span class="s2">"珍珠"</span><span class="p">,</span> <span class="no">Halia</span><span class="p">:</span> <span class="s2">"姜汁"</span> <span class="p">}[</span><span class="n">a</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">extras</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"加</span><span class="si">#{</span><span class="n">extras</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:Drink</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:merge</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"红茶"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"奶茶"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"咖啡"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"咖啡拿铁"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">end</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_1</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_2</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_4</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_5</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_6</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@rules</span> <span class="o">=</span> <span class="no">EBNF</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">TEA_GRAMMER</span><span class="p">).</span><span class="nf">make_peg</span><span class="p">.</span><span class="nf">ast</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="ss">:Drink</span><span class="p">,</span> <span class="vi">@rules</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="kp">loop</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"输入饮料名："</span>
  <span class="nb">print</span> <span class="s2">"&gt; "</span>
  <span class="nb">puts</span>  <span class="s2">"&lt; </span><span class="si">#{</span><span class="no">MalayTea</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们来运行一下看看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❯ ruby main.rb
输入饮料名：
&gt; Bungkus Ikat Mati Nga Lat Kopi O Siu Dai Gau Peng Bubble
&lt; 外带塑料袋装打死结大杯少糖浓缩咖啡加冰块珍珠
</code></pre></div></div>

<p>欢迎大家带着这个程序去马来西亚／新加坡饮茶。</p>]]></content><author><name>CodeRemixer</name></author><category term="编译" /><category term="Ruby" /><category term="语言学" /><summary type="html"><![CDATA[近几日马来西亚网友 Gurdip Singh 在 Facebook 发的这个「三点几嚟，饮茶先啦」非常流行。]]></summary></entry><entry><title type="html">用 Ruby 实现飞机自动驾驶仪</title><link href="https://coderemixer.com/2021/01/08/autopilot-with-ruby" rel="alternate" type="text/html" title="用 Ruby 实现飞机自动驾驶仪" /><published>2021-01-08T13:03:32+08:00</published><updated>2021-01-08T13:03:32+08:00</updated><id>https://coderemixer.com/2021/01/08/autopilot-with-ruby</id><content type="html" xml:base="https://coderemixer.com/2021/01/08/autopilot-with-ruby"><![CDATA[<p><code class="language-plaintext highlighter-rouge">krpc</code> 是一个砍巴拉太空计划（Kerbel Space Program）中的插件。可以通过 RPC 来控制游戏。同时有第三方的 Ruby 客户端：<a href="https://github.com/TeWu/krpc-rb">krpc-rb</a>。和真实飞机不同的是，在砍巴拉游戏中驾驶飞机是非常痛苦的，在没有插件辅助的情况下，你看不到具体的 GPS 坐标，很多时候看到的都是和飞机驾驶无关的轨道参数，而一些关键的控制参数缺很难获取。同时游戏中也没有自动驾驶仪。特别在航天飞机降落的控制非常难，虽然手动降落不会太有问题，游戏对于重着陆的容忍度很高，但是要控制飞机飞往机场的过程漫长而痛苦。于是我们试试看利用 <code class="language-plaintext highlighter-rouge">krpc</code> 来实现正常商用飞机都有的自动驾驶仪的功能。</p>

<h2 id="pid-控制">PID 控制</h2>

<p>PID 是自动化控制中最基础也是最常用的控制算法。</p>

<p>我们假设我们要控制汽车油门使得汽车的速度达到某个我们预想中的速度。最直接的想法就是基于距离目标速度的大小来调整油门。也就是说越接近目标速度，我们油门踩得越轻。</p>

<p>但这会产生一个问题，由于我们控制的是给油，油门到加速度控制存在一个延迟，使得我们放开油门后的几毫秒内可能速度还会上升；而当我们看到速度超过放开油门的量越来越大，随着车速越来越快，我们受到的空气阻力实际在增加，车速又会很快下降，而无法与加速度达到平衡，这种情况下我们就会在目标速度附近来回震荡。根据我们按比例控制的激进程度，振幅可能有所变化，最坏情况下我们会震动幅度越来越大，使得系统完全失控。</p>

<p>解决这个问题最直接的方法是引入一个积分项，不单单根据目前速度的误差，也要根据当前加速度的积分，也就是速度来判断。速度越大可能我们需要的油门也要更大一些。</p>

<p>最后我们实际控制还会遇到扰动的问题，我们可能还要根据过去一段时间内误差变化幅度来调节油门大小，比如遇到一个晃动速度快速下降，我们就要快速补一下油门来弥补这个误差。这意味着我们还要引入一个微分项。把这三个结合起来，我们可以得到公式：
\(u(t) = K_pe(t) + K_i\int_0^te(\tau)d\tau+K_d\frac{d}{dt}e(t)\)
形成一个通用的 P（比例）I（积分）D（微分）控制器。不过虽然说是通用，这每一项前面的系数比例要想调好也是不容易的。我们会用这个控制器来分别控制飞机的节流阀、滚转和俯仰。</p>

<p>用 Ruby 实现出来是这样的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PIDController</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="n">ki</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">clip_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">clip_max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="vi">@prev_err</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="vi">@integral</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="vi">@kp</span> <span class="o">=</span> <span class="n">kp</span>
    <span class="vi">@ki</span> <span class="o">=</span> <span class="n">ki</span>
    <span class="vi">@kd</span> <span class="o">=</span> <span class="n">kd</span>
    <span class="vi">@clip_min</span> <span class="o">=</span> <span class="n">clip_min</span>
    <span class="vi">@clip_max</span> <span class="o">=</span> <span class="n">clip_max</span>

    <span class="vi">@last_frame</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">trigger</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">measured</span><span class="p">)</span>
    <span class="n">trigger_err</span><span class="p">(</span><span class="n">goal</span> <span class="o">-</span> <span class="n">measured</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">trigger_err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="n">current_frame</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">current_frame</span> <span class="o">-</span> <span class="vi">@last_frame</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="mf">1.0</span>
      <span class="vi">@last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
      <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">end</span>

    <span class="vi">@integral</span> <span class="o">=</span> <span class="vi">@integral</span> <span class="o">+</span> <span class="n">err</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="vi">@integral</span> <span class="o">=</span> <span class="vi">@clip_min</span> <span class="k">if</span> <span class="vi">@integral</span> <span class="o">&lt;</span> <span class="vi">@clip_min</span>
    <span class="vi">@integral</span> <span class="o">=</span> <span class="vi">@clip_max</span> <span class="k">if</span> <span class="vi">@integral</span> <span class="o">&gt;</span> <span class="vi">@clip_max</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">err</span> <span class="o">-</span> <span class="vi">@prev_err</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">res</span> <span class="o">=</span> <span class="vi">@kp</span> <span class="o">*</span> <span class="n">err</span> <span class="o">+</span> <span class="vi">@ki</span> <span class="o">*</span> <span class="vi">@integral</span> <span class="o">+</span> <span class="vi">@kd</span> <span class="o">*</span> <span class="n">d</span>
    <span class="vi">@prev_err</span> <span class="o">=</span> <span class="n">err</span>
    <span class="vi">@last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>

    <span class="k">return</span> <span class="vi">@clip_min</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="vi">@clip_min</span>
    <span class="k">return</span> <span class="vi">@clip_max</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="vi">@clip_max</span>
    <span class="n">res</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>实际实现和公式有一些细微差异。积分项不能比可以控制的最大值更大，也不能比最小值更小。否则当误差和控制不在一个数量级的时候，往往会出现很难控制或者反应迟钝的问题。</p>

<h2 id="起飞控制">起飞控制</h2>

<p>起飞控制比较简单，在打开 SAS 保持稳定的情况下，我们只需要控制系统加速到抬轮速度，然后将飞机抬头到俯仰 10 度，收起起落架。最后爬升到给定的高度。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TakeoffProcess</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="n">vr</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
    <span class="vi">@vessel</span> <span class="o">=</span> <span class="n">vessel</span>
    <span class="vi">@control</span> <span class="o">=</span> <span class="n">vessel</span><span class="p">.</span><span class="nf">control</span>

    <span class="vi">@vr</span> <span class="o">=</span> <span class="n">vr</span>
    <span class="vi">@velocity</span> <span class="o">=</span> <span class="n">velocity</span>
    <span class="vi">@height</span> <span class="o">=</span> <span class="n">height</span>

    <span class="vi">@throttle_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
    <span class="vi">@pitch_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">brakes</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">sas</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">orbit</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">orbit</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">reference_frame</span><span class="p">)</span>
      <span class="n">surface</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">surface_reference_frame</span><span class="p">)</span>
      <span class="k">break</span> <span class="k">unless</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span> <span class="o">&lt;</span> <span class="vi">@vr</span>
      <span class="n">throttle</span> <span class="o">=</span> <span class="vi">@throttle_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@velocity</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">throttle</span> <span class="o">=</span> <span class="n">throttle</span>
    <span class="k">end</span>

    <span class="c1"># Rotate</span>
    <span class="nb">puts</span> <span class="s2">"Rotate, Gear Up!"</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">gear</span> <span class="o">=</span> <span class="kp">false</span>

    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">orbit</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">orbit</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">reference_frame</span><span class="p">)</span>
      <span class="n">surface</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">surface_reference_frame</span><span class="p">)</span>
      <span class="k">break</span> <span class="k">unless</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">mean_altitude</span> <span class="o">&lt;</span> <span class="vi">@height</span> <span class="o">-</span> <span class="mi">100</span>
      <span class="n">throttle</span> <span class="o">=</span> <span class="vi">@throttle_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@velocity</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">throttle</span> <span class="o">=</span> <span class="n">throttle</span>

      <span class="n">pitch</span> <span class="o">=</span> <span class="vi">@pitch_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="nf">pitch</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">=</span> <span class="n">pitch</span>
    <span class="k">end</span>

    <span class="nb">puts</span> <span class="s2">"Takeoff Process Finished."</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>比较麻烦的地方是 ksp 有一个 reference_frame 的概念，很多参数需要的是相对于 reference_frame 参数的概念。比如当你需要速度的时候，有可能获得轨道速度，也可能得到的是地面速度。再比如俯仰，如果是相对于轨道的俯仰，那么理论上始终应该是在 0 附近，因为轨道会随着俯仰变化而变化。所以计算的时候要小心。</p>

<h2 id="方向角计算">方向角计算</h2>

<p>起飞后一般飞机自动驾驶仪一个最重要的功能就是根据预先在飞行电脑上设定好的飞行路线来飞行了。路点一般有几个关键参数：高度、速度、经纬度。高度和速度的写法和我们起飞的时候差不多。但转向就比较复杂。</p>

<p>我们首先需要确定的是，飞机要转几度才能转到目标点，也就是计算方位角。我们先来考虑，如果这个地球是一个平面，经纬度是 x 和 y 轴上的坐标，方向角应当怎么算呢？其实我们可以很容易得到方向向量：
\((x, y) = (x_b-x_a, y_b-y_a)\)
那么方向角（自正北作为 0 度的顺时针角度）就是
\(tan(\theta)=\frac{x_b-x_a}{y_b-y_a}\)
\(\theta = atan(\frac{x_b-x_a}{y_b-y_a})\)
然而在球面上计算这个问题要复杂一些，本质上我们需要知道大圆上任意两点的距离，我们需要用到球面三角学中重要的<a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E6%AD%A3%E7%9F%A2%E5%85%AC%E5%BC%8F">半正矢公式（Harversine Formula）</a>。</p>

<p>根据半正矢定理，我们有：
\(hav(c) = hav(a-b)+sin(a)sin(b)hav(C)\)
其中：
\(hav(\theta)=sin^2\frac{\theta}{2}=\frac{1-cos\theta}{2}\)
<img src="/assets/images/harversine.png" alt="Harversine" /></p>

<p>进一步我们可以得到：
\(A = (lat_a, lng_a)\)
\(B = (lat_b, lng_b)\)
\(N = (\frac{\pi}{2}, 0)\)
\(hav(NB) = hav(AB-AN)+sin(AB)sin(AN)hav(\angle NAB)\)
再往下算基本就吐了，这公式长到打在 Wolfram Alpha 上直接不识别。只好上网找了个算好的结果：
\(tan(\theta)=\frac{|lng_b-lng_a|}{ln(\frac{tan(\frac{lat_B}{2}+\frac{\pi}{4})}{tan(\frac{lat_A}{2}+\frac{\pi}{4})})}\)
需要特别注意，当
\(lat_a = lat_b\)
的时候分母为 0，针对这类情况，大多数编程语言都有 <code class="language-plaintext highlighter-rouge">atan2(y, x)</code> 函数，当 <code class="language-plaintext highlighter-rouge">x = 0</code> 时返回 90 度。最后我们有程序：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delta_phi</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="vi">@latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="n">orbit</span><span class="p">.</span><span class="nf">latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">delta_lon</span> <span class="o">=</span>  <span class="p">(</span><span class="vi">@longitude</span> <span class="o">-</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">longitude</span><span class="p">)</span>  <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>
<span class="n">theta</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">atan2</span><span class="p">(</span><span class="n">delta_lon</span><span class="p">,</span> <span class="n">delta_phi</span><span class="p">)</span>
<span class="n">target_heading</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>
</code></pre></div></div>

<h2 id="偏航控制">偏航控制</h2>

<p>飞机上有两个可以控制飞机转向的方法，一个是偏航（Yaw），另一个是组合使用滚转（Roll）和俯仰（Pitch）。偏航通常是通过垂直尾翼来产生偏航力矩。而滚转和俯仰由副翼和水平尾翼得到。显然副翼和水平尾翼比垂直尾翼大很多，控制也会更快速、灵敏。事实上我们只需要控制滚转即可，因为当我们控制滚转，飞机的升力面会减少，从而导致升力下降、飞机下降；为了保持飞行高度，我们基于飞行高度控制的俯仰自然会提高俯仰，从而产生偏航方向的力矩。</p>

<p>不过需要注意两个关键点：</p>

<ol>
  <li>控制俯仰来控制升力的原理是，在一定范围内攻角（Angle of Attack）和升力系数成正比。然而当攻角大于某个角度，升力可能会迅速下降（即失速），如果要提高升力应当降低俯仰，而不是继续抬升俯仰。</li>
  <li>当滚转角度越来越大后，副翼的升力面会逐渐减小到无论如何提高节流阀大小或调整俯仰都无法维持的情况（即失速），应当将侧倾角度（bank angle）控制在合理范围内。</li>
</ol>

<p>在控制程序中我直接限制了俯仰的范围是 [-5.0, 10] 度，而滚转限制在正负 25 度以内。整体程序如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WaypointProcess</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">)</span>
    <span class="vi">@vessel</span> <span class="o">=</span> <span class="n">vessel</span>
    <span class="vi">@control</span> <span class="o">=</span> <span class="n">vessel</span><span class="p">.</span><span class="nf">control</span>

    <span class="vi">@velocity</span> <span class="o">=</span> <span class="n">velocity</span>
    <span class="vi">@height</span> <span class="o">=</span> <span class="n">height</span>
    <span class="vi">@longitude</span> <span class="o">=</span> <span class="n">longitude</span>
    <span class="vi">@latitude</span> <span class="o">=</span> <span class="n">latitude</span>

    <span class="vi">@throttle_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
    <span class="vi">@pitch_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="vi">@roll_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">sas</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">orbit</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">orbit</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">reference_frame</span><span class="p">)</span>
      <span class="n">surface</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">surface_reference_frame</span><span class="p">)</span>
      <span class="k">break</span> <span class="k">if</span> <span class="p">(</span><span class="n">orbit</span><span class="p">.</span><span class="nf">latitude</span> <span class="o">-</span> <span class="vi">@latitude</span><span class="p">).</span><span class="nf">abs</span> <span class="o">&lt;</span> <span class="mf">1e-4</span> <span class="ow">and</span> <span class="p">(</span><span class="n">orbit</span><span class="p">.</span><span class="nf">longitude</span> <span class="o">-</span> <span class="vi">@longitude</span><span class="p">).</span><span class="nf">abs</span> <span class="o">&lt;</span> <span class="mf">1e-4</span>

      <span class="n">throttle</span> <span class="o">=</span> <span class="vi">@throttle_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@velocity</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">throttle</span> <span class="o">=</span> <span class="n">throttle</span>

      <span class="n">pitch</span> <span class="o">=</span> <span class="vi">@pitch_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@height</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">mean_altitude</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">pitch</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">surface</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">&gt;</span> <span class="mi">10</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>
      <span class="k">elsif</span> <span class="n">pitch</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">surface</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="mf">0.1</span>
      <span class="k">end</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">=</span> <span class="n">pitch</span>

      <span class="n">delta_phi</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="vi">@latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="n">orbit</span><span class="p">.</span><span class="nf">latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
      <span class="n">delta_lon</span> <span class="o">=</span>  <span class="p">(</span><span class="vi">@longitude</span> <span class="o">-</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">longitude</span><span class="p">)</span>  <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>
      <span class="n">theta</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">atan2</span><span class="p">(</span><span class="n">delta_lon</span><span class="p">,</span> <span class="n">delta_phi</span><span class="p">)</span>
      <span class="n">target_heading</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>

      <span class="n">target_heading</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">target_heading</span> <span class="k">if</span> <span class="n">target_heading</span> <span class="o">&lt;</span> <span class="mi">0</span>
      <span class="n">delta_heading</span> <span class="o">=</span> <span class="n">target_heading</span> <span class="o">-</span> <span class="n">surface</span><span class="p">.</span><span class="nf">heading</span>

      <span class="n">delta_heading</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">-</span> <span class="n">delta_heading</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&gt;</span> <span class="mi">180</span>
      <span class="n">delta_heading</span> <span class="o">=</span> <span class="n">delta_heading</span> <span class="o">+</span> <span class="mi">360</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span>

      <span class="n">bank_angle</span> <span class="o">=</span> <span class="n">delta_heading</span>
      <span class="n">bank_angle</span> <span class="o">=</span> <span class="mi">25</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&gt;</span> <span class="mi">25</span>
      <span class="n">bank_angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">25</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">25</span>

      <span class="n">roll</span> <span class="o">=</span> <span class="vi">@roll_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="n">bank_angle</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="nf">roll</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">roll</span> <span class="o">=</span> <span class="n">roll</span>
      <span class="n">current_roll</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="nf">roll</span>
    <span class="k">end</span>

    <span class="nb">puts</span> <span class="s2">"Waypoint lat: </span><span class="si">#{</span><span class="vi">@latitude</span><span class="si">}</span><span class="s2">, lng: </span><span class="si">#{</span><span class="vi">@longitude</span><span class="si">}</span><span class="s2"> Reached."</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<h2 id="测试">测试</h2>

<p>我们使用如下的飞行路径设定：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'matrix'</span>
<span class="nb">require</span> <span class="s1">'krpc'</span>

<span class="nb">require</span> <span class="s1">'./libs/controller/pid'</span>
<span class="nb">require</span> <span class="s1">'./libs/process/takeoff'</span>
<span class="nb">require</span> <span class="s1">'./libs/process/waypoint'</span>

<span class="no">KRPC</span><span class="p">.</span><span class="nf">connect</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="o">|</span>
  <span class="n">vessel</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">space_center</span><span class="p">.</span><span class="nf">active_vessel</span>

  <span class="c1"># VR: 100m/s, Climb at 390 knots to 2000m</span>
  <span class="no">TakeoffProcess</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">).</span><span class="nf">run</span>
  <span class="c1"># Fly to North pole (N90, S0.0) at 330 knots at FL300</span>
  <span class="no">WaypointProcess</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="mi">170</span><span class="p">,</span> <span class="mi">7000</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">).</span><span class="nf">run</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 100m/s 时抬轮，以 390 节速度爬升到 2000 米，然后爬升到 30000 英尺转向飞往北极点。测试完美。</p>

<p><img src="/assets/images/ksp-ap-test.jpg" alt="KSP AP Test" /></p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Mlqzk6bTOxQ" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>完整代码：<a href="https://github.com/dsh0416/ksp-pilot">GitHub dsh0416/ksp-pilot</a></p>

<p>我用的是自带存档强翼 A300 进行的测试。该飞机被设计成大气层内飞行的重型运输机。由于 Kerbin 星球比起地球大气稀薄，到 FL300 飞机已经难以维持 300 节的时速了。不过如果使用空天飞机进行测试则没有这样的问题。</p>

<p>目前的 PID 曲线的调教比较保守，在高度控制上震荡比较厉害。这可以针对具体飞机进行调整，如果在安装 <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a> 的情况下，可以获得具体的「升力系数参数」，其实通过控制升力系数来控制高度是最为可靠的方法，现实中的飞机也是这么做的。</p>

<p>之后如果能获取机场 GPS 坐标实现自动进近和降落应该会更有意思。</p>

<p>不过这个项目还是很有意义的，不但练习了 Ruby 编程，还学习了立体几何、物理、飞行原理和自动化控制的相关知识。</p>]]></content><author><name>CodeRemixer</name></author><category term="KSP" /><category term="Ruby" /><category term="PID" /><summary type="html"><![CDATA[krpc 是一个砍巴拉太空计划（Kerbel Space Program）中的插件。可以通过 RPC 来控制游戏。同时有第三方的 Ruby 客户端：krpc-rb。和真实飞机不同的是，在砍巴拉游戏中驾驶飞机是非常痛苦的，在没有插件辅助的情况下，你看不到具体的 GPS 坐标，很多时候看到的都是和飞机驾驶无关的轨道参数，而一些关键的控制参数缺很难获取。同时游戏中也没有自动驾驶仪。特别在航天飞机降落的控制非常难，虽然手动降落不会太有问题，游戏对于重着陆的容忍度很高，但是要控制飞机飞往机场的过程漫长而痛苦。于是我们试试看利用 krpc 来实现正常商用飞机都有的自动驾驶仪的功能。]]></summary></entry><entry><title type="html">Developing Fiber Scheduler for Ruby 3</title><link href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en" rel="alternate" type="text/html" title="Developing Fiber Scheduler for Ruby 3" /><published>2020-12-22T16:41:41+08:00</published><updated>2020-12-22T16:41:41+08:00</updated><id>https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en</id><content type="html" xml:base="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en"><![CDATA[<p><a href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log/">中文版本</a></p>

<h2 id="ruby-3-fiber-scheduler">Ruby 3 Fiber Scheduler</h2>

<p>I wrote an article in July 2020, <a href="https://coderemixer.com/2020/07/26/whats-new-in-ruby-3-fiber/"><em>Ruby 3 Fiber changes preview (in Chinese)</em></a>,
and followed up by another post in August <a href="https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler/"><em>A Walkthrough of Ruby 3 Scheduler</em></a>.
Ruby 3 has updated lots of versions during these months, including <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview1</code> <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview2</code> and <code class="language-plaintext highlighter-rouge">ruby-3.0.0-rc1</code>,
which makes lots of improvements to the Fiber Scheduler API.</p>

<p>But as I mentioned before, what Ruby 3 implements is the interface.
It would not use the scheduler, unless a scheduler implementation is included.</p>

<p>I am very busy working and studying in the past four months,
and I took some time in the recent days to get updated with the API.</p>

<p>GitHub: <a href="https://github.com/dsh0416/evt">Evt</a></p>

<h2 id="use-of-fiber-scheduler">Use of Fiber Scheduler</h2>

<p>Suppose we have a pair of fds generated by <code class="language-plaintext highlighter-rouge">IO.pipe</code>. When we write <code class="language-plaintext highlighter-rouge">Hello World</code> to one of them, we could read it from the other side of the pipe.
We would have code like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>

<span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">message</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div></div>

<p>This program has lots of limitations. For example, you can’t write a string longer than the buffer size.
Since the other side is not reading at the same time, it would get stuck if the string is too long.
You would also have to write first, otherwise it would also get stuck.
Of course, we could use multi-threading to solve this problem.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'thread'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t1</span><span class="p">.</span><span class="nf">join</span>
<span class="n">t2</span><span class="p">.</span><span class="nf">join</span>
</code></pre></div></div>

<p>But as we all know, using threads to solve I/O problems is very inefficient.
The OS context switch is slow. The fairness of thread scheduling is still a very hard problem in the field of OS.
For an I/O problem, which is not CPU-bound, all we need is to halt it and wait for the proper callback.
In this case, all you need is to call Ruby 3 scheduler.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="n">scheduler</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>In general, an async function requires keywords like <code class="language-plaintext highlighter-rouge">callback</code>, <code class="language-plaintext highlighter-rouge">async</code>, or <code class="language-plaintext highlighter-rouge">await</code>.
But this is not necessary in Ruby 3.
Ruby 3 lists all common situations where you need async functions: I/O multiplexing, process halting, kernel sleep, and mutex.
Ruby 3 exposes all of these interfaces for scheduler to improve the performance without adding any new keywords.
My project <a href="https://github.com/dsh0416/evt">evt</a> is such a scheduler to meet the needs of Ruby 3 Scheduler.</p>

<p>Comparing to the simple example above, here is an example of HTTP/1.1 server</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="vi">@scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>
<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="vi">@scheduler</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_INET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">bind</span> <span class="no">Addrinfo</span><span class="p">.</span><span class="nf">tcp</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">3002</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">listen</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOMAXCONN</span>

<span class="k">def</span> <span class="nf">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">until</span> <span class="n">socket</span><span class="p">.</span><span class="nf">closed?</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">until</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span> <span class="o">||</span> <span class="n">line</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">end</span>
    <span class="n">socket</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s2">Content-Length: 0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">socket</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">accept</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
      <span class="n">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vi">@scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>We could see from this that, the code is almost the same with synchronous development.
All you need to do is to setup the scheduler with <code class="language-plaintext highlighter-rouge">Fiber.set_scheduler</code>,
and add <code class="language-plaintext highlighter-rouge">Fiber.scheduler</code> where you usually have to solve with multithreading.
Finally, use <code class="language-plaintext highlighter-rouge">scheduler.run</code> to start the scheduler.</p>

<h2 id="backend-support">Backend support</h2>

<h3 id="io_uring-support"><code class="language-plaintext highlighter-rouge">io_uring</code> Support</h3>

<p>Not only the Ruby API gets lots of updates in the recent months, but also my scheduler. Especially for a better I/O multiplexing backend support.
<code class="language-plaintext highlighter-rouge">io_uring</code> is included since Linux 5.4.
Since the <code class="language-plaintext highlighter-rouge">io_uring</code> could reduce the syscalls and could have direct <code class="language-plaintext highlighter-rouge">iov</code> calls to acheive better performance comparing to <code class="language-plaintext highlighter-rouge">epoll</code>,
the support of <code class="language-plaintext highlighter-rouge">io_uring</code> is important.
Direct <code class="language-plaintext highlighter-rouge">iov</code> support requires Ruby Fiber scheduler for some further changes.
These changes are introduced by ioquatix since Ruby 3.0.0-preview2.
What we need to implement is two parts.
One of them is <code class="language-plaintext highlighter-rouge">epoll</code> compatible API:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;liburing.h&gt;</span><span class="cp">
</span>
<span class="cp">#define URING_ENTRIES 64
#define URING_MAX_EVENTS 64
</span>
<span class="k">struct</span> <span class="n">uring_data</span> <span class="p">{</span>
  <span class="n">bool</span> <span class="n">is_poll</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">poll_mask</span><span class="p">;</span>
  <span class="n">VALUE</span> <span class="n">io</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">rb_data_type_t</span> <span class="n">type_uring_payload</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">wrap_struct_name</span> <span class="o">=</span> <span class="s">"uring_payload"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">dmark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dfree</span> <span class="o">=</span> <span class="n">uring_payload_free</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">uring_payload_size</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">RUBY_TYPED_FREE_IMMEDIATELY</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">io_uring_queue_exit</span><span class="p">((</span><span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">xfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">));</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">io_uring_queue_init</span><span class="p">(</span><span class="n">URING_ENTRIES</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eIOError</span><span class="p">,</span> <span class="s">"unable to initalize io_uring"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>

    <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_IN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_OUT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="n">poll_mask</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_poll_add</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">poll_mask</span><span class="p">);</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// io_uring runs under oneshot mode. No need to deregister.</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The other part is direct iov support:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_io_read</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">read_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">read_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_readv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_str_new</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_str_append</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_io_write</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">write_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">write_buffer</span> <span class="o">=</span> <span class="n">StringValueCStr</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">write_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_writev</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But in some cases, the iov would not be called. I’m still figuring out the bug. But at least the performance is very close to <code class="language-plaintext highlighter-rouge">epoll</code>.</p>

<h3 id="iocp-support">IOCP Support</h3>

<p>Another problem is to support Windows IOCP. I tried to implement somethine like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcallv</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">HANDLE</span> <span class="n">io_handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">rb_w32_get_osfhandle</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">interest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">readable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">writable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">HANDLE</span> <span class="n">res</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">io_handler</span><span class="p">,</span> <span class="n">iocp</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_push</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"push"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">OVERLAPPED_ENTRY</span> <span class="n">lpCompletionPortEntries</span><span class="p">[</span><span class="n">IOCP_MAX_EVENTS</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">ulNumEntriesRemoved</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>

    <span class="n">DWORD</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_timeout</span> <span class="o">==</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mh">0x5000</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">next_timeout</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// seconds to milliseconds</span>
    <span class="p">}</span>

    <span class="n">DWORD</span> <span class="n">NumberOfBytesTransferred</span><span class="p">;</span>
    <span class="n">LPOVERLAPPED</span> <span class="n">pOverlapped</span><span class="p">;</span>
    <span class="n">ULONG_PTR</span> <span class="n">CompletionKey</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">res</span> <span class="o">=</span> <span class="n">GetQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NumberOfBytesTransferred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CompletionKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pOverlapped</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="c1">// BOOL res = GetQueuedCompletionStatusEx(</span>
    <span class="c1">//    iocp, lpCompletionPortEntries, IOCP_MAX_EVENTS, &amp;ulNumEntriesRemoved, timeout, TRUE);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_ary_new2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">readables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>
    <span class="n">VALUE</span> <span class="n">writables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>

    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readables</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">writables</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"--------- Received! ---------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Received IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">CompletionKey</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"dwNumberOfBytesTransferred: %lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfBytesTransferred</span><span class="p">);</span>

    <span class="c1">// if (ulNumEntriesRemoved &gt; 0) {</span>
    <span class="c1">//     printf("Entries: %ld\n", ulNumEntriesRemoved);</span>
    <span class="c1">// }</span>

    <span class="c1">// for (ULONG i = 0; i &lt; ulNumEntriesRemoved; i++) {</span>
    <span class="c1">//     OVERLAPPED_ENTRY entry = lpCompletionPortEntries[i];</span>
        
    <span class="c1">//     struct iocp_data *data = (struct iocp_data*) entry.lpCompletionKey;</span>

    <span class="c1">//     int interest = data-&gt;interest;</span>
    <span class="c1">//     VALUE obj_io = data-&gt;io;</span>
    <span class="c1">//     if (interest &amp; readable) {</span>
    <span class="c1">//         rb_funcall(readables, id_push, 1, obj_io);</span>
    <span class="c1">//     } else if (interest &amp; writable) {</span>
    <span class="c1">//         rb_funcall(writables, id_push, 1, obj_io);</span>
    <span class="c1">//     }</span>

    <span class="c1">//     xfree(data);</span>
    <span class="c1">// }</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But the I/O scheduler receives the wrong pointers when callback. After some researches, to support IOCP, you have to initialize the I/O with <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> flag.
This may need some changes in Ruby <code class="language-plaintext highlighter-rouge">win32/win32.c</code> to support IOCP.
But at least I solved the problems of the <code class="language-plaintext highlighter-rouge">IO.select</code> fallback.
The problem is fine, since nobody cares about Windows production performance…</p>

<h3 id="kqueue-improvements"><code class="language-plaintext highlighter-rouge">kqueue</code> Improvements</h3>

<p>Another Improvement is to macOS <code class="language-plaintext highlighter-rouge">kqueue</code>.
<code class="language-plaintext highlighter-rouge">kqueue</code> on FreeBSD is good. Bug the performance on macOS is really weird.
Since all of our I/O registration is in one-shot, I used one-shot mode of <code class="language-plaintext highlighter-rouge">kqueue</code> to reduce the number of syscalls.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">kevent</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u_short</span> <span class="n">event_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_READ</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_WRITE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">EV_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">EV_ADD</span><span class="o">|</span><span class="n">EV_ENABLE</span><span class="o">|</span><span class="n">EV_ONESHOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">io</span><span class="p">);</span>
    <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// TODO: Check the return value</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="overall">Overall</h3>

<p>At last, we support almost all I/O multiplexing backends of mostly used OS:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Linux</th>
      <th>Windows</th>
      <th>macOS</th>
      <th>FreeBSD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>io_uring</td>
      <td>✅  (See 1)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>epoll</td>
      <td>✅  (See 2)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>kqueue</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅ (⚠️See 5)</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>IOCP</td>
      <td>❌</td>
      <td>❌ (⚠️See 3)</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Ruby (<code class="language-plaintext highlighter-rouge">IO.select</code>)</td>
      <td>✅ Fallback</td>
      <td>✅ (⚠️See 4)</td>
      <td>✅ Fallback</td>
      <td>✅ Fallback</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>when liburing is installed</li>
  <li>when kernel version &gt;= 2.6.8</li>
  <li>WOULD NOT WORK until <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> is included in I/O initialization process.</li>
  <li>Some I/Os are not able to be nonblock under Windows. See <a href="https://docs.ruby-lang.org/en/master/doc/scheduler_md.html#label-IO">Scheduler Docs</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">kqueue</code> performance in Darwin is very poor. <strong>MAY BE DISABLED IN THE FUTURE.</strong></li>
</ol>

<h2 id="benchmark">Benchmark</h2>

<p>How is the overall performance?</p>

<p>The benchmark is running under <code class="language-plaintext highlighter-rouge">v0.2.2</code> version and Ruby 3.0.0-rc1.
See <a href="https://github.com/dsh0416/evt-server-benchmark">evt-server-benchmark</a> for test code, the test is running under a single-thread server.</p>

<p>The test command is <code class="language-plaintext highlighter-rouge">wrk -t4 -c8192 -d30s http://localhost:3001</code>.</p>

<p>All of the systems have set their file descriptor limit to maximum.</p>

<table>
  <thead>
    <tr>
      <th>OS</th>
      <th>CPU</th>
      <th>Memory</th>
      <th>Backend</th>
      <th>req/s</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>epoll</td>
      <td>54680.08</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>io_uring</td>
      <td>50245.53</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>IO.select (using poll)</td>
      <td>44159.23</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>kqueue</td>
      <td>37855.53</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>IO.select (using poll)</td>
      <td>28293.36</td>
    </tr>
  </tbody>
</table>

<p>Very impressive. The results improvements are from lots of aspects.
Current async frameworks like Falcon uses <a href="https://github.com/socketry/nio4r">nio4r</a>.
The backend of <a href="https://github.com/socketry/nio4r">nio4r</a> is libev.
The performance of libev is average due to the extreme compatibility design.
Existing async frameworks also requires lots of meta-programming.
But this extension is almost written in C, with only the features the scheduler need.</p>

<p>Comparing to my previous tests on preview 1, this version uses long connection, and Ruby nonblock I/O also has fixed a lot.
The <code class="language-plaintext highlighter-rouge">wrk</code> results are very error-sensitive. All of these things makes our performance 10 times faster comparing to what we have done 3 months ago.</p>

<p><strong>wrk is very error-sensitive, the parser in the benchmark is incorrect, which could not close the socket properly. I updated my <a href="https://github.com/midori-rb/midori.rb">Midori</a> to a Ruby 3 Scheduler project, the performance could reach 247k req/s with kqueue and 647k req/s with epoll, which is more than 100x times faster comparing to blocking I/O.</strong></p>

<h2 id="combining-with-ractor">Combining with Ractor</h2>

<p>I also wrote a post on November about Ractor  <a href="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide/"><em>Ruby 3 Ractor Dev Guide (in Chinese)</em></a>
Combining Fiber with Ractor is always a interesting thing. We have two routes for that:</p>

<ol>
  <li>Receive accpets in the main Ractor, and dispatch the request to sub-Ractors. After transferring the results back, return it from the main Ractor with scheduler.</li>
  <li>Use Linux <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code> feature to let all Ractor listen to the port at the same time, which is very easy to deal with with exisiting server archs.</li>
</ol>

<p>Unfortunately, either of these are functioning correctly now. Some Fiber features are not available in Ractor.
I suppose this is a bug, and have submitted a patch <a href="https://github.com/ruby/ruby/pull/3971">GitHub #3971</a>.
According to my previous benchmarks, Ractor my increase about 4 times the performance by multi-core.</p>

<p>But since API servers are usually stateless, these improvements could be acheived by multi-processes.
Ractor’s majot contribution may be fewer memory consumption.</p>

<p>I would test it with Ruby 3.0 future updates.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We acheived a 10 times performance improvement comparing to preview 1, and almost 36 times faster comparing to blocking I/O. The major performance issue of Ruby servers are I/O blocking instead of VM performance.
With the I/O scheduler is included, we could improve the I/O performance of Ruby 3 into a new era.
The future work is to wait for the updates of some C extension libraries like database connections.
Then if we use an async scheduler with a Fiber based Web server like  <a href="https://github.com/socketry/falcon">Falcon</a>,
you don’t have to do anything about your business code to get dozens of times of performance improvements.</p>

<p>Let’s continue happy programming with Ruby.</p>]]></content><author><name>CodeRemixer</name></author><category term="Programming" /><category term="Ruby" /><category term="Fiber" /><summary type="html"><![CDATA[中文版本]]></summary></entry><entry><title type="html">为 Ruby 3 Fiber 调度器设计事件库 Evt</title><link href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log" rel="alternate" type="text/html" title="为 Ruby 3 Fiber 调度器设计事件库 Evt" /><published>2020-12-22T16:41:41+08:00</published><updated>2020-12-22T16:41:41+08:00</updated><id>https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log</id><content type="html" xml:base="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log"><![CDATA[<p><a href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en/">For English Readers</a></p>

<h2 id="ruby-3-fiber-调度器">Ruby 3 Fiber 调度器</h2>

<p>我在 2020 年 7 月写过一篇文章 <a href="https://coderemixer.com/2020/07/26/whats-new-in-ruby-3-fiber/">《Ruby 3 Fiber 变化前瞻》</a>，以及后来 8 月又写过一篇文章 <a href="https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler-cn/">《尝试使用 Ruby 3 调度器》</a>，简单介绍了 Fiber 调度器。Ruby 3 在这几个月中更新了数个版本，包括 <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview1</code> <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview2</code> 和 <code class="language-plaintext highlighter-rouge">ruby-3.0.0-rc1</code>，其对于 Fiber 调度器的 API 做了更多的改进。</p>

<p>不过正如我之前所说，Ruby 3 调度器实现的只有接口，如果没有配套的接口实现，默认是不会启动的。最近四个月工作实在很忙，抽出了点时间来跟上 API 更新的脚步。这个项目得以进一步更新。</p>

<p>项目地址：<a href="https://github.com/dsh0416/evt">Evt</a></p>

<h2 id="fiber-调度器的使用">Fiber 调度器的使用</h2>

<p>我们假设我们现在有一对 <code class="language-plaintext highlighter-rouge">IO.pipe</code>，我们往一个里写入 <code class="language-plaintext highlighter-rouge">Hello World</code>，然后从另一个里读出来。我们可能会写这样一份代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>

<span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">message</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div></div>

<p>不过这个程序有很多限制，比如写入不能超过 <code class="language-plaintext highlighter-rouge">buffer</code>，否则另一端由于没有异步读取，会卡死。以及必须要先写再读，否则也会卡死。当然我们可以使用多线程来解决这个问题：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'thread'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t1</span><span class="p">.</span><span class="nf">join</span>
<span class="n">t2</span><span class="p">.</span><span class="nf">join</span>
</code></pre></div></div>

<p>但我们知道，使用线程来实现 I/O 的多路复用是效率极低的。操作系统的线程切换代价非常大，甚至对于线程之间调度的公平性，至今都是操作系统研究领域的噩梦。然而对于一个 I/O 问题，并不是 CPU-bound 的，只是需要调度器提供合适的睡眠和回调。这时，你只需要调用 Ruby 3 的调度器接口来替代线程就可以了。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="n">scheduler</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>一般来说异步代码需要写 <code class="language-plaintext highlighter-rouge">callback</code> 或者引入 <code class="language-plaintext highlighter-rouge">async</code> <code class="language-plaintext highlighter-rouge">await</code> 的关键字。但是在 Ruby 3 中这是不必要的。Ruby 3 列举了所有常见的需要进行上下文切换调度的场景：I/O 多路复用、等待进程退出、内核睡眠、自旋锁。把这些接口暴露出来，让开发者可以通过自行开发调度器来进行处理，从而无需引入任何额外的关键字。而我这几个月写的 <a href="https://github.com/dsh0416/evt">Evt</a> 就是这样一个调度器。</p>

<p>比起上面这个简单的例子，下面这个例子是一个 HTTP/1.1 的服务器</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="vi">@scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>
<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="vi">@scheduler</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_INET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">bind</span> <span class="no">Addrinfo</span><span class="p">.</span><span class="nf">tcp</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">3002</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">listen</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOMAXCONN</span>

<span class="k">def</span> <span class="nf">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">until</span> <span class="n">socket</span><span class="p">.</span><span class="nf">closed?</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">until</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span> <span class="o">||</span> <span class="n">line</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">end</span>
    <span class="n">socket</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s2">Content-Length: 0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">socket</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">accept</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
      <span class="n">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vi">@scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>可以看出来，开发的过程基本上和同步阻塞的线程开发没有任何区别，只需要 <code class="language-plaintext highlighter-rouge">Fiber.set_scheduler</code> 来设置你的调度器，然后在每个原先需要多线程来处理的 I/O 阻塞场景用 <code class="language-plaintext highlighter-rouge">Fiber.scheduler</code> 来替代。最后触发 <code class="language-plaintext highlighter-rouge">scheduler.run</code> 来启动调度器即可。</p>

<h2 id="后端支持情况">后端支持情况</h2>

<h3 id="io_uring-支持"><code class="language-plaintext highlighter-rouge">io_uring</code> 支持</h3>

<p>这几个月不止 Ruby API 进行了很多优化，我的调度器也做了很多优化，比如做了许多 I/O 多路复用后端的优化。一个是 Linux 5.4 开始引入的 <code class="language-plaintext highlighter-rouge">io_uring</code> 多路复用的支持。由于 <code class="language-plaintext highlighter-rouge">io_uring</code> 可以减少 <code class="language-plaintext highlighter-rouge">syscall</code> 调用次数以及直接的 <code class="language-plaintext highlighter-rouge">iov</code> 调用理论上能比 <code class="language-plaintext highlighter-rouge">epoll</code> 达到更好的性能。直接的 <code class="language-plaintext highlighter-rouge">iov</code> 调用需要 Ruby Fiber 调度器接口上的额外支持。在和 ioquatix 讨论后，Ruby 3.0.0-preview2 开始引入了相关的接口。于是整个 <code class="language-plaintext highlighter-rouge">io_uring</code> 的实现需要两个部分，一个是和 <code class="language-plaintext highlighter-rouge">epoll</code> 模式兼容的 one-shot polling 相关的代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;liburing.h&gt;</span><span class="cp">
</span>
<span class="cp">#define URING_ENTRIES 64
#define URING_MAX_EVENTS 64
</span>
<span class="k">struct</span> <span class="n">uring_data</span> <span class="p">{</span>
  <span class="n">bool</span> <span class="n">is_poll</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">poll_mask</span><span class="p">;</span>
  <span class="n">VALUE</span> <span class="n">io</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">rb_data_type_t</span> <span class="n">type_uring_payload</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">wrap_struct_name</span> <span class="o">=</span> <span class="s">"uring_payload"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">dmark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dfree</span> <span class="o">=</span> <span class="n">uring_payload_free</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">uring_payload_size</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">RUBY_TYPED_FREE_IMMEDIATELY</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">io_uring_queue_exit</span><span class="p">((</span><span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">xfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">));</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">io_uring_queue_init</span><span class="p">(</span><span class="n">URING_ENTRIES</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eIOError</span><span class="p">,</span> <span class="s">"unable to initalize io_uring"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>

    <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_IN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_OUT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="n">poll_mask</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_poll_add</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">poll_mask</span><span class="p">);</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// io_uring runs under oneshot mode. No need to deregister.</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一部分则是直接的 iov 支持：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_io_read</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">read_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">read_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_readv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_str_new</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_str_append</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_io_write</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">write_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">write_buffer</span> <span class="o">=</span> <span class="n">StringValueCStr</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">write_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_writev</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不过目前不知道为什么 <code class="language-plaintext highlighter-rouge">iov</code> 调用没有被 Ruby Scheduler 识别到，目前还在修复相关的问题。不过好消息是至少达到了接近 <code class="language-plaintext highlighter-rouge">epoll</code> 的性能了。</p>

<h3 id="iocp-支持">IOCP 支持</h3>

<p>另一个麻烦的地方是 Windows IOCP 支持。我试图写了一个 IOCP 的调度器：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcallv</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">HANDLE</span> <span class="n">io_handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">rb_w32_get_osfhandle</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">interest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">readable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">writable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">HANDLE</span> <span class="n">res</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">io_handler</span><span class="p">,</span> <span class="n">iocp</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_push</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"push"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">OVERLAPPED_ENTRY</span> <span class="n">lpCompletionPortEntries</span><span class="p">[</span><span class="n">IOCP_MAX_EVENTS</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">ulNumEntriesRemoved</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>

    <span class="n">DWORD</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_timeout</span> <span class="o">==</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mh">0x5000</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">next_timeout</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// seconds to milliseconds</span>
    <span class="p">}</span>

    <span class="n">DWORD</span> <span class="n">NumberOfBytesTransferred</span><span class="p">;</span>
    <span class="n">LPOVERLAPPED</span> <span class="n">pOverlapped</span><span class="p">;</span>
    <span class="n">ULONG_PTR</span> <span class="n">CompletionKey</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">res</span> <span class="o">=</span> <span class="n">GetQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NumberOfBytesTransferred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CompletionKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pOverlapped</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="c1">// BOOL res = GetQueuedCompletionStatusEx(</span>
    <span class="c1">//    iocp, lpCompletionPortEntries, IOCP_MAX_EVENTS, &amp;ulNumEntriesRemoved, timeout, TRUE);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_ary_new2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">readables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>
    <span class="n">VALUE</span> <span class="n">writables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>

    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readables</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">writables</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"--------- Received! ---------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Received IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">CompletionKey</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"dwNumberOfBytesTransferred: %lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfBytesTransferred</span><span class="p">);</span>

    <span class="c1">// if (ulNumEntriesRemoved &gt; 0) {</span>
    <span class="c1">//     printf("Entries: %ld\n", ulNumEntriesRemoved);</span>
    <span class="c1">// }</span>

    <span class="c1">// for (ULONG i = 0; i &lt; ulNumEntriesRemoved; i++) {</span>
    <span class="c1">//     OVERLAPPED_ENTRY entry = lpCompletionPortEntries[i];</span>
        
    <span class="c1">//     struct iocp_data *data = (struct iocp_data*) entry.lpCompletionKey;</span>

    <span class="c1">//     int interest = data-&gt;interest;</span>
    <span class="c1">//     VALUE obj_io = data-&gt;io;</span>
    <span class="c1">//     if (interest &amp; readable) {</span>
    <span class="c1">//         rb_funcall(readables, id_push, 1, obj_io);</span>
    <span class="c1">//     } else if (interest &amp; writable) {</span>
    <span class="c1">//         rb_funcall(writables, id_push, 1, obj_io);</span>
    <span class="c1">//     }</span>

    <span class="c1">//     xfree(data);</span>
    <span class="c1">// }</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但实际发现收到的 I/O 全部都是错误的指针。一番研究后发现，如果要让 IOCP 调度对应的 I/O，该 I/O 在初始化时就要有  <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> Flag 的支持。这意味着还需要 Ruby 的 <code class="language-plaintext highlighter-rouge">win32/win32.c</code> 中做出一些改进，才能在调度器中正确调度 IOCP。不过 Windows 上的 fallback <code class="language-plaintext highlighter-rouge">IO.select</code> 调度器还是能正常使用的，这问题就不大，毕竟谁在乎 Windows 的生产性能呢…</p>

<h3 id="kqueue-支持改进"><code class="language-plaintext highlighter-rouge">kqueue</code> 支持改进</h3>

<p>另一个做出的改进是在 macOS 的 <code class="language-plaintext highlighter-rouge">kqueue</code> 上。<code class="language-plaintext highlighter-rouge">kqueue</code> 在 FreeBSD 上的性能相当好，但是在 macOS 上就比较拉跨。只能通过减少 <code class="language-plaintext highlighter-rouge">syscall</code> 来提高性能。这几个月的一个改进是使用了 <code class="language-plaintext highlighter-rouge">kqueue</code> 的 one-shot 模式，来减少一次 deregister 需要的 <code class="language-plaintext highlighter-rouge">syscall</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">kevent</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u_short</span> <span class="n">event_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_READ</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_WRITE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">EV_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">EV_ADD</span><span class="o">|</span><span class="n">EV_ENABLE</span><span class="o">|</span><span class="n">EV_ONESHOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">io</span><span class="p">);</span>
    <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// TODO: Check the return value</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="概览">概览</h3>

<p>最后我们把主流的操作系统 I/O 多路复用都写了一遍集成到了我们的事件处理库中，整体情况如下：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Linux</th>
      <th>Windows</th>
      <th>macOS</th>
      <th>FreeBSD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>io_uring</td>
      <td>✅  (见 1)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>epoll</td>
      <td>✅  (见 2)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>kqueue</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅ (⚠️见 5)</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>IOCP</td>
      <td>❌</td>
      <td>❌ (⚠️见 3)</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Ruby (<code class="language-plaintext highlighter-rouge">IO.select</code>)</td>
      <td>✅ Fallback</td>
      <td>✅ (⚠️见 4)</td>
      <td>✅ Fallback</td>
      <td>✅ Fallback</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>当编译时检测到 <code class="language-plaintext highlighter-rouge">liburing-dev</code> 已被安装</li>
  <li>当 Linux 内核版本 &gt;= 2.6.8</li>
  <li>在 I/O 初始化过程中 <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> flag 被引入前 <strong>无法工作</strong>。</li>
  <li>一些 I/O 在 Windows 下无法变成非阻塞 I/O，详见 <a href="https://docs.ruby-lang.org/en/master/doc/scheduler_md.html#label-IO">调度器文档</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">kqueue</code> 在 Darwin 下的一些特殊情况性能很烂，<strong>可能会在未来被禁用。</strong></li>
</ol>

<h2 id="基准测试">基准测试</h2>

<p>那么总体性能如何呢？</p>

<p>下面的测试是在 evt <code class="language-plaintext highlighter-rouge">v0.2.2</code> 和 Ruby 3.0.0-rc1 上运行的，详细的测试代码见 <a href="https://github.com/dsh0416/evt-server-benchmark">evt-server-benchmark</a>。测试仅使用单线程服务器。</p>

<p>测试命令是 <code class="language-plaintext highlighter-rouge">wrk -t4 -c8192 -d30s http://localhost:3001</code>.</p>

<table>
  <thead>
    <tr>
      <th>操作系统</th>
      <th>CPU</th>
      <th>内存</th>
      <th>后端</th>
      <th>请求/秒</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>epoll</td>
      <td>54680.08</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>io_uring</td>
      <td>50245.53</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>Ruby (使用 poll)</td>
      <td>44159.23</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>kqueue</td>
      <td>37855.53</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>Ruby (使用 poll)</td>
      <td>28293.36</td>
    </tr>
  </tbody>
</table>

<p>相当惊人。这个结果有几方面因素。现在的 Falcon 等异步框架使用的都是基于 <a href="https://github.com/socketry/nio4r">nio4r</a> 来实现的，其背后是 libev。libev 在各个异步事件库中的性能本来就是比较一般的，再加上其为了更好的兼容性做了大量的妥协。另一方面，以前的调度库需要大量 Ruby 元编程帮助，而现在几乎都是在 C extension 间完成的，性能也有了很大的提升。</p>

<p>另外比起我们之前在 preview1 上做的测试，这个版本的 Fiber 调度器修复了大量的错误，而 wrk 的测试结果是非常错误敏感的，这使得我们最终的请求速度比起之前又提升了 10 倍。</p>

<p><strong>wrk 对于错误非常敏感，这个 benchmark 中的 parser 有问题，无法准确关闭 socket。把我的 <a href="https://github.com/midori-rb/midori.rb">Midori</a> 重新捡起来改成了 Ruby 3 Scheduler 项目。性能达到了 247k req/s 单线程使用 kqueue！使用 epoll 更是达到了 647k req/s！达到了上百倍的性能提升。</strong></p>

<h2 id="与-ractor-结合">与 Ractor 结合</h2>

<p>我在 2020 年 11 月 17 日写过一篇关于 Ractor 的扫盲贴 <a href="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide/">《Ractor 下多线程 Ruby 程序指南》</a>，Ractor 和 Fiber 的结合始终是一个有意思的话题。目前情况下 Fiber 与 Ractor 结合来实现 Web 服务器有两个可能的路径：</p>

<ol>
  <li>在主 Ractor 部署一个调度器，用来处理请求的 accept。将请求派发到子 Ractor 中，由子线程进行处理后将返回值传回主 Ractor 中进行请求返回。</li>
  <li>利用 Linux 内核 <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code> 特性让多个 Ractor 同时监听请求，即可直接将单线程服务器扩展成多线程服务器。</li>
</ol>

<p>比较可惜的是，目前这两者都是无法实现的。因为目前 Fiber 的一些特性无法在 Ractor 中使用。我个人倾向认为这是误报，目前已提交了一个 patch <a href="https://github.com/ruby/ruby/pull/3971">GitHub #3971</a>。根据我之前的测试，Ractor 的加入在实际上应该还能再提升 4 倍左右的吞吐量。不过由于 API 服务器通常是无状态的，主要矛盾也不是 CPU-bound，所以这些吞吐量也是可以由多进程来实现的，Ractor 的引入更多是比起多进程实现的内存消耗降低。</p>

<p>等 Ruby 3.0 更新后我们可以进一步测试。</p>

<h2 id="总结">总结</h2>

<p>这比起 preview1 10 倍的性能提升，和比起以前阻塞 I/O 近 36 倍的性能提升足以证明 Ruby 目前<strong>服务器的性能</strong>问题的本质是 I/O 阻塞问题，而不是 Ruby CPU 执行慢的问题。而随着 I/O 调度器的引入，Ruby 3 的 I/O 性能能更上一个台阶。接下来我们要等待的就是一些使用 C 原生组件的，比如数据库驱动和 Redis 驱动的更新。然后使用一个基于 Fiber 的 Web 服务器，例如 <a href="https://github.com/socketry/falcon">Falcon</a>。无需任何业务上代码的变化，就能得到数倍甚至数十倍的性能提升。</p>

<p>让我们继续享受 Ruby 的快乐编程。</p>]]></content><author><name>CodeRemixer</name></author><category term="编程" /><category term="Ruby" /><category term="Fiber" /><summary type="html"><![CDATA[For English Readers]]></summary></entry><entry><title type="html">Ractor 下多线程 Ruby 程序指南</title><link href="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide" rel="alternate" type="text/html" title="Ractor 下多线程 Ruby 程序指南" /><published>2020-11-17T15:30:24+08:00</published><updated>2020-11-17T15:30:24+08:00</updated><id>https://coderemixer.com/2020/11/17/ruby-3-ractor-guide</id><content type="html" xml:base="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide"><![CDATA[<h2 id="什么是-ractor">什么是 Ractor?</h2>

<p>Ractor 是 Ruby 3 新引入的特性。Ractor 顾名思义是 Ruby 和 Actor 的组合词。Actor 模型是一个基于通讯的、非锁同步的并发模型。基于 Actor 的并发模型在 Ruby 中有很多应用，比如 <code class="language-plaintext highlighter-rouge">concurrent-ruby</code> 中的 <code class="language-plaintext highlighter-rouge">Concurrent::Actor</code>。Concurrent Ruby 虽然引入了大量的抽象模型，允许开发高并发的应用，但是它并不能摆脱 Ruby 的 GIL (Global Interpreter Lock)，这使得同一时间，只有一个线程是活跃的。所以通常 <code class="language-plaintext highlighter-rouge">concurrent-ruby</code> 需要搭配无锁的 JRuby 解释器使用。然而，直接解除 GIL 锁会导致大量默认 GIL 可用的依赖出现问题，在多线程开发中会产生难以预料的线程竞争问题。</p>

<p>去年在 RubyConf China 的时候，我问 matz 说 90 年代多核的小型机以及超级计算机已经变得非常普遍了，为什么会把 Ruby 的多线程设计成这样呢？matz 表示，他当时还在用装着 Windows 95 的 PC，如果他知道以后多核会那么普遍，他也不会把 Ruby 设计成这样。</p>

<h2 id="什么数据可以在-ractor-间共享">什么数据可以在 Ractor 间共享？</h2>

<p>但是，历史遗留问题依然需要解决。随着 Fiber Scheduler 在 Ruby 3 引入来提高 I/O 密集场景下单一线程利用率极低的问题；我们需要进一步解决，计算密集场景下，多线程的利用率。</p>

<p>为了解决这一问题，Ruby 3 引入了 Ractor 模型。Ractor 本质来说还是 Thread 线程，但是 Ractor 做了一系列的限制。首先，锁是不会在 Ractor 之间共享的；也就是说，不可能有两个线程争抢同一个锁。Ractor 和 Ractor 之间可以传递消息。Ractor 内部具有全局锁，确保 Ractor 内的行为和原先 Thread 是一致的。传递消息必须是值类型的，这意味着不会有指针跨 Ractor 生存，也会避免数据竞争问题。简而言之，Ractor 把每个 Thread 当作一个 Actor。</p>

<p>但 Ruby 没有真正的值类型。但值类型的本质就是用拷贝来替代引用。我们要做的就是确保 Ruby 对象的可拷贝性。我们查看 Ractor 的文档，我们可以看到这个的严格描述：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ractors don't share everything, unlike threads.
<span class="p">
*</span> Most objects are <span class="ge">*Unshareable objects*</span>, so you don't need to care about thread-safety problem which is caused by sharing.
<span class="p">*</span> Some objects are <span class="ge">*Shareable objects*</span>.
<span class="p">  *</span> Immutable objects: frozen objects which don't refer to unshareable-objects.
<span class="p">    *</span> <span class="sb">`i = 123`</span>: <span class="sb">`i`</span> is an immutable object.
<span class="p">    *</span> <span class="sb">`s = "str".freeze`</span>: <span class="sb">`s`</span> is an immutable object.
<span class="p">    *</span> <span class="sb">`a = [1, [2], 3].freeze`</span>: <span class="sb">`a`</span> is not an immutable object because <span class="sb">`a`</span> refer unshareable-object <span class="sb">`[2]`</span> (which is not frozen).
<span class="p">  *</span> Class/Module objects
<span class="p">  *</span> Special shareable objects
<span class="p">    *</span> Ractor object itself.
<span class="p">    *</span> And more...
</code></pre></div></div>

<h2 id="ractor-性能提升测试">Ractor 性能提升测试</h2>

<p>为了测试出 Ractor 的效果，我们需要一个计算密集的场景。最计算密集的场景，当然就是做数学计算本身。比如我们有下面一个程序：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DAT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="mi">72072000</span><span class="p">).</span><span class="nf">to_a</span>
<span class="nb">p</span> <span class="no">DAT</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>这个程序计算 0 到 72072000 的平方和。我们运行一下这个程序，得到运行时间是 8.17s。</p>

<p>如果我们用传统的多线程来写，我们可以把程序写成这样：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">THREADS</span> <span class="o">=</span> <span class="mi">8</span>
<span class="no">LCM</span> <span class="o">=</span> <span class="mi">72072000</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="no">THREADS</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="n">r</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="p">(((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">...</span><span class="p">((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))).</span><span class="nf">to_a</span>
    <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">dat</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">r</span>
<span class="k">end</span>

<span class="n">t</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">join</span> <span class="p">}</span>
<span class="nb">p</span> <span class="n">res</span><span class="p">.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>运行后，我们发现，虽然确实创建了 8 个系统线程，但是总运行时间变成了 8.21s。没有显著的性能提升。</p>

<p>使用 Ractor 重写程序，主要需要改变我们子线程内需要访问外面的 <code class="language-plaintext highlighter-rouge">i</code> 变量，我们用消息的方法传递进去，改进后的代码会变成这样：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">THREADS</span> <span class="o">=</span> <span class="mi">8</span>
<span class="no">LCM</span> <span class="o">=</span> <span class="mi">72072000</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

<span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="no">THREADS</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="n">r</span> <span class="o">=</span> <span class="no">Ractor</span><span class="p">.</span><span class="nf">new</span> <span class="n">i</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="p">(((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">...</span><span class="p">((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))).</span><span class="nf">to_a</span>
    <span class="n">dat</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">r</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="n">t</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">take</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>其结果如何呢？我们根据不同的线程数量进行了测试。</p>

<table>
  <thead>
    <tr>
      <th><strong>Threads</strong></th>
      <th><strong>AMD Ryzen 7 2700x</strong></th>
      <th><strong>Intel i7-6820HQ</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1</strong></td>
      <td>8.171</td>
      <td>12.027</td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td>4.483</td>
      <td>6.913</td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td>4.874</td>
      <td>6.755</td>
    </tr>
    <tr>
      <td><strong>4</strong></td>
      <td>2.353</td>
      <td>6.188</td>
    </tr>
    <tr>
      <td><strong>5</strong></td>
      <td>2.429</td>
      <td>5.154</td>
    </tr>
    <tr>
      <td><strong>6</strong></td>
      <td>2.259</td>
      <td>5.320</td>
    </tr>
    <tr>
      <td><strong>7</strong></td>
      <td>1.908</td>
      <td>5.368</td>
    </tr>
    <tr>
      <td><strong>8</strong></td>
      <td>2.156</td>
      <td>5.754</td>
    </tr>
    <tr>
      <td><strong>9</strong></td>
      <td>2.136</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>10</strong></td>
      <td>3.159</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>11</strong></td>
      <td>2.577</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>12</strong></td>
      <td>2.679</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>13</strong></td>
      <td>2.787</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>14</strong></td>
      <td>2.615</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>15</strong></td>
      <td>2.197</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>16</strong></td>
      <td>2.303</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/ractor-benchmark.png" alt="Ractor Benchmark" /></p>

<p>Ractor 确实改善了多线程全局解释锁的问题。</p>

<h2 id="显微镜下的-ractor">显微镜下的 Ractor</h2>

<p>我使用了 AMD uProf（对于 Intel CPU，可以使用 Intel VTune）进行 CPU 运算情况的统计。为了降低睿频对单线程性能的影响，我将 AMD Ryzen 7 2700x 全核心锁死 4.2GHz。</p>

<p><img src="/assets/images/ractor-uprof.png" alt="uProf Results" /></p>

<p>对于 AMD Ryzen 7 2700x，4 线程比单一线程快了 3 倍多。到 4 线程，比单一线程快了约 4 倍。AMD Ryzen 7 2700x 是一款 8 核心 16 线程的 CPU。同时，每 4 个核心组成一个 CCX，跨 CCX 的内存访问有额外的代价。这使得 4 线程内性能提升很显著，超过 4 线程后受限于 CCX 和 SMT，性能提升变得比较有限。其表现是随着线程数的增加，IPC（每时钟周期指令数）开始下降。在单线程运算时，每时钟周期 CPU 可以执行 2.42 个指令；但到了 16 线程运算时，每时钟周期 CPU 只能执行 1.40 个指令。同时，更多的线程意味着更复杂的操作系统的线程调度，使得多核的利用率越来越低。</p>

<p>同样，对于 Intel i7-6820HQ，我们得到了类似的结论。这是一款 4 核 8 线程的 CPU，由于第 5 个线程开始需要使用 HT，从而提升变得很有限。</p>

<h2 id="ractor-如何改善现有-ruby-程序的性能">Ractor 如何改善现有 Ruby 程序的性能？</h2>

<p>Ractor 的引入除了可以改善计算密集场景下的运算效率，对于现有大型 Ruby Web 程序的内存占用也是有积极意义的。现有 Web 服务器，比如 puma，由于 I/O 多路复用性能极其低下，通常会使用多线程 + 多进程的形式来提升性能。由于 Web 服务器可以自由水平扩展，使用多进程的形式来管理，可以完全解开 GIL 锁的问题。</p>

<p>但是 fork 指令效率低下。微软在 2019 年 HOTOS 上给出了一篇论文：<a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf">A fork() in the road</a>，和 spawn 相比，fork 模式会导致启动速度变得非常慢。为了缓解这一问题，在 Ruby 2.7 引入 <code class="language-plaintext highlighter-rouge">GC.compact</code> 后，通常需要执行多次 <code class="language-plaintext highlighter-rouge">compact</code> 来降低 fork 启动的消耗。进一步地，使用 Ractor 来替代多进程管理，可以更容易地传递消息，复用可冻结的常量，从而降低内存占用。</p>

<h2 id="总结">总结</h2>

<p>Ruby 3 打开了多线程的潘多拉盒子。我们可以更好利用多线程来改善性能。但是看着 CPU Profiler 下不同线程调用会导致 CPU IPC 下降和缓存命中下降，对程序调优也提出了更高的要求。</p>

<p>我们边走边看吧。</p>]]></content><author><name>CodeRemixer</name></author><category term="编程" /><category term="Ruby" /><summary type="html"><![CDATA[什么是 Ractor?]]></summary></entry><entry><title type="html">真的存在没有反光的眼镜吗？</title><link href="https://coderemixer.com/2020/11/10/how-anti-reflective-coating-works" rel="alternate" type="text/html" title="真的存在没有反光的眼镜吗？" /><published>2020-11-10T23:48:24+08:00</published><updated>2020-11-10T23:48:24+08:00</updated><id>https://coderemixer.com/2020/11/10/how-anti-reflective-coating-works</id><content type="html" xml:base="https://coderemixer.com/2020/11/10/how-anti-reflective-coating-works"><![CDATA[<p>前几天看某个 YouTuber 说因为眼镜反射很厉害，导致很难打光，想去眼睛店配一副新的眼镜，能减少反光。眼睛店老板号称富士的某款镜片可以「几乎」解决所有反光，花了好几万新台币，买回来发现除了反射从绿色变成了紫色，没有明显差异。</p>

<h2 id="原理">原理</h2>

<p>眼镜镜片减少反射的主要原理是利用镀膜。为什么镀膜可以减少反射呢？我们需要一些简单易懂的物理课。我们将光看成一束波（这里就先不讲量子力学里光的特性，太复杂了），当光打在镜片上时，大部分的光会透过去，少部分会发生反射。如果现在在镜片前还有一层镀膜，由于这是两个不同介质的物质，光线会先发生折射，再发生刚刚的透过和反射的过程。同时在镀膜的表面，还有可能再发生一次反射。于是我们得到了两束平行的反射光，反射 1 和反射 2，这两束光有一个相位差 φ，如果这个相位差恰好能使两束光线的波峰和波谷叠加（发生干涉），那么这部分能量就会被抵消，反射光减小；但是又由于能量守恒，所以透过镜片的光线就会增加。所以这一类镀膜也称为「增透膜」。</p>

<p><img src="/assets/images/ar-coating.jpg" alt="AR Coating" /></p>

<p>我们现在从原理上了解了增透膜如何减少反光，接下来的问题是，镀膜减少的反射光由什么决定？基本上就是膜层的折射率乘以厚度（即光学厚度）。因为这个光学厚度的两倍是光线 2 比光线 1 多走的路程，如果这个厚度恰好是半波长的一半（或者半波长的整倍数加 1/4 波长），那么这束光线就能被完全抵消。</p>

<h2 id="实践分析">实践分析</h2>

<p>那么问题来了，最常见的摄影灯光是白光，白光不是单一波长的光，显然不可能由一层增透膜抵消掉。事实上镜片会使用多层镀膜，多层镀膜的效果比较难计算，但要想抵消掉全部白光里各种波长的光也是困难重重。</p>

<p>那么为什么配了这个减少反光的眼镜后，反光从绿色变成了紫色呢？其实也很好理解，因为 400nm 波长的紫光，比 550nm 左右的绿光半波长更短，这要求镀膜材料的厚度和反射率都要更低。波长越短的光对于材料和镀膜的技术要求都更高，自然就更难处理。</p>

<p>事实上，像是相机镜头中，由于通常需要多组镜片，问题会叠加，提高透光率的要求更高。但随便拿哪个再贵的相机镜头出来，放在太阳地下还是能看到绿色、紫色或者红色的反光，没有能完全抵消掉反光的镜片。</p>

<h2 id="总结">总结</h2>

<p>不过平心而论，各个镜片厂商对于这个镀膜减反射特性的描述都是很详细的。比如说我随便找了一下蔡司的镀膜规格，说的是主要和传统镀膜比起来降低了 1% 左右的绿光反射率，由于人眼对绿光更敏感，所以比较有效果。但是看着这张图就知道在紫色光的 400nm 部分，反射率还是高达 5%，和传统镀膜并没有明显差异。</p>

<p><img src="/assets/images/zeiss-coating.jpg" alt="Zeiss Coating Sample" /></p>

<p>所以这个问题的最后，为什么这个几万元的眼镜明明只是降低了 1% 绿光反射，会让人觉得能降低大部分反射，最后花了冤枉钱呢？其实镜片厂没有骗人，详细的资料列得很清楚，但买镜片的客户并不是从镜片厂直接获取的资讯，经过了一层眼镜店老板。眼镜店老板又不用学习光学，他的职责就是怎么卖出更大的利润，结果就是被眼镜店老板骗了。</p>]]></content><author><name>CodeRemixer</name></author><category term="光学" /><category term="物理" /><summary type="html"><![CDATA[前几天看某个 YouTuber 说因为眼镜反射很厉害，导致很难打光，想去眼睛店配一副新的眼镜，能减少反光。眼睛店老板号称富士的某款镜片可以「几乎」解决所有反光，花了好几万新台币，买回来发现除了反射从绿色变成了紫色，没有明显差异。]]></summary></entry><entry><title type="html">Safari is Fast, but So What?</title><link href="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what-english" rel="alternate" type="text/html" title="Safari is Fast, but So What?" /><published>2020-10-21T10:52:13+08:00</published><updated>2020-10-21T10:52:13+08:00</updated><id>https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what-english</id><content type="html" xml:base="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what-english"><![CDATA[<p>中文版本<a href="/2020/10/21/safari-is-fast-but-so-what/">见此</a></p>

<h2 id="a-mysterious-bug">A Mysterious Bug</h2>

<p>In a day of 2016, we found that our users could not pass the CDN authentication with their iPhones. We then took several days to debug. The situation is that we need to upload three files at the same time. We use the token of the user to generate three random ids. The CDN server would use these ids to authenticate the upload of user files. In this case, we don’t have to transfer the files to CDN on our server.</p>

<p>But soon, iOS users found a weird problem. Users could only upload one of the three files. After debugging, we found that after uploading the first file, the next two ids become illegal. Furthermore, we found the three ids fetched by Safari are precisely the same?!</p>

<h2 id="reproduction">Reproduction</h2>

<p>I soon designed a reproduction of this bug:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
&lt;html&gt;
&lt;script type="text/javascript"&gt;
function reqListener () {
  console.log(this.responseText);
}

for (i = 0; i &lt; 3; i++) {
  var oReq = new XMLHttpRequest();
  oReq.addEventListener("load", reqListener);
  oReq.open("GET", "/count");
  oReq.send();
}
&lt;/script&gt;
&lt;/html&gt;
</span><span class="no">EOF</span>
<span class="k">end</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">get</span> <span class="s1">'/count'</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">count</span><span class="p">.</span><span class="nf">to_s</span>
<span class="k">end</span>

</code></pre></div></div>

<p>On Firefox, you would get 1 2 3, but on Safari, you would get three 1s.</p>

<p>For the same API request, if the parameters are identical. Safari may return same results of all these requests if they are sent asynchronously.</p>

<h2 id="analysis">Analysis</h2>

<p>In general, we may think that GET requests of HTTP/1.1 are Idempotent. If we treat x as the status of the server, and f is the GET request, we would have:</p>

\[f(f(x)) = f(x)\]

<p>The idempotence ensures that the side effects of multiple calls are identical to a single call. We could infer that all responses of the same GET request should also be exact.</p>

<p>But if we check <a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">rfc7231</a> carefully, the definition of the Idempotence is to ensure resend of a failure request safe instead of not allowing the backend to do any non-idempotent operations.</p>

<p>What if we change GET to POST?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
&lt;html&gt;
&lt;script type="text/javascript"&gt;
function reqListener () {
  console.log(this.responseText);
}

for (i = 0; i &lt; 3; i++) {
  var oReq = new XMLHttpRequest();
  oReq.addEventListener("load", reqListener);
  oReq.open("POST", "/count");
  oReq.send();
}
&lt;/script&gt;
&lt;/html&gt;
</span><span class="no">EOF</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/count'</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">count</span><span class="p">.</span><span class="nf">to_s</span>
<span class="k">end</span>
</code></pre></div></div>
<p>IT IS STILL THREE 1s! There’s not any HTTP spectification to define the Idempotence of POST action. This must cause serious problems due to the basic concepts of HTTP actions.</p>

<p>If we check the output from the backend, there is only one 1, which means the three POST requests are cached by Safari?!</p>

<p>If we assume the reliability of idempotence, we could hash the parameters to reduce the response time with cache and improve the performance of callbacks in the event engine of a browser. But apparently, this assumption is incorrect, and Safari does make such optimizations, which causes the bug.</p>

<h2 id="bug-report">Bug Report</h2>

<p><img src="/assets/images/safari-js-bug.png" alt="Screenshot" /></p>

<p>If we check this problem carefully on the Internet, people started asking questions about Safari cache POST requests and Safari cache GET requests with cache disabled from 2012.</p>

<p>I submitted this bug from Apple’s feedback system in 2016. After four years, the feedback system has evolved to Feedback Assistant; Mac OS X has been renamed to macOS; El Capitan has been upgraded to Big Sur. But this bug is still in the latest Safari (16610.2.8.1.1). My ticket is still open, with NO RESPONSE.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Safari is fast, efficient, and power-saving. But if Safari can’t keep essential compatibility with W3C Web API standards, how dare we using this browser? But due to the monopoly of iOS and App Store, iOS developers are not allowed to use third-party Webview, including Chrome and Firefox. Before iOS, nobody cares about Safari. But now, we, the web developers, have to compromise with the incorrect implementation of Safari. Even the evil IE, didn’t use the monopoly of the operating system to force users to accept the specification of a browser.</p>

<p>Safari is not only the new IE, but it is also more evil than IE. Apple is the destroyer of the free Internet system.</p>

<p>F**k you, Apple.</p>]]></content><author><name>CodeRemixer</name></author><category term="Safari" /><category term="Apple" /><category term="Web" /><category term="W3C" /><category term="JavaScript" /><summary type="html"><![CDATA[中文版本见此]]></summary></entry></feed>