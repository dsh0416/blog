<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://coderemixer.com/atom.xml" rel="self" type="application/atom+xml" /><link href="https://coderemixer.com/" rel="alternate" type="text/html" /><updated>2024-02-09T13:30:56+00:00</updated><id>https://coderemixer.com/atom.xml</id><title type="html">Coderemixer 代码混音师</title><subtitle>一个用来发牢骚的网站，以至于无法对所说的话负责。</subtitle><author><name>CodeRemixer</name></author><entry><title type="html">三点几嚟，饮茶先啦 —— 将大马饮料名编译成汉语</title><link href="https://coderemixer.com/2021/07/05/compile-malay-tea-name" rel="alternate" type="text/html" title="三点几嚟，饮茶先啦 —— 将大马饮料名编译成汉语" /><published>2021-07-05T12:44:49+00:00</published><updated>2021-07-05T12:44:49+00:00</updated><id>https://coderemixer.com/2021/07/05/compile-malay-tea-name</id><content type="html" xml:base="https://coderemixer.com/2021/07/05/compile-malay-tea-name"><![CDATA[<p>近几日马来西亚网友 Gurdip Singh 在 Facebook 发的这个「三点几嚟，饮茶先啦」非常流行。</p>

<p>Facebook: www.facebook.com/100009201465316/videos/2530411593942198</p>

<p>Bilibili 搬运：https://www.bilibili.com/video/av845257746/</p>

<p>不过马来语的饮料名称非常有意思。某个目前居住在新加坡的朋友 @david92 给我解释了一下，如何在店里点茶喝。基本是一个组合式的语法，非常规律。最基础的茶底是红茶（Teh）或者咖啡（Kopi）。默认饮料是带糖和炼乳的，但你可以重新定制。如果你在后面加上 O 表示不要加炼乳，而 C 表示把炼乳换成鲜奶。类似，Kosong 是无糖，Siu Dai 是少糖，而 Gah Dai 是加更多的糖。</p>

<h2 id="ebnf-语法">ebnf 语法</h2>

<p>我查阅了一些资料进一步完善了一下这个概念，发现这个语法完全是「可编译」的，非常简单。很快，我写了一个 bnf 语法来描述这个概念：</p>

<pre><code class="language-ebnf">&lt;water&gt;     ::= "Kopi" | "Teh" | "Milo"
&lt;sugar&gt;     ::= "Kosong" | "Siu Dai" | "Gah Dai"
&lt;milk&gt;      ::= "O" | "C"
&lt;thickness&gt; ::= "Po" | "Gau"
&lt;extra&gt;     ::= "Peng" | "Bubble" | "Halia"
&lt;upsize&gt;    ::= "Nga Lat"
&lt;takeout&gt;   ::= "Bungkus" 
&lt;plastic&gt;   ::= "Ikat"
&lt;knot&gt;      ::= "Mati" | "Tepi"

&lt;drink&gt;     ::=
  (&lt;takeout&gt; (" " &lt;plastic&gt; (" " &lt;knot&gt;)?)? " ")?
  (&lt;upsize&gt; " ")?
  &lt;water&gt; (" " &lt;milk&gt;)? (" " &lt;sugar&gt;)?
  (" " &lt;thickness&gt;)?
  (" " &lt;extra&gt;)*
</code></pre>

<p>其中，Po 是清淡，Gau 是浓缩，Peng 是加冰块，Bubble 是加珍珠，Halia 是加姜汁。Nga Lat 是大杯。外带的概念比校复杂，Bungkus 是外带，通常是杯状的。像是 Bernard Tee 视频里那种塑料袋装的，叫 Ikat。Ikat 有两种不同的打结方式，一种是打死结 Mati，还有一种是侧面打结，开口的叫 Tepi。</p>

<p>比如 Bungkus Ikat Mati Nga Lat Kopi O Siu Dai Gau Peng Bubble 就是外带塑料袋装打死结大杯少糖浓缩咖啡加冰块和珍珠。</p>

<p>我们可以在 <a href="https://bnfplayground.pauliankline.com/">ebnf playground</a> 测试这个语法。这个网站甚至能生成随机的符合某个语法（比如这里 Drink）的字符串，来让我们人工检查这个语法对不对。于是截止这里我们还可以实现一个自动生成饮料名的生成器：https://www.bilibili.com/video/BV1SK4y197hc</p>

<h2 id="实现到汉语的编译器">实现到汉语的编译器</h2>

<p>Ruby 中有一个 gem 叫 ebnf 可以读取 ebnf 文件然后生成对应的 parser，然后我们写一个输出中文的 generator 即可将马来西亚语翻译成中文。</p>

<p>由于 ebnf 的语法并没有规范，Ruby ebnf 库和我们刚刚 playground 中的语法有细微不同，这里做了一些变更。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"ebnf"</span>

<span class="no">TEA_GRAMMER</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
Water     ::= "Kopi" | "Teh" | "Milo"
Sugar     ::= "Kosong" | "Siu Dai" | "Gah Dai"
Milk      ::= "O" | "C"
Thickness ::= "Po" | "Gau"
Extra     ::= "Peng" | "Bubble" | "Halia"
Upsize    ::= "Nga Lat"
Knot      ::= "Mati" | "Tepi"
Plastic   ::= "Ikat" Knot?
Takeout   ::= "Bungkus" Plastic?

Drink     ::= Takeout? Upsize? Water Milk? Sugar? Thickness? Extra*
</span><span class="no">EOF</span>
</code></pre></div></div>

<p>由于这个库执行 parse 需要先转换成解析表达文法（Parsing Expression Grammar）从而生成更多的子规则，我们先打印一下自动生成的子规则便于之后开发 generator。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">EBNF</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">TEA_GRAMMER</span><span class="p">).</span><span class="nf">make_peg</span><span class="p">.</span><span class="nf">ast</span>

<span class="cm">=begin
(rule Water (alt "Kopi" "Teh" "Milo"))
(rule Sugar (alt "Kosong" "Siu Dai" "Gah Dai"))
(rule Milk (alt "O" "C"))
(rule Thickness (alt "Po" "Gau"))
(rule Extra (alt "Peng" "Bubble" "Halia"))
(rule Upsize (seq "Nga Lat"))
(rule Knot (alt "Mati" "Tepi"))
(rule Plastic (seq "Ikat" _Plastic_1))
(rule _Plastic_1 (opt Knot))
(rule Takeout (seq "Bungkus" _Takeout_1))
(rule _Takeout_1 (opt Plastic))
(rule Drink (seq _Drink_1 _Drink_2 Water _Drink_3 _Drink_4 _Drink_5 _Drink_6))
(rule _Drink_1 (opt Takeout))
(rule _Drink_2 (opt Upsize))
(rule _Drink_3 (opt Milk))
(rule _Drink_4 (opt Sugar))
(rule _Drink_5 (opt Thickness))
(rule _Drink_6 (star Extra))
=end</span>
</code></pre></div></div>

<p>我们创建一个 generator 类，如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MalayTea</span>
  <span class="kp">include</span> <span class="no">EBNF</span><span class="o">::</span><span class="no">PEG</span><span class="o">::</span><span class="no">Parser</span>
  <span class="nb">attr_reader</span> <span class="ss">:rules</span>
   <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@rules</span> <span class="o">=</span> <span class="no">EBNF</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">TEA_GRAMMER</span><span class="p">).</span><span class="nf">make_peg</span><span class="p">.</span><span class="nf">ast</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="ss">:Drink</span><span class="p">,</span> <span class="vi">@rules</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">MalayTea</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">)</span>
</code></pre></div></div>

<p>这时候输入一个句子，其会如实输出 AST 抽象语法树。而我们要做的就是根据 rule 名称来规约这些语法树直到某个特定输出。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="s2">"外带"</span>
    <span class="k">else</span>
        <span class="s2">"外带</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:Plastic</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="s2">"塑料袋装"</span>
    <span class="k">else</span>
        <span class="s2">"塑料袋装</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Plastic_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Mati</span><span class="p">:</span> <span class="s2">"打死结"</span><span class="p">,</span> <span class="no">Tepi</span><span class="p">:</span> <span class="s2">"侧面打结"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_2</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"大杯"</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:Water</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="p">{</span> <span class="no">Kopi</span><span class="p">:</span> <span class="s2">"咖啡"</span><span class="p">,</span> <span class="no">Teh</span><span class="p">:</span> <span class="s2">"红茶"</span><span class="p">,</span> <span class="no">Milo</span><span class="p">:</span> <span class="s2">"美禄"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_3</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">"炼乳"</span> <span class="p">:</span> <span class="p">{</span> <span class="no">O</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span> <span class="no">C</span><span class="p">:</span> <span class="s2">"鲜奶"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_4</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Kosong</span><span class="p">:</span> <span class="s2">"无糖"</span><span class="p">,</span> <span class="s2">"Siu Dai"</span><span class="p">:</span> <span class="s2">"少糖"</span><span class="p">,</span> <span class="s2">"Gah Dai"</span><span class="p">:</span> <span class="s2">"加糖"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_5</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Gau</span><span class="p">:</span> <span class="s2">"浓缩"</span><span class="p">,</span> <span class="no">Po</span><span class="p">:</span> <span class="s2">"清淡"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_6</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">extras</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
        <span class="p">{</span> <span class="no">Peng</span><span class="p">:</span> <span class="s2">"冰块"</span><span class="p">,</span> <span class="no">Bubble</span><span class="p">:</span> <span class="s2">"珍珠"</span><span class="p">,</span> <span class="no">Halia</span><span class="p">:</span> <span class="s2">"姜汁"</span> <span class="p">}[</span><span class="n">a</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">extras</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"加</span><span class="si">#{</span><span class="n">extras</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们规约最后一步的时候需要特殊处理鲜奶红茶和鲜奶咖啡这两个词语，因为一般我们直接叫奶茶和咖啡拿铁。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">production</span><span class="p">(</span><span class="ss">:Drink</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:merge</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"红茶"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"奶茶"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"咖啡"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"咖啡拿铁"</span>
        <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">end</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_1</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_2</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_4</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_5</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_6</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="成果">成果</h2>

<p>最后我们得到了一个将马来西亚语的饮料名编译到汉语的编译（翻译）器。</p>

<p>完整代码如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"ebnf"</span>

<span class="no">TEA_GRAMMER</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
Water     ::= "Kopi" | "Teh" | "Milo"
Sugar     ::= "Kosong" | "Siu Dai" | "Gah Dai"
Milk      ::= "O" | "C"
Thickness ::= "Po" | "Gau"
Extra     ::= "Peng" | "Bubble" | "Halia"
Upsize    ::= "Nga Lat"
Knot      ::= "Mati" | "Tepi"
Plastic   ::= "Ikat" Knot?
Takeout   ::= "Bungkus" Plastic?

Drink     ::= Takeout? Upsize? Water Milk? Sugar? Thickness? Extra*
</span><span class="no">EOF</span>

<span class="k">class</span> <span class="nc">MalayTea</span>
  <span class="kp">include</span> <span class="no">EBNF</span><span class="o">::</span><span class="no">PEG</span><span class="o">::</span><span class="no">Parser</span>
  <span class="nb">attr_reader</span> <span class="ss">:rules</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="s2">"外带"</span>
    <span class="k">else</span>
      <span class="s2">"外带</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:Plastic</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">value</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="s2">"塑料袋装"</span>
    <span class="k">else</span>
      <span class="s2">"塑料袋装</span><span class="si">#{</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">values</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Plastic_1</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Mati</span><span class="p">:</span> <span class="s2">"打死结"</span><span class="p">,</span> <span class="no">Tepi</span><span class="p">:</span> <span class="s2">"侧面打结"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_2</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"大杯"</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:Water</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="p">{</span> <span class="no">Kopi</span><span class="p">:</span> <span class="s2">"咖啡"</span><span class="p">,</span> <span class="no">Teh</span><span class="p">:</span> <span class="s2">"红茶"</span><span class="p">,</span> <span class="no">Milo</span><span class="p">:</span> <span class="s2">"美禄"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_3</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">"炼乳"</span> <span class="p">:</span> <span class="p">{</span> <span class="no">O</span><span class="p">:</span> <span class="s2">""</span><span class="p">,</span> <span class="no">C</span><span class="p">:</span> <span class="s2">"鲜奶"</span> <span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_4</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Kosong</span><span class="p">:</span> <span class="s2">"无糖"</span><span class="p">,</span> <span class="s2">"Siu Dai"</span><span class="p">:</span> <span class="s2">"少糖"</span><span class="p">,</span> <span class="s2">"Gah Dai"</span><span class="p">:</span> <span class="s2">"加糖"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_5</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">value</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="p">{</span> <span class="no">Gau</span><span class="p">:</span> <span class="s2">"浓缩"</span><span class="p">,</span> <span class="no">Po</span><span class="p">:</span> <span class="s2">"清淡"</span><span class="p">}[</span><span class="n">value</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:_Drink_6</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">extras</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
      <span class="p">{</span> <span class="no">Peng</span><span class="p">:</span> <span class="s2">"冰块"</span><span class="p">,</span> <span class="no">Bubble</span><span class="p">:</span> <span class="s2">"珍珠"</span><span class="p">,</span> <span class="no">Halia</span><span class="p">:</span> <span class="s2">"姜汁"</span> <span class="p">}[</span><span class="n">a</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">]</span>
    <span class="k">end</span>
    <span class="n">extras</span><span class="p">.</span><span class="nf">empty?</span> <span class="p">?</span> <span class="s2">""</span> <span class="p">:</span> <span class="s2">"加</span><span class="si">#{</span><span class="n">extras</span><span class="p">.</span><span class="nf">join</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="n">production</span><span class="p">(</span><span class="ss">:Drink</span><span class="p">,</span> <span class="ss">clear_packrat: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:merge</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"红茶"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"奶茶"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">elsif</span> <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"咖啡"</span> <span class="ow">and</span> <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"鲜奶"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"咖啡拿铁"</span>
      <span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">end</span>
    <span class="s2">"</span><span class="si">#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_1</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_2</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_4</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_3</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_5</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:Water</span><span class="p">]</span><span class="si">}#{</span><span class="n">h</span><span class="p">[</span><span class="ss">:_Drink_6</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@rules</span> <span class="o">=</span> <span class="no">EBNF</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">TEA_GRAMMER</span><span class="p">).</span><span class="nf">make_peg</span><span class="p">.</span><span class="nf">ast</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="n">parse</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="ss">:Drink</span><span class="p">,</span> <span class="vi">@rules</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="kp">loop</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"输入饮料名："</span>
  <span class="nb">print</span> <span class="s2">"&gt; "</span>
  <span class="nb">puts</span>  <span class="s2">"&lt; </span><span class="si">#{</span><span class="no">MalayTea</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们来运行一下看看：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❯ ruby main.rb
输入饮料名：
&gt; Bungkus Ikat Mati Nga Lat Kopi O Siu Dai Gau Peng Bubble
&lt; 外带塑料袋装打死结大杯少糖浓缩咖啡加冰块珍珠
</code></pre></div></div>

<p>欢迎大家带着这个程序去马来西亚／新加坡饮茶。</p>]]></content><author><name>CodeRemixer</name></author><category term="编译" /><category term="Ruby" /><category term="语言学" /><summary type="html"><![CDATA[近几日马来西亚网友 Gurdip Singh 在 Facebook 发的这个「三点几嚟，饮茶先啦」非常流行。]]></summary></entry><entry><title type="html">用 Ruby 实现飞机自动驾驶仪</title><link href="https://coderemixer.com/2021/01/08/autopilot-with-ruby" rel="alternate" type="text/html" title="用 Ruby 实现飞机自动驾驶仪" /><published>2021-01-08T13:03:32+00:00</published><updated>2021-01-08T13:03:32+00:00</updated><id>https://coderemixer.com/2021/01/08/autopilot-with-ruby</id><content type="html" xml:base="https://coderemixer.com/2021/01/08/autopilot-with-ruby"><![CDATA[<p><code class="language-plaintext highlighter-rouge">krpc</code> 是一个砍巴拉太空计划（Kerbel Space Program）中的插件。可以通过 RPC 来控制游戏。同时有第三方的 Ruby 客户端：<a href="https://github.com/TeWu/krpc-rb">krpc-rb</a>。和真实飞机不同的是，在砍巴拉游戏中驾驶飞机是非常痛苦的，在没有插件辅助的情况下，你看不到具体的 GPS 坐标，很多时候看到的都是和飞机驾驶无关的轨道参数，而一些关键的控制参数缺很难获取。同时游戏中也没有自动驾驶仪。特别在航天飞机降落的控制非常难，虽然手动降落不会太有问题，游戏对于重着陆的容忍度很高，但是要控制飞机飞往机场的过程漫长而痛苦。于是我们试试看利用 <code class="language-plaintext highlighter-rouge">krpc</code> 来实现正常商用飞机都有的自动驾驶仪的功能。</p>

<h2 id="pid-控制">PID 控制</h2>

<p>PID 是自动化控制中最基础也是最常用的控制算法。</p>

<p>我们假设我们要控制汽车油门使得汽车的速度达到某个我们预想中的速度。最直接的想法就是基于距离目标速度的大小来调整油门。也就是说越接近目标速度，我们油门踩得越轻。</p>

<p>但这会产生一个问题，由于我们控制的是给油，油门到加速度控制存在一个延迟，使得我们放开油门后的几毫秒内可能速度还会上升；而当我们看到速度超过放开油门的量越来越大，随着车速越来越快，我们受到的空气阻力实际在增加，车速又会很快下降，而无法与加速度达到平衡，这种情况下我们就会在目标速度附近来回震荡。根据我们按比例控制的激进程度，振幅可能有所变化，最坏情况下我们会震动幅度越来越大，使得系统完全失控。</p>

<p>解决这个问题最直接的方法是引入一个积分项，不单单根据目前速度的误差，也要根据当前加速度的积分，也就是速度来判断。速度越大可能我们需要的油门也要更大一些。</p>

<p>最后我们实际控制还会遇到扰动的问题，我们可能还要根据过去一段时间内误差变化幅度来调节油门大小，比如遇到一个晃动速度快速下降，我们就要快速补一下油门来弥补这个误差。这意味着我们还要引入一个微分项。把这三个结合起来，我们可以得到公式：
\(u(t) = K_pe(t) + K_i\int_0^te(\tau)d\tau+K_d\frac{d}{dt}e(t)\)
形成一个通用的 P（比例）I（积分）D（微分）控制器。不过虽然说是通用，这每一项前面的系数比例要想调好也是不容易的。我们会用这个控制器来分别控制飞机的节流阀、滚转和俯仰。</p>

<p>用 Ruby 实现出来是这样的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PIDController</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">kp</span><span class="p">,</span> <span class="n">ki</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">clip_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">clip_max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="vi">@prev_err</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="vi">@integral</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="vi">@kp</span> <span class="o">=</span> <span class="n">kp</span>
    <span class="vi">@ki</span> <span class="o">=</span> <span class="n">ki</span>
    <span class="vi">@kd</span> <span class="o">=</span> <span class="n">kd</span>
    <span class="vi">@clip_min</span> <span class="o">=</span> <span class="n">clip_min</span>
    <span class="vi">@clip_max</span> <span class="o">=</span> <span class="n">clip_max</span>

    <span class="vi">@last_frame</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">trigger</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">measured</span><span class="p">)</span>
    <span class="n">trigger_err</span><span class="p">(</span><span class="n">goal</span> <span class="o">-</span> <span class="n">measured</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">trigger_err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="n">current_frame</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">current_frame</span> <span class="o">-</span> <span class="vi">@last_frame</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="mf">1.0</span>
      <span class="vi">@last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>
      <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">end</span>

    <span class="vi">@integral</span> <span class="o">=</span> <span class="vi">@integral</span> <span class="o">+</span> <span class="n">err</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="vi">@integral</span> <span class="o">=</span> <span class="vi">@clip_min</span> <span class="k">if</span> <span class="vi">@integral</span> <span class="o">&lt;</span> <span class="vi">@clip_min</span>
    <span class="vi">@integral</span> <span class="o">=</span> <span class="vi">@clip_max</span> <span class="k">if</span> <span class="vi">@integral</span> <span class="o">&gt;</span> <span class="vi">@clip_max</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">err</span> <span class="o">-</span> <span class="vi">@prev_err</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">res</span> <span class="o">=</span> <span class="vi">@kp</span> <span class="o">*</span> <span class="n">err</span> <span class="o">+</span> <span class="vi">@ki</span> <span class="o">*</span> <span class="vi">@integral</span> <span class="o">+</span> <span class="vi">@kd</span> <span class="o">*</span> <span class="n">d</span>
    <span class="vi">@prev_err</span> <span class="o">=</span> <span class="n">err</span>
    <span class="vi">@last_frame</span> <span class="o">=</span> <span class="n">current_frame</span>

    <span class="k">return</span> <span class="vi">@clip_min</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="vi">@clip_min</span>
    <span class="k">return</span> <span class="vi">@clip_max</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="vi">@clip_max</span>
    <span class="n">res</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>实际实现和公式有一些细微差异。积分项不能比可以控制的最大值更大，也不能比最小值更小。否则当误差和控制不在一个数量级的时候，往往会出现很难控制或者反应迟钝的问题。</p>

<h2 id="起飞控制">起飞控制</h2>

<p>起飞控制比较简单，在打开 SAS 保持稳定的情况下，我们只需要控制系统加速到抬轮速度，然后将飞机抬头到俯仰 10 度，收起起落架。最后爬升到给定的高度。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TakeoffProcess</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="n">vr</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
    <span class="vi">@vessel</span> <span class="o">=</span> <span class="n">vessel</span>
    <span class="vi">@control</span> <span class="o">=</span> <span class="n">vessel</span><span class="p">.</span><span class="nf">control</span>

    <span class="vi">@vr</span> <span class="o">=</span> <span class="n">vr</span>
    <span class="vi">@velocity</span> <span class="o">=</span> <span class="n">velocity</span>
    <span class="vi">@height</span> <span class="o">=</span> <span class="n">height</span>

    <span class="vi">@throttle_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
    <span class="vi">@pitch_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">brakes</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">sas</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">orbit</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">orbit</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">reference_frame</span><span class="p">)</span>
      <span class="n">surface</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">surface_reference_frame</span><span class="p">)</span>
      <span class="k">break</span> <span class="k">unless</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span> <span class="o">&lt;</span> <span class="vi">@vr</span>
      <span class="n">throttle</span> <span class="o">=</span> <span class="vi">@throttle_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@velocity</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">throttle</span> <span class="o">=</span> <span class="n">throttle</span>
    <span class="k">end</span>

    <span class="c1"># Rotate</span>
    <span class="nb">puts</span> <span class="s2">"Rotate, Gear Up!"</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">gear</span> <span class="o">=</span> <span class="kp">false</span>

    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">orbit</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">orbit</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">reference_frame</span><span class="p">)</span>
      <span class="n">surface</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">surface_reference_frame</span><span class="p">)</span>
      <span class="k">break</span> <span class="k">unless</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">mean_altitude</span> <span class="o">&lt;</span> <span class="vi">@height</span> <span class="o">-</span> <span class="mi">100</span>
      <span class="n">throttle</span> <span class="o">=</span> <span class="vi">@throttle_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@velocity</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">throttle</span> <span class="o">=</span> <span class="n">throttle</span>

      <span class="n">pitch</span> <span class="o">=</span> <span class="vi">@pitch_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="nf">pitch</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">=</span> <span class="n">pitch</span>
    <span class="k">end</span>

    <span class="nb">puts</span> <span class="s2">"Takeoff Process Finished."</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>比较麻烦的地方是 ksp 有一个 reference_frame 的概念，很多参数需要的是相对于 reference_frame 参数的概念。比如当你需要速度的时候，有可能获得轨道速度，也可能得到的是地面速度。再比如俯仰，如果是相对于轨道的俯仰，那么理论上始终应该是在 0 附近，因为轨道会随着俯仰变化而变化。所以计算的时候要小心。</p>

<h2 id="方向角计算">方向角计算</h2>

<p>起飞后一般飞机自动驾驶仪一个最重要的功能就是根据预先在飞行电脑上设定好的飞行路线来飞行了。路点一般有几个关键参数：高度、速度、经纬度。高度和速度的写法和我们起飞的时候差不多。但转向就比较复杂。</p>

<p>我们首先需要确定的是，飞机要转几度才能转到目标点，也就是计算方位角。我们先来考虑，如果这个地球是一个平面，经纬度是 x 和 y 轴上的坐标，方向角应当怎么算呢？其实我们可以很容易得到方向向量：
\((x, y) = (x_b-x_a, y_b-y_a)\)
那么方向角（自正北作为 0 度的顺时针角度）就是
\(tan(\theta)=\frac{x_b-x_a}{y_b-y_a}\)
\(\theta = atan(\frac{x_b-x_a}{y_b-y_a})\)
然而在球面上计算这个问题要复杂一些，本质上我们需要知道大圆上任意两点的距离，我们需要用到球面三角学中重要的<a href="https://zh.wikipedia.org/wiki/%E5%8D%8A%E6%AD%A3%E7%9F%A2%E5%85%AC%E5%BC%8F">半正矢公式（Harversine Formula）</a>。</p>

<p>根据半正矢定理，我们有：
\(hav(c) = hav(a-b)+sin(a)sin(b)hav(C)\)
其中：
\(hav(\theta)=sin^2\frac{\theta}{2}=\frac{1-cos\theta}{2}\)
<img src="/assets/images/harversine.png" alt="Harversine" /></p>

<p>进一步我们可以得到：
\(A = (lat_a, lng_a)\)
\(B = (lat_b, lng_b)\)
\(N = (\frac{\pi}{2}, 0)\)
\(hav(NB) = hav(AB-AN)+sin(AB)sin(AN)hav(\angle NAB)\)
再往下算基本就吐了，这公式长到打在 Wolfram Alpha 上直接不识别。只好上网找了个算好的结果：
\(tan(\theta)=\frac{|lng_b-lng_a|}{ln(\frac{tan(\frac{lat_B}{2}+\frac{\pi}{4})}{tan(\frac{lat_A}{2}+\frac{\pi}{4})})}\)
需要特别注意，当
\(lat_a = lat_b\)
的时候分母为 0，针对这类情况，大多数编程语言都有 <code class="language-plaintext highlighter-rouge">atan2(y, x)</code> 函数，当 <code class="language-plaintext highlighter-rouge">x = 0</code> 时返回 90 度。最后我们有程序：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delta_phi</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="vi">@latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="n">orbit</span><span class="p">.</span><span class="nf">latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">delta_lon</span> <span class="o">=</span>  <span class="p">(</span><span class="vi">@longitude</span> <span class="o">-</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">longitude</span><span class="p">)</span>  <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>
<span class="n">theta</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">atan2</span><span class="p">(</span><span class="n">delta_lon</span><span class="p">,</span> <span class="n">delta_phi</span><span class="p">)</span>
<span class="n">target_heading</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>
</code></pre></div></div>

<h2 id="偏航控制">偏航控制</h2>

<p>飞机上有两个可以控制飞机转向的方法，一个是偏航（Yaw），另一个是组合使用滚转（Roll）和俯仰（Pitch）。偏航通常是通过垂直尾翼来产生偏航力矩。而滚转和俯仰由副翼和水平尾翼得到。显然副翼和水平尾翼比垂直尾翼大很多，控制也会更快速、灵敏。事实上我们只需要控制滚转即可，因为当我们控制滚转，飞机的升力面会减少，从而导致升力下降、飞机下降；为了保持飞行高度，我们基于飞行高度控制的俯仰自然会提高俯仰，从而产生偏航方向的力矩。</p>

<p>不过需要注意两个关键点：</p>

<ol>
  <li>控制俯仰来控制升力的原理是，在一定范围内攻角（Angle of Attack）和升力系数成正比。然而当攻角大于某个角度，升力可能会迅速下降（即失速），如果要提高升力应当降低俯仰，而不是继续抬升俯仰。</li>
  <li>当滚转角度越来越大后，副翼的升力面会逐渐减小到无论如何提高节流阀大小或调整俯仰都无法维持的情况（即失速），应当将侧倾角度（bank angle）控制在合理范围内。</li>
</ol>

<p>在控制程序中我直接限制了俯仰的范围是 [-5.0, 10] 度，而滚转限制在正负 25 度以内。整体程序如下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WaypointProcess</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">)</span>
    <span class="vi">@vessel</span> <span class="o">=</span> <span class="n">vessel</span>
    <span class="vi">@control</span> <span class="o">=</span> <span class="n">vessel</span><span class="p">.</span><span class="nf">control</span>

    <span class="vi">@velocity</span> <span class="o">=</span> <span class="n">velocity</span>
    <span class="vi">@height</span> <span class="o">=</span> <span class="n">height</span>
    <span class="vi">@longitude</span> <span class="o">=</span> <span class="n">longitude</span>
    <span class="vi">@latitude</span> <span class="o">=</span> <span class="n">latitude</span>

    <span class="vi">@throttle_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
    <span class="vi">@pitch_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="vi">@roll_controller</span> <span class="o">=</span> <span class="no">PIDController</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mf">0.0005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@control</span><span class="p">.</span><span class="nf">sas</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">orbit</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">orbit</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">reference_frame</span><span class="p">)</span>
      <span class="n">surface</span> <span class="o">=</span> <span class="vi">@vessel</span><span class="p">.</span><span class="nf">flight</span><span class="p">(</span><span class="vi">@vessel</span><span class="p">.</span><span class="nf">surface_reference_frame</span><span class="p">)</span>
      <span class="k">break</span> <span class="k">if</span> <span class="p">(</span><span class="n">orbit</span><span class="p">.</span><span class="nf">latitude</span> <span class="o">-</span> <span class="vi">@latitude</span><span class="p">).</span><span class="nf">abs</span> <span class="o">&lt;</span> <span class="mf">1e-4</span> <span class="ow">and</span> <span class="p">(</span><span class="n">orbit</span><span class="p">.</span><span class="nf">longitude</span> <span class="o">-</span> <span class="vi">@longitude</span><span class="p">).</span><span class="nf">abs</span> <span class="o">&lt;</span> <span class="mf">1e-4</span>

      <span class="n">throttle</span> <span class="o">=</span> <span class="vi">@throttle_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@velocity</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">speed</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">throttle</span> <span class="o">=</span> <span class="n">throttle</span>

      <span class="n">pitch</span> <span class="o">=</span> <span class="vi">@pitch_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="vi">@height</span><span class="p">,</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">mean_altitude</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">pitch</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">surface</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">&gt;</span> <span class="mi">10</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span>
      <span class="k">elsif</span> <span class="n">pitch</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">surface</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span>
        <span class="n">pitch</span> <span class="o">=</span> <span class="mf">0.1</span>
      <span class="k">end</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">pitch</span> <span class="o">=</span> <span class="n">pitch</span>

      <span class="n">delta_phi</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="vi">@latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="no">Math</span><span class="p">.</span><span class="nf">tan</span><span class="p">((</span><span class="n">orbit</span><span class="p">.</span><span class="nf">latitude</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
      <span class="n">delta_lon</span> <span class="o">=</span>  <span class="p">(</span><span class="vi">@longitude</span> <span class="o">-</span> <span class="n">orbit</span><span class="p">.</span><span class="nf">longitude</span><span class="p">)</span>  <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>
      <span class="n">theta</span> <span class="o">=</span> <span class="no">Math</span><span class="p">.</span><span class="nf">atan2</span><span class="p">(</span><span class="n">delta_lon</span><span class="p">,</span> <span class="n">delta_phi</span><span class="p">)</span>
      <span class="n">target_heading</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span>

      <span class="n">target_heading</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">+</span> <span class="n">target_heading</span> <span class="k">if</span> <span class="n">target_heading</span> <span class="o">&lt;</span> <span class="mi">0</span>
      <span class="n">delta_heading</span> <span class="o">=</span> <span class="n">target_heading</span> <span class="o">-</span> <span class="n">surface</span><span class="p">.</span><span class="nf">heading</span>

      <span class="n">delta_heading</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">-</span> <span class="n">delta_heading</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&gt;</span> <span class="mi">180</span>
      <span class="n">delta_heading</span> <span class="o">=</span> <span class="n">delta_heading</span> <span class="o">+</span> <span class="mi">360</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span>

      <span class="n">bank_angle</span> <span class="o">=</span> <span class="n">delta_heading</span>
      <span class="n">bank_angle</span> <span class="o">=</span> <span class="mi">25</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&gt;</span> <span class="mi">25</span>
      <span class="n">bank_angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">25</span> <span class="k">if</span> <span class="n">delta_heading</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">25</span>

      <span class="n">roll</span> <span class="o">=</span> <span class="vi">@roll_controller</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span><span class="n">bank_angle</span><span class="p">,</span> <span class="n">surface</span><span class="p">.</span><span class="nf">roll</span><span class="p">)</span>
      <span class="vi">@control</span><span class="p">.</span><span class="nf">roll</span> <span class="o">=</span> <span class="n">roll</span>
      <span class="n">current_roll</span> <span class="o">=</span> <span class="n">surface</span><span class="p">.</span><span class="nf">roll</span>
    <span class="k">end</span>

    <span class="nb">puts</span> <span class="s2">"Waypoint lat: </span><span class="si">#{</span><span class="vi">@latitude</span><span class="si">}</span><span class="s2">, lng: </span><span class="si">#{</span><span class="vi">@longitude</span><span class="si">}</span><span class="s2"> Reached."</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<h2 id="测试">测试</h2>

<p>我们使用如下的飞行路径设定：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'matrix'</span>
<span class="nb">require</span> <span class="s1">'krpc'</span>

<span class="nb">require</span> <span class="s1">'./libs/controller/pid'</span>
<span class="nb">require</span> <span class="s1">'./libs/process/takeoff'</span>
<span class="nb">require</span> <span class="s1">'./libs/process/waypoint'</span>

<span class="no">KRPC</span><span class="p">.</span><span class="nf">connect</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="o">|</span>
  <span class="n">vessel</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">space_center</span><span class="p">.</span><span class="nf">active_vessel</span>

  <span class="c1"># VR: 100m/s, Climb at 390 knots to 2000m</span>
  <span class="no">TakeoffProcess</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">).</span><span class="nf">run</span>
  <span class="c1"># Fly to North pole (N90, S0.0) at 330 knots at FL300</span>
  <span class="no">WaypointProcess</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">vessel</span><span class="p">,</span> <span class="mi">170</span><span class="p">,</span> <span class="mi">7000</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">).</span><span class="nf">run</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 100m/s 时抬轮，以 390 节速度爬升到 2000 米，然后爬升到 30000 英尺转向飞往北极点。测试完美。</p>

<p><img src="/assets/images/ksp-ap-test.jpg" alt="KSP AP Test" /></p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Mlqzk6bTOxQ" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>完整代码：<a href="https://github.com/dsh0416/ksp-pilot">GitHub dsh0416/ksp-pilot</a></p>

<p>我用的是自带存档强翼 A300 进行的测试。该飞机被设计成大气层内飞行的重型运输机。由于 Kerbin 星球比起地球大气稀薄，到 FL300 飞机已经难以维持 300 节的时速了。不过如果使用空天飞机进行测试则没有这样的问题。</p>

<p>目前的 PID 曲线的调教比较保守，在高度控制上震荡比较厉害。这可以针对具体飞机进行调整，如果在安装 <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a> 的情况下，可以获得具体的「升力系数参数」，其实通过控制升力系数来控制高度是最为可靠的方法，现实中的飞机也是这么做的。</p>

<p>之后如果能获取机场 GPS 坐标实现自动进近和降落应该会更有意思。</p>

<p>不过这个项目还是很有意义的，不但练习了 Ruby 编程，还学习了立体几何、物理、飞行原理和自动化控制的相关知识。</p>]]></content><author><name>CodeRemixer</name></author><category term="KSP" /><category term="Ruby" /><category term="PID" /><summary type="html"><![CDATA[krpc 是一个砍巴拉太空计划（Kerbel Space Program）中的插件。可以通过 RPC 来控制游戏。同时有第三方的 Ruby 客户端：krpc-rb。和真实飞机不同的是，在砍巴拉游戏中驾驶飞机是非常痛苦的，在没有插件辅助的情况下，你看不到具体的 GPS 坐标，很多时候看到的都是和飞机驾驶无关的轨道参数，而一些关键的控制参数缺很难获取。同时游戏中也没有自动驾驶仪。特别在航天飞机降落的控制非常难，虽然手动降落不会太有问题，游戏对于重着陆的容忍度很高，但是要控制飞机飞往机场的过程漫长而痛苦。于是我们试试看利用 krpc 来实现正常商用飞机都有的自动驾驶仪的功能。]]></summary></entry><entry><title type="html">Developing Fiber Scheduler for Ruby 3</title><link href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en" rel="alternate" type="text/html" title="Developing Fiber Scheduler for Ruby 3" /><published>2020-12-22T17:41:41+00:00</published><updated>2020-12-22T17:41:41+00:00</updated><id>https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en</id><content type="html" xml:base="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en"><![CDATA[<p><a href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log/">中文版本</a></p>

<h2 id="ruby-3-fiber-scheduler">Ruby 3 Fiber Scheduler</h2>

<p>I wrote an article in July 2020, <a href="https://coderemixer.com/2020/07/26/whats-new-in-ruby-3-fiber/"><em>Ruby 3 Fiber changes preview (in Chinese)</em></a>,
and followed up by another post in August <a href="https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler/"><em>A Walkthrough of Ruby 3 Scheduler</em></a>.
Ruby 3 has updated lots of versions during these months, including <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview1</code> <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview2</code> and <code class="language-plaintext highlighter-rouge">ruby-3.0.0-rc1</code>,
which makes lots of improvements to the Fiber Scheduler API.</p>

<p>But as I mentioned before, what Ruby 3 implements is the interface.
It would not use the scheduler, unless a scheduler implementation is included.</p>

<p>I am very busy working and studying in the past four months,
and I took some time in the recent days to get updated with the API.</p>

<p>GitHub: <a href="https://github.com/dsh0416/evt">Evt</a></p>

<h2 id="use-of-fiber-scheduler">Use of Fiber Scheduler</h2>

<p>Suppose we have a pair of fds generated by <code class="language-plaintext highlighter-rouge">IO.pipe</code>. When we write <code class="language-plaintext highlighter-rouge">Hello World</code> to one of them, we could read it from the other side of the pipe.
We would have code like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>

<span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">message</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div></div>

<p>This program has lots of limitations. For example, you can’t write a string longer than the buffer size.
Since the other side is not reading at the same time, it would get stuck if the string is too long.
You would also have to write first, otherwise it would also get stuck.
Of course, we could use multi-threading to solve this problem.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'thread'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t1</span><span class="p">.</span><span class="nf">join</span>
<span class="n">t2</span><span class="p">.</span><span class="nf">join</span>
</code></pre></div></div>

<p>But as we all know, using threads to solve I/O problems is very inefficient.
The OS context switch is slow. The fairness of thread scheduling is still a very hard problem in the field of OS.
For an I/O problem, which is not CPU-bound, all we need is to halt it and wait for the proper callback.
In this case, all you need is to call Ruby 3 scheduler.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="n">scheduler</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>In general, an async function requires keywords like <code class="language-plaintext highlighter-rouge">callback</code>, <code class="language-plaintext highlighter-rouge">async</code>, or <code class="language-plaintext highlighter-rouge">await</code>.
But this is not necessary in Ruby 3.
Ruby 3 lists all common situations where you need async functions: I/O multiplexing, process halting, kernel sleep, and mutex.
Ruby 3 exposes all of these interfaces for scheduler to improve the performance without adding any new keywords.
My project <a href="https://github.com/dsh0416/evt">evt</a> is such a scheduler to meet the needs of Ruby 3 Scheduler.</p>

<p>Comparing to the simple example above, here is an example of HTTP/1.1 server</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="vi">@scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>
<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="vi">@scheduler</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_INET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">bind</span> <span class="no">Addrinfo</span><span class="p">.</span><span class="nf">tcp</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">3002</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">listen</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOMAXCONN</span>

<span class="k">def</span> <span class="nf">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">until</span> <span class="n">socket</span><span class="p">.</span><span class="nf">closed?</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">until</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span> <span class="o">||</span> <span class="n">line</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">end</span>
    <span class="n">socket</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s2">Content-Length: 0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">socket</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">accept</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
      <span class="n">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vi">@scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>We could see from this that, the code is almost the same with synchronous development.
All you need to do is to setup the scheduler with <code class="language-plaintext highlighter-rouge">Fiber.set_scheduler</code>,
and add <code class="language-plaintext highlighter-rouge">Fiber.scheduler</code> where you usually have to solve with multithreading.
Finally, use <code class="language-plaintext highlighter-rouge">scheduler.run</code> to start the scheduler.</p>

<h2 id="backend-support">Backend support</h2>

<h3 id="io_uring-support"><code class="language-plaintext highlighter-rouge">io_uring</code> Support</h3>

<p>Not only the Ruby API gets lots of updates in the recent months, but also my scheduler. Especially for a better I/O multiplexing backend support.
<code class="language-plaintext highlighter-rouge">io_uring</code> is included since Linux 5.4.
Since the <code class="language-plaintext highlighter-rouge">io_uring</code> could reduce the syscalls and could have direct <code class="language-plaintext highlighter-rouge">iov</code> calls to acheive better performance comparing to <code class="language-plaintext highlighter-rouge">epoll</code>,
the support of <code class="language-plaintext highlighter-rouge">io_uring</code> is important.
Direct <code class="language-plaintext highlighter-rouge">iov</code> support requires Ruby Fiber scheduler for some further changes.
These changes are introduced by ioquatix since Ruby 3.0.0-preview2.
What we need to implement is two parts.
One of them is <code class="language-plaintext highlighter-rouge">epoll</code> compatible API:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;liburing.h&gt;</span><span class="cp">
</span>
<span class="cp">#define URING_ENTRIES 64
#define URING_MAX_EVENTS 64
</span>
<span class="k">struct</span> <span class="n">uring_data</span> <span class="p">{</span>
  <span class="n">bool</span> <span class="n">is_poll</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">poll_mask</span><span class="p">;</span>
  <span class="n">VALUE</span> <span class="n">io</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">rb_data_type_t</span> <span class="n">type_uring_payload</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">wrap_struct_name</span> <span class="o">=</span> <span class="s">"uring_payload"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">dmark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dfree</span> <span class="o">=</span> <span class="n">uring_payload_free</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">uring_payload_size</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">RUBY_TYPED_FREE_IMMEDIATELY</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">io_uring_queue_exit</span><span class="p">((</span><span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">xfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">));</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">io_uring_queue_init</span><span class="p">(</span><span class="n">URING_ENTRIES</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eIOError</span><span class="p">,</span> <span class="s">"unable to initalize io_uring"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>

    <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_IN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_OUT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="n">poll_mask</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_poll_add</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">poll_mask</span><span class="p">);</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// io_uring runs under oneshot mode. No need to deregister.</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The other part is direct iov support:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_io_read</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">read_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">read_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_readv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_str_new</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_str_append</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_io_write</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">write_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">write_buffer</span> <span class="o">=</span> <span class="n">StringValueCStr</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">write_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_writev</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But in some cases, the iov would not be called. I’m still figuring out the bug. But at least the performance is very close to <code class="language-plaintext highlighter-rouge">epoll</code>.</p>

<h3 id="iocp-support">IOCP Support</h3>

<p>Another problem is to support Windows IOCP. I tried to implement somethine like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcallv</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">HANDLE</span> <span class="n">io_handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">rb_w32_get_osfhandle</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">interest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">readable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">writable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">HANDLE</span> <span class="n">res</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">io_handler</span><span class="p">,</span> <span class="n">iocp</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_push</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"push"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">OVERLAPPED_ENTRY</span> <span class="n">lpCompletionPortEntries</span><span class="p">[</span><span class="n">IOCP_MAX_EVENTS</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">ulNumEntriesRemoved</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>

    <span class="n">DWORD</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_timeout</span> <span class="o">==</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mh">0x5000</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">next_timeout</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// seconds to milliseconds</span>
    <span class="p">}</span>

    <span class="n">DWORD</span> <span class="n">NumberOfBytesTransferred</span><span class="p">;</span>
    <span class="n">LPOVERLAPPED</span> <span class="n">pOverlapped</span><span class="p">;</span>
    <span class="n">ULONG_PTR</span> <span class="n">CompletionKey</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">res</span> <span class="o">=</span> <span class="n">GetQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NumberOfBytesTransferred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CompletionKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pOverlapped</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="c1">// BOOL res = GetQueuedCompletionStatusEx(</span>
    <span class="c1">//    iocp, lpCompletionPortEntries, IOCP_MAX_EVENTS, &amp;ulNumEntriesRemoved, timeout, TRUE);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_ary_new2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">readables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>
    <span class="n">VALUE</span> <span class="n">writables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>

    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readables</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">writables</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"--------- Received! ---------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Received IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">CompletionKey</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"dwNumberOfBytesTransferred: %lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfBytesTransferred</span><span class="p">);</span>

    <span class="c1">// if (ulNumEntriesRemoved &gt; 0) {</span>
    <span class="c1">//     printf("Entries: %ld\n", ulNumEntriesRemoved);</span>
    <span class="c1">// }</span>

    <span class="c1">// for (ULONG i = 0; i &lt; ulNumEntriesRemoved; i++) {</span>
    <span class="c1">//     OVERLAPPED_ENTRY entry = lpCompletionPortEntries[i];</span>
        
    <span class="c1">//     struct iocp_data *data = (struct iocp_data*) entry.lpCompletionKey;</span>

    <span class="c1">//     int interest = data-&gt;interest;</span>
    <span class="c1">//     VALUE obj_io = data-&gt;io;</span>
    <span class="c1">//     if (interest &amp; readable) {</span>
    <span class="c1">//         rb_funcall(readables, id_push, 1, obj_io);</span>
    <span class="c1">//     } else if (interest &amp; writable) {</span>
    <span class="c1">//         rb_funcall(writables, id_push, 1, obj_io);</span>
    <span class="c1">//     }</span>

    <span class="c1">//     xfree(data);</span>
    <span class="c1">// }</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But the I/O scheduler receives the wrong pointers when callback. After some researches, to support IOCP, you have to initialize the I/O with <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> flag.
This may need some changes in Ruby <code class="language-plaintext highlighter-rouge">win32/win32.c</code> to support IOCP.
But at least I solved the problems of the <code class="language-plaintext highlighter-rouge">IO.select</code> fallback.
The problem is fine, since nobody cares about Windows production performance…</p>

<h3 id="kqueue-improvements"><code class="language-plaintext highlighter-rouge">kqueue</code> Improvements</h3>

<p>Another Improvement is to macOS <code class="language-plaintext highlighter-rouge">kqueue</code>.
<code class="language-plaintext highlighter-rouge">kqueue</code> on FreeBSD is good. Bug the performance on macOS is really weird.
Since all of our I/O registration is in one-shot, I used one-shot mode of <code class="language-plaintext highlighter-rouge">kqueue</code> to reduce the number of syscalls.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">kevent</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u_short</span> <span class="n">event_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_READ</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_WRITE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">EV_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">EV_ADD</span><span class="o">|</span><span class="n">EV_ENABLE</span><span class="o">|</span><span class="n">EV_ONESHOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">io</span><span class="p">);</span>
    <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// TODO: Check the return value</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="overall">Overall</h3>

<p>At last, we support almost all I/O multiplexing backends of mostly used OS:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Linux</th>
      <th>Windows</th>
      <th>macOS</th>
      <th>FreeBSD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>io_uring</td>
      <td>✅  (See 1)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>epoll</td>
      <td>✅  (See 2)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>kqueue</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅ (⚠️See 5)</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>IOCP</td>
      <td>❌</td>
      <td>❌ (⚠️See 3)</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Ruby (<code class="language-plaintext highlighter-rouge">IO.select</code>)</td>
      <td>✅ Fallback</td>
      <td>✅ (⚠️See 4)</td>
      <td>✅ Fallback</td>
      <td>✅ Fallback</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>when liburing is installed</li>
  <li>when kernel version &gt;= 2.6.8</li>
  <li>WOULD NOT WORK until <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> is included in I/O initialization process.</li>
  <li>Some I/Os are not able to be nonblock under Windows. See <a href="https://docs.ruby-lang.org/en/master/doc/scheduler_md.html#label-IO">Scheduler Docs</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">kqueue</code> performance in Darwin is very poor. <strong>MAY BE DISABLED IN THE FUTURE.</strong></li>
</ol>

<h2 id="benchmark">Benchmark</h2>

<p>How is the overall performance?</p>

<p>The benchmark is running under <code class="language-plaintext highlighter-rouge">v0.2.2</code> version and Ruby 3.0.0-rc1.
See <a href="https://github.com/dsh0416/evt-server-benchmark">evt-server-benchmark</a> for test code, the test is running under a single-thread server.</p>

<p>The test command is <code class="language-plaintext highlighter-rouge">wrk -t4 -c8192 -d30s http://localhost:3001</code>.</p>

<p>All of the systems have set their file descriptor limit to maximum.</p>

<table>
  <thead>
    <tr>
      <th>OS</th>
      <th>CPU</th>
      <th>Memory</th>
      <th>Backend</th>
      <th>req/s</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>epoll</td>
      <td>54680.08</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>io_uring</td>
      <td>50245.53</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>IO.select (using poll)</td>
      <td>44159.23</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>kqueue</td>
      <td>37855.53</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>IO.select (using poll)</td>
      <td>28293.36</td>
    </tr>
  </tbody>
</table>

<p>Very impressive. The results improvements are from lots of aspects.
Current async frameworks like Falcon uses <a href="https://github.com/socketry/nio4r">nio4r</a>.
The backend of <a href="https://github.com/socketry/nio4r">nio4r</a> is libev.
The performance of libev is average due to the extreme compatibility design.
Existing async frameworks also requires lots of meta-programming.
But this extension is almost written in C, with only the features the scheduler need.</p>

<p>Comparing to my previous tests on preview 1, this version uses long connection, and Ruby nonblock I/O also has fixed a lot.
The <code class="language-plaintext highlighter-rouge">wrk</code> results are very error-sensitive. All of these things makes our performance 10 times faster comparing to what we have done 3 months ago.</p>

<p><strong>wrk is very error-sensitive, the parser in the benchmark is incorrect, which could not close the socket properly. I updated my <a href="https://github.com/midori-rb/midori.rb">Midori</a> to a Ruby 3 Scheduler project, the performance could reach 247k req/s with kqueue and 647k req/s with epoll, which is more than 100x times faster comparing to blocking I/O.</strong></p>

<h2 id="combining-with-ractor">Combining with Ractor</h2>

<p>I also wrote a post on November about Ractor  <a href="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide/"><em>Ruby 3 Ractor Dev Guide (in Chinese)</em></a>
Combining Fiber with Ractor is always a interesting thing. We have two routes for that:</p>

<ol>
  <li>Receive accpets in the main Ractor, and dispatch the request to sub-Ractors. After transferring the results back, return it from the main Ractor with scheduler.</li>
  <li>Use Linux <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code> feature to let all Ractor listen to the port at the same time, which is very easy to deal with with exisiting server archs.</li>
</ol>

<p>Unfortunately, either of these are functioning correctly now. Some Fiber features are not available in Ractor.
I suppose this is a bug, and have submitted a patch <a href="https://github.com/ruby/ruby/pull/3971">GitHub #3971</a>.
According to my previous benchmarks, Ractor my increase about 4 times the performance by multi-core.</p>

<p>But since API servers are usually stateless, these improvements could be acheived by multi-processes.
Ractor’s majot contribution may be fewer memory consumption.</p>

<p>I would test it with Ruby 3.0 future updates.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We acheived a 10 times performance improvement comparing to preview 1, and almost 36 times faster comparing to blocking I/O. The major performance issue of Ruby servers are I/O blocking instead of VM performance.
With the I/O scheduler is included, we could improve the I/O performance of Ruby 3 into a new era.
The future work is to wait for the updates of some C extension libraries like database connections.
Then if we use an async scheduler with a Fiber based Web server like  <a href="https://github.com/socketry/falcon">Falcon</a>,
you don’t have to do anything about your business code to get dozens of times of performance improvements.</p>

<p>Let’s continue happy programming with Ruby.</p>]]></content><author><name>CodeRemixer</name></author><category term="编程" /><category term="Ruby" /><summary type="html"><![CDATA[中文版本]]></summary></entry><entry><title type="html">为 Ruby 3 Fiber 调度器设计事件库 Evt</title><link href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log" rel="alternate" type="text/html" title="为 Ruby 3 Fiber 调度器设计事件库 Evt" /><published>2020-12-22T17:41:41+00:00</published><updated>2020-12-22T17:41:41+00:00</updated><id>https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log</id><content type="html" xml:base="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log"><![CDATA[<p><a href="https://coderemixer.com/2020/12/22/ruby-3-fiber-scheduler-evt-dev-log-en/">For English Readers</a></p>

<h2 id="ruby-3-fiber-调度器">Ruby 3 Fiber 调度器</h2>

<p>我在 2020 年 7 月写过一篇文章 <a href="https://coderemixer.com/2020/07/26/whats-new-in-ruby-3-fiber/">《Ruby 3 Fiber 变化前瞻》</a>，以及后来 8 月又写过一篇文章 <a href="https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler-cn/">《尝试使用 Ruby 3 调度器》</a>，简单介绍了 Fiber 调度器。Ruby 3 在这几个月中更新了数个版本，包括 <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview1</code> <code class="language-plaintext highlighter-rouge">ruby-3.0.0-preview2</code> 和 <code class="language-plaintext highlighter-rouge">ruby-3.0.0-rc1</code>，其对于 Fiber 调度器的 API 做了更多的改进。</p>

<p>不过正如我之前所说，Ruby 3 调度器实现的只有接口，如果没有配套的接口实现，默认是不会启动的。最近四个月工作实在很忙，抽出了点时间来跟上 API 更新的脚步。这个项目得以进一步更新。</p>

<p>项目地址：<a href="https://github.com/dsh0416/evt">Evt</a></p>

<h2 id="fiber-调度器的使用">Fiber 调度器的使用</h2>

<p>我们假设我们现在有一对 <code class="language-plaintext highlighter-rouge">IO.pipe</code>，我们往一个里写入 <code class="language-plaintext highlighter-rouge">Hello World</code>，然后从另一个里读出来。我们可能会写这样一份代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
<span class="n">wr</span><span class="p">.</span><span class="nf">close</span>

<span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">message</span>
<span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div></div>

<p>不过这个程序有很多限制，比如写入不能超过 <code class="language-plaintext highlighter-rouge">buffer</code>，否则另一端由于没有异步读取，会卡死。以及必须要先写再读，否则也会卡死。当然我们可以使用多线程来解决这个问题：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'thread'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="n">t1</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t2</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">t1</span><span class="p">.</span><span class="nf">join</span>
<span class="n">t2</span><span class="p">.</span><span class="nf">join</span>
</code></pre></div></div>

<p>但我们知道，使用线程来实现 I/O 的多路复用是效率极低的。操作系统的线程切换代价非常大，甚至对于线程之间调度的公平性，至今都是操作系统研究领域的噩梦。然而对于一个 I/O 问题，并不是 CPU-bound 的，只是需要调度器提供合适的睡眠和回调。这时，你只需要调用 Ruby 3 的调度器接口来替代线程就可以了。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="n">scheduler</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">message</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="n">message</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="n">scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>一般来说异步代码需要写 <code class="language-plaintext highlighter-rouge">callback</code> 或者引入 <code class="language-plaintext highlighter-rouge">async</code> <code class="language-plaintext highlighter-rouge">await</code> 的关键字。但是在 Ruby 3 中这是不必要的。Ruby 3 列举了所有常见的需要进行上下文切换调度的场景：I/O 多路复用、等待进程退出、内核睡眠、自旋锁。把这些接口暴露出来，让开发者可以通过自行开发调度器来进行处理，从而无需引入任何额外的关键字。而我这几个月写的 <a href="https://github.com/dsh0416/evt">Evt</a> 就是这样一个调度器。</p>

<p>比起上面这个简单的例子，下面这个例子是一个 HTTP/1.1 的服务器</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="vi">@scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>
<span class="no">Fiber</span><span class="p">.</span><span class="nf">set_scheduler</span> <span class="vi">@scheduler</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_INET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">bind</span> <span class="no">Addrinfo</span><span class="p">.</span><span class="nf">tcp</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">3002</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">listen</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOMAXCONN</span>

<span class="k">def</span> <span class="nf">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">until</span> <span class="n">socket</span><span class="p">.</span><span class="nf">closed?</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">until</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span> <span class="o">||</span> <span class="n">line</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
    <span class="k">end</span>
    <span class="n">socket</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s2">Content-Length: 0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">socket</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">accept</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">schedule</span> <span class="k">do</span>
      <span class="n">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="vi">@scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>可以看出来，开发的过程基本上和同步阻塞的线程开发没有任何区别，只需要 <code class="language-plaintext highlighter-rouge">Fiber.set_scheduler</code> 来设置你的调度器，然后在每个原先需要多线程来处理的 I/O 阻塞场景用 <code class="language-plaintext highlighter-rouge">Fiber.scheduler</code> 来替代。最后触发 <code class="language-plaintext highlighter-rouge">scheduler.run</code> 来启动调度器即可。</p>

<h2 id="后端支持情况">后端支持情况</h2>

<h3 id="io_uring-支持"><code class="language-plaintext highlighter-rouge">io_uring</code> 支持</h3>

<p>这几个月不止 Ruby API 进行了很多优化，我的调度器也做了很多优化，比如做了许多 I/O 多路复用后端的优化。一个是 Linux 5.4 开始引入的 <code class="language-plaintext highlighter-rouge">io_uring</code> 多路复用的支持。由于 <code class="language-plaintext highlighter-rouge">io_uring</code> 可以减少 <code class="language-plaintext highlighter-rouge">syscall</code> 调用次数以及直接的 <code class="language-plaintext highlighter-rouge">iov</code> 调用理论上能比 <code class="language-plaintext highlighter-rouge">epoll</code> 达到更好的性能。直接的 <code class="language-plaintext highlighter-rouge">iov</code> 调用需要 Ruby Fiber 调度器接口上的额外支持。在和 ioquatix 讨论后，Ruby 3.0.0-preview2 开始引入了相关的接口。于是整个 <code class="language-plaintext highlighter-rouge">io_uring</code> 的实现需要两个部分，一个是和 <code class="language-plaintext highlighter-rouge">epoll</code> 模式兼容的 one-shot polling 相关的代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;liburing.h&gt;</span><span class="cp">
</span>
<span class="cp">#define URING_ENTRIES 64
#define URING_MAX_EVENTS 64
</span>
<span class="k">struct</span> <span class="n">uring_data</span> <span class="p">{</span>
  <span class="n">bool</span> <span class="n">is_poll</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">poll_mask</span><span class="p">;</span>
  <span class="n">VALUE</span> <span class="n">io</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">rb_data_type_t</span> <span class="n">type_uring_payload</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">wrap_struct_name</span> <span class="o">=</span> <span class="s">"uring_payload"</span><span class="p">,</span>
  <span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">dmark</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dfree</span> <span class="o">=</span> <span class="n">uring_payload_free</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">uring_payload_size</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
  <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">RUBY_TYPED_FREE_IMMEDIATELY</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">uring_payload_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">io_uring_queue_exit</span><span class="p">((</span><span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">xfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">uring_payload_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span><span class="p">));</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">io_uring_queue_init</span><span class="p">(</span><span class="n">URING_ENTRIES</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eIOError</span><span class="p">,</span> <span class="s">"unable to initalize io_uring"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>

    <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_IN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">poll_mask</span> <span class="o">|=</span> <span class="n">POLL_OUT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="n">poll_mask</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_poll_add</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">poll_mask</span><span class="p">);</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// io_uring runs under oneshot mode. No need to deregister.</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一部分则是直接的 iov 支持：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_io_read</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">read_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">read_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">read_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_readv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_str_new</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rb_str_append</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_io_write</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">offset</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">io_uring</span><span class="o">*</span> <span class="n">ring</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">uring_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">write_buffer</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="c1">// @iov[io] = Fiber.current</span>
    <span class="n">VALUE</span> <span class="n">iovs</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iovs"</span><span class="p">);</span>
    <span class="n">rb_hash_aset</span><span class="p">(</span><span class="n">iovs</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"current"</span><span class="p">),</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">// register</span>
    <span class="n">VALUE</span> <span class="n">ring_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@ring"</span><span class="p">);</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">ring_obj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_uring_payload</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="n">write_buffer</span> <span class="o">=</span> <span class="n">StringValueCStr</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">write_buffer</span><span class="p">,</span>
        <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uring_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">poll_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">io_uring_prep_writev</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NUM2SIZET</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
    <span class="n">io_uring_sqe_set_data</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
    <span class="n">rb_funcall</span><span class="p">(</span><span class="n">Fiber</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"yield"</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Fiber.yield</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不过目前不知道为什么 <code class="language-plaintext highlighter-rouge">iov</code> 调用没有被 Ruby Scheduler 识别到，目前还在修复相关的问题。不过好消息是至少达到了接近 <code class="language-plaintext highlighter-rouge">epoll</code> 的性能了。</p>

<h3 id="iocp-支持">IOCP 支持</h3>

<p>另一个麻烦的地方是 Windows IOCP 支持。我试图写了一个 IOCP 的调度器：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">,</span> <span class="n">TypedData_Wrap_Struct</span><span class="p">(</span><span class="n">Payload</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcallv</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">HANDLE</span> <span class="n">io_handler</span> <span class="o">=</span> <span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="n">rb_w32_get_osfhandle</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iocp_data</span><span class="p">));</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">io</span> <span class="o">=</span> <span class="n">io</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">is_poll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">interest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">readable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interest</span> <span class="o">|=</span> <span class="n">writable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">HANDLE</span> <span class="n">res</span> <span class="o">=</span> <span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">io_handler</span><span class="p">,</span> <span class="n">iocp</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_push</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"push"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">iocp_obj</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@iocp"</span><span class="p">);</span>
    <span class="n">VALUE</span> <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>

    <span class="n">HANDLE</span> <span class="n">iocp</span><span class="p">;</span>
    <span class="n">OVERLAPPED_ENTRY</span> <span class="n">lpCompletionPortEntries</span><span class="p">[</span><span class="n">IOCP_MAX_EVENTS</span><span class="p">];</span>
    <span class="n">ULONG</span> <span class="n">ulNumEntriesRemoved</span><span class="p">;</span>
    <span class="n">TypedData_Get_Struct</span><span class="p">(</span><span class="n">iocp_obj</span><span class="p">,</span> <span class="n">HANDLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_iocp_payload</span><span class="p">,</span> <span class="n">iocp</span><span class="p">);</span>

    <span class="n">DWORD</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_timeout</span> <span class="o">==</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mh">0x5000</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">next_timeout</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// seconds to milliseconds</span>
    <span class="p">}</span>

    <span class="n">DWORD</span> <span class="n">NumberOfBytesTransferred</span><span class="p">;</span>
    <span class="n">LPOVERLAPPED</span> <span class="n">pOverlapped</span><span class="p">;</span>
    <span class="n">ULONG_PTR</span> <span class="n">CompletionKey</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">res</span> <span class="o">=</span> <span class="n">GetQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NumberOfBytesTransferred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CompletionKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pOverlapped</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="c1">// BOOL res = GetQueuedCompletionStatusEx(</span>
    <span class="c1">//    iocp, lpCompletionPortEntries, IOCP_MAX_EVENTS, &amp;ulNumEntriesRemoved, timeout, TRUE);</span>

    <span class="n">VALUE</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rb_ary_new2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">readables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>
    <span class="n">VALUE</span> <span class="n">writables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>

    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readables</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">writables</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"--------- Received! ---------</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Received IO at address: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">CompletionKey</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"dwNumberOfBytesTransferred: %lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">NumberOfBytesTransferred</span><span class="p">);</span>

    <span class="c1">// if (ulNumEntriesRemoved &gt; 0) {</span>
    <span class="c1">//     printf("Entries: %ld\n", ulNumEntriesRemoved);</span>
    <span class="c1">// }</span>

    <span class="c1">// for (ULONG i = 0; i &lt; ulNumEntriesRemoved; i++) {</span>
    <span class="c1">//     OVERLAPPED_ENTRY entry = lpCompletionPortEntries[i];</span>
        
    <span class="c1">//     struct iocp_data *data = (struct iocp_data*) entry.lpCompletionKey;</span>

    <span class="c1">//     int interest = data-&gt;interest;</span>
    <span class="c1">//     VALUE obj_io = data-&gt;io;</span>
    <span class="c1">//     if (interest &amp; readable) {</span>
    <span class="c1">//         rb_funcall(readables, id_push, 1, obj_io);</span>
    <span class="c1">//     } else if (interest &amp; writable) {</span>
    <span class="c1">//         rb_funcall(writables, id_push, 1, obj_io);</span>
    <span class="c1">//     }</span>

    <span class="c1">//     xfree(data);</span>
    <span class="c1">// }</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但实际发现收到的 I/O 全部都是错误的指针。一番研究后发现，如果要让 IOCP 调度对应的 I/O，该 I/O 在初始化时就要有  <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> Flag 的支持。这意味着还需要 Ruby 的 <code class="language-plaintext highlighter-rouge">win32/win32.c</code> 中做出一些改进，才能在调度器中正确调度 IOCP。不过 Windows 上的 fallback <code class="language-plaintext highlighter-rouge">IO.select</code> 调度器还是能正常使用的，这问题就不大，毕竟谁在乎 Windows 的生产性能呢…</p>

<h3 id="kqueue-支持改进"><code class="language-plaintext highlighter-rouge">kqueue</code> 支持改进</h3>

<p>另一个做出的改进是在 macOS 的 <code class="language-plaintext highlighter-rouge">kqueue</code> 上。<code class="language-plaintext highlighter-rouge">kqueue</code> 在 FreeBSD 上的性能相当好，但是在 macOS 上就比较拉跨。只能通过减少 <code class="language-plaintext highlighter-rouge">syscall</code> 来提高性能。这几个月的一个改进是使用了 <code class="language-plaintext highlighter-rouge">kqueue</code> 的 one-shot 模式，来减少一次 deregister 需要的 <code class="language-plaintext highlighter-rouge">syscall</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">kevent</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u_short</span> <span class="n">event_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WRITABLE"</span><span class="p">)));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_READ</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_WRITE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">EV_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">EV_ADD</span><span class="o">|</span><span class="n">EV_ENABLE</span><span class="o">|</span><span class="n">EV_ONESHOT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">io</span><span class="p">);</span>
    <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// TODO: Check the return value</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="概览">概览</h3>

<p>最后我们把主流的操作系统 I/O 多路复用都写了一遍集成到了我们的事件处理库中，整体情况如下：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Linux</th>
      <th>Windows</th>
      <th>macOS</th>
      <th>FreeBSD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>io_uring</td>
      <td>✅  (见 1)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>epoll</td>
      <td>✅  (见 2)</td>
      <td>❌</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>kqueue</td>
      <td>❌</td>
      <td>❌</td>
      <td>✅ (⚠️见 5)</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>IOCP</td>
      <td>❌</td>
      <td>❌ (⚠️见 3)</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>Ruby (<code class="language-plaintext highlighter-rouge">IO.select</code>)</td>
      <td>✅ Fallback</td>
      <td>✅ (⚠️见 4)</td>
      <td>✅ Fallback</td>
      <td>✅ Fallback</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>当编译时检测到 <code class="language-plaintext highlighter-rouge">liburing-dev</code> 已被安装</li>
  <li>当 Linux 内核版本 &gt;= 2.6.8</li>
  <li>在 I/O 初始化过程中 <code class="language-plaintext highlighter-rouge">FILE_FLAG_OVERLAPPED</code> flag 被引入前 <strong>无法工作</strong>。</li>
  <li>一些 I/O 在 Windows 下无法变成非阻塞 I/O，详见 <a href="https://docs.ruby-lang.org/en/master/doc/scheduler_md.html#label-IO">调度器文档</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">kqueue</code> 在 Darwin 下的一些特殊情况性能很烂，<strong>可能会在未来被禁用。</strong></li>
</ol>

<h2 id="基准测试">基准测试</h2>

<p>那么总体性能如何呢？</p>

<p>下面的测试是在 evt <code class="language-plaintext highlighter-rouge">v0.2.2</code> 和 Ruby 3.0.0-rc1 上运行的，详细的测试代码见 <a href="https://github.com/dsh0416/evt-server-benchmark">evt-server-benchmark</a>。测试仅使用单线程服务器。</p>

<p>测试命令是 <code class="language-plaintext highlighter-rouge">wrk -t4 -c8192 -d30s http://localhost:3001</code>.</p>

<table>
  <thead>
    <tr>
      <th>操作系统</th>
      <th>CPU</th>
      <th>内存</th>
      <th>后端</th>
      <th>请求/秒</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>epoll</td>
      <td>54680.08</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>io_uring</td>
      <td>50245.53</td>
    </tr>
    <tr>
      <td>Linux</td>
      <td>Ryzen 2700x</td>
      <td>64GB</td>
      <td>Ruby (使用 poll)</td>
      <td>44159.23</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>kqueue</td>
      <td>37855.53</td>
    </tr>
    <tr>
      <td>macOS</td>
      <td>i7-6820HQ</td>
      <td>16GB</td>
      <td>Ruby (使用 poll)</td>
      <td>28293.36</td>
    </tr>
  </tbody>
</table>

<p>相当惊人。这个结果有几方面因素。现在的 Falcon 等异步框架使用的都是基于 <a href="https://github.com/socketry/nio4r">nio4r</a> 来实现的，其背后是 libev。libev 在各个异步事件库中的性能本来就是比较一般的，再加上其为了更好的兼容性做了大量的妥协。另一方面，以前的调度库需要大量 Ruby 元编程帮助，而现在几乎都是在 C extension 间完成的，性能也有了很大的提升。</p>

<p>另外比起我们之前在 preview1 上做的测试，这个版本的 Fiber 调度器修复了大量的错误，而 wrk 的测试结果是非常错误敏感的，这使得我们最终的请求速度比起之前又提升了 10 倍。</p>

<p><strong>wrk 对于错误非常敏感，这个 benchmark 中的 parser 有问题，无法准确关闭 socket。把我的 <a href="https://github.com/midori-rb/midori.rb">Midori</a> 重新捡起来改成了 Ruby 3 Scheduler 项目。性能达到了 247k req/s 单线程使用 kqueue！使用 epoll 更是达到了 647k req/s！达到了上百倍的性能提升。</strong></p>

<h2 id="与-ractor-结合">与 Ractor 结合</h2>

<p>我在 2020 年 11 月 17 日写过一篇关于 Ractor 的扫盲贴 <a href="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide/">《Ractor 下多线程 Ruby 程序指南》</a>，Ractor 和 Fiber 的结合始终是一个有意思的话题。目前情况下 Fiber 与 Ractor 结合来实现 Web 服务器有两个可能的路径：</p>

<ol>
  <li>在主 Ractor 部署一个调度器，用来处理请求的 accept。将请求派发到子 Ractor 中，由子线程进行处理后将返回值传回主 Ractor 中进行请求返回。</li>
  <li>利用 Linux 内核 <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code> 特性让多个 Ractor 同时监听请求，即可直接将单线程服务器扩展成多线程服务器。</li>
</ol>

<p>比较可惜的是，目前这两者都是无法实现的。因为目前 Fiber 的一些特性无法在 Ractor 中使用。我个人倾向认为这是误报，目前已提交了一个 patch <a href="https://github.com/ruby/ruby/pull/3971">GitHub #3971</a>。根据我之前的测试，Ractor 的加入在实际上应该还能再提升 4 倍左右的吞吐量。不过由于 API 服务器通常是无状态的，主要矛盾也不是 CPU-bound，所以这些吞吐量也是可以由多进程来实现的，Ractor 的引入更多是比起多进程实现的内存消耗降低。</p>

<p>等 Ruby 3.0 更新后我们可以进一步测试。</p>

<h2 id="总结">总结</h2>

<p>这比起 preview1 10 倍的性能提升，和比起以前阻塞 I/O 近 36 倍的性能提升足以证明 Ruby 目前<strong>服务器的性能</strong>问题的本质是 I/O 阻塞问题，而不是 Ruby CPU 执行慢的问题。而随着 I/O 调度器的引入，Ruby 3 的 I/O 性能能更上一个台阶。接下来我们要等待的就是一些使用 C 原生组件的，比如数据库驱动和 Redis 驱动的更新。然后使用一个基于 Fiber 的 Web 服务器，例如 <a href="https://github.com/socketry/falcon">Falcon</a>。无需任何业务上代码的变化，就能得到数倍甚至数十倍的性能提升。</p>

<p>让我们继续享受 Ruby 的快乐编程。</p>]]></content><author><name>CodeRemixer</name></author><category term="编程" /><category term="Ruby" /><summary type="html"><![CDATA[For English Readers]]></summary></entry><entry><title type="html">Ractor 下多线程 Ruby 程序指南</title><link href="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide" rel="alternate" type="text/html" title="Ractor 下多线程 Ruby 程序指南" /><published>2020-11-17T16:30:24+00:00</published><updated>2020-11-17T16:30:24+00:00</updated><id>https://coderemixer.com/2020/11/17/ruby-3-ractor-guide</id><content type="html" xml:base="https://coderemixer.com/2020/11/17/ruby-3-ractor-guide"><![CDATA[<h2 id="什么是-ractor">什么是 Ractor?</h2>

<p>Ractor 是 Ruby 3 新引入的特性。Ractor 顾名思义是 Ruby 和 Actor 的组合词。Actor 模型是一个基于通讯的、非锁同步的并发模型。基于 Actor 的并发模型在 Ruby 中有很多应用，比如 <code class="language-plaintext highlighter-rouge">concurrent-ruby</code> 中的 <code class="language-plaintext highlighter-rouge">Concurrent::Actor</code>。Concurrent Ruby 虽然引入了大量的抽象模型，允许开发高并发的应用，但是它并不能摆脱 Ruby 的 GIL (Global Interpreter Lock)，这使得同一时间，只有一个线程是活跃的。所以通常 <code class="language-plaintext highlighter-rouge">concurrent-ruby</code> 需要搭配无锁的 JRuby 解释器使用。然而，直接解除 GIL 锁会导致大量默认 GIL 可用的依赖出现问题，在多线程开发中会产生难以预料的线程竞争问题。</p>

<p>去年在 RubyConf China 的时候，我问 matz 说 90 年代多核的小型机以及超级计算机已经变得非常普遍了，为什么会把 Ruby 的多线程设计成这样呢？matz 表示，他当时还在用装着 Windows 95 的 PC，如果他知道以后多核会那么普遍，他也不会把 Ruby 设计成这样。</p>

<h2 id="什么数据可以在-ractor-间共享">什么数据可以在 Ractor 间共享？</h2>

<p>但是，历史遗留问题依然需要解决。随着 Fiber Scheduler 在 Ruby 3 引入来提高 I/O 密集场景下单一线程利用率极低的问题；我们需要进一步解决，计算密集场景下，多线程的利用率。</p>

<p>为了解决这一问题，Ruby 3 引入了 Ractor 模型。Ractor 本质来说还是 Thread 线程，但是 Ractor 做了一系列的限制。首先，锁是不会在 Ractor 之间共享的；也就是说，不可能有两个线程争抢同一个锁。Ractor 和 Ractor 之间可以传递消息。Ractor 内部具有全局锁，确保 Ractor 内的行为和原先 Thread 是一致的。传递消息必须是值类型的，这意味着不会有指针跨 Ractor 生存，也会避免数据竞争问题。简而言之，Ractor 把每个 Thread 当作一个 Actor。</p>

<p>但 Ruby 没有真正的值类型。但值类型的本质就是用拷贝来替代引用。我们要做的就是确保 Ruby 对象的可拷贝性。我们查看 Ractor 的文档，我们可以看到这个的严格描述：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ractors don't share everything, unlike threads.
<span class="p">
*</span> Most objects are <span class="ge">*Unshareable objects*</span>, so you don't need to care about thread-safety problem which is caused by sharing.
<span class="p">*</span> Some objects are <span class="ge">*Shareable objects*</span>.
<span class="p">  *</span> Immutable objects: frozen objects which don't refer to unshareable-objects.
<span class="p">    *</span> <span class="sb">`i = 123`</span>: <span class="sb">`i`</span> is an immutable object.
<span class="p">    *</span> <span class="sb">`s = "str".freeze`</span>: <span class="sb">`s`</span> is an immutable object.
<span class="p">    *</span> <span class="sb">`a = [1, [2], 3].freeze`</span>: <span class="sb">`a`</span> is not an immutable object because <span class="sb">`a`</span> refer unshareable-object <span class="sb">`[2]`</span> (which is not frozen).
<span class="p">  *</span> Class/Module objects
<span class="p">  *</span> Special shareable objects
<span class="p">    *</span> Ractor object itself.
<span class="p">    *</span> And more...
</code></pre></div></div>

<h2 id="ractor-性能提升测试">Ractor 性能提升测试</h2>

<p>为了测试出 Ractor 的效果，我们需要一个计算密集的场景。最计算密集的场景，当然就是做数学计算本身。比如我们有下面一个程序：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DAT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="mi">72072000</span><span class="p">).</span><span class="nf">to_a</span>
<span class="nb">p</span> <span class="no">DAT</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>这个程序计算 0 到 72072000 的平方和。我们运行一下这个程序，得到运行时间是 8.17s。</p>

<p>如果我们用传统的多线程来写，我们可以把程序写成这样：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">THREADS</span> <span class="o">=</span> <span class="mi">8</span>
<span class="no">LCM</span> <span class="o">=</span> <span class="mi">72072000</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="no">THREADS</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="n">r</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="p">(((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">...</span><span class="p">((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))).</span><span class="nf">to_a</span>
    <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">dat</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">r</span>
<span class="k">end</span>

<span class="n">t</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">join</span> <span class="p">}</span>
<span class="nb">p</span> <span class="n">res</span><span class="p">.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>运行后，我们发现，虽然确实创建了 8 个系统线程，但是总运行时间变成了 8.21s。没有显著的性能提升。</p>

<p>使用 Ractor 重写程序，主要需要改变我们子线程内需要访问外面的 <code class="language-plaintext highlighter-rouge">i</code> 变量，我们用消息的方法传递进去，改进后的代码会变成这样：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">THREADS</span> <span class="o">=</span> <span class="mi">8</span>
<span class="no">LCM</span> <span class="o">=</span> <span class="mi">72072000</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

<span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="no">THREADS</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="n">r</span> <span class="o">=</span> <span class="no">Ractor</span><span class="p">.</span><span class="nf">new</span> <span class="n">i</span> <span class="k">do</span> <span class="o">|</span><span class="n">j</span><span class="o">|</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="p">(((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">...</span><span class="p">((</span><span class="no">LCM</span><span class="o">/</span><span class="no">THREADS</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))).</span><span class="nf">to_a</span>
    <span class="n">dat</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">r</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="n">t</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">take</span> <span class="p">}.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div>

<p>其结果如何呢？我们根据不同的线程数量进行了测试。</p>

<table>
  <thead>
    <tr>
      <th><strong>Threads</strong></th>
      <th><strong>AMD Ryzen 7 2700x</strong></th>
      <th><strong>Intel i7-6820HQ</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>1</strong></td>
      <td>8.171</td>
      <td>12.027</td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td>4.483</td>
      <td>6.913</td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td>4.874</td>
      <td>6.755</td>
    </tr>
    <tr>
      <td><strong>4</strong></td>
      <td>2.353</td>
      <td>6.188</td>
    </tr>
    <tr>
      <td><strong>5</strong></td>
      <td>2.429</td>
      <td>5.154</td>
    </tr>
    <tr>
      <td><strong>6</strong></td>
      <td>2.259</td>
      <td>5.320</td>
    </tr>
    <tr>
      <td><strong>7</strong></td>
      <td>1.908</td>
      <td>5.368</td>
    </tr>
    <tr>
      <td><strong>8</strong></td>
      <td>2.156</td>
      <td>5.754</td>
    </tr>
    <tr>
      <td><strong>9</strong></td>
      <td>2.136</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>10</strong></td>
      <td>3.159</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>11</strong></td>
      <td>2.577</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>12</strong></td>
      <td>2.679</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>13</strong></td>
      <td>2.787</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>14</strong></td>
      <td>2.615</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>15</strong></td>
      <td>2.197</td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>16</strong></td>
      <td>2.303</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/ractor-benchmark.png" alt="Ractor Benchmark" /></p>

<p>Ractor 确实改善了多线程全局解释锁的问题。</p>

<h2 id="显微镜下的-ractor">显微镜下的 Ractor</h2>

<p>我使用了 AMD uProf（对于 Intel CPU，可以使用 Intel VTune）进行 CPU 运算情况的统计。为了降低睿频对单线程性能的影响，我将 AMD Ryzen 7 2700x 全核心锁死 4.2GHz。</p>

<p><img src="/assets/images/ractor-uprof.png" alt="uProf Results" /></p>

<p>对于 AMD Ryzen 7 2700x，4 线程比单一线程快了 3 倍多。到 4 线程，比单一线程快了约 4 倍。AMD Ryzen 7 2700x 是一款 8 核心 16 线程的 CPU。同时，每 4 个核心组成一个 CCX，跨 CCX 的内存访问有额外的代价。这使得 4 线程内性能提升很显著，超过 4 线程后受限于 CCX 和 SMT，性能提升变得比较有限。其表现是随着线程数的增加，IPC（每时钟周期指令数）开始下降。在单线程运算时，每时钟周期 CPU 可以执行 2.42 个指令；但到了 16 线程运算时，每时钟周期 CPU 只能执行 1.40 个指令。同时，更多的线程意味着更复杂的操作系统的线程调度，使得多核的利用率越来越低。</p>

<p>同样，对于 Intel i7-6820HQ，我们得到了类似的结论。这是一款 4 核 8 线程的 CPU，由于第 5 个线程开始需要使用 HT，从而提升变得很有限。</p>

<h2 id="ractor-如何改善现有-ruby-程序的性能">Ractor 如何改善现有 Ruby 程序的性能？</h2>

<p>Ractor 的引入除了可以改善计算密集场景下的运算效率，对于现有大型 Ruby Web 程序的内存占用也是有积极意义的。现有 Web 服务器，比如 puma，由于 I/O 多路复用性能极其低下，通常会使用多线程 + 多进程的形式来提升性能。由于 Web 服务器可以自由水平扩展，使用多进程的形式来管理，可以完全解开 GIL 锁的问题。</p>

<p>但是 fork 指令效率低下。微软在 2019 年 HOTOS 上给出了一篇论文：<a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf">A fork() in the road</a>，和 spawn 相比，fork 模式会导致启动速度变得非常慢。为了缓解这一问题，在 Ruby 2.7 引入 <code class="language-plaintext highlighter-rouge">GC.compact</code> 后，通常需要执行多次 <code class="language-plaintext highlighter-rouge">compact</code> 来降低 fork 启动的消耗。进一步地，使用 Ractor 来替代多进程管理，可以更容易地传递消息，复用可冻结的常量，从而降低内存占用。</p>

<h2 id="总结">总结</h2>

<p>Ruby 3 打开了多线程的潘多拉盒子。我们可以更好利用多线程来改善性能。但是看着 CPU Profiler 下不同线程调用会导致 CPU IPC 下降和缓存命中下降，对程序调优也提出了更高的要求。</p>

<p>我们边走边看吧。</p>]]></content><author><name>CodeRemixer</name></author><category term="编程" /><category term="Ruby" /><summary type="html"><![CDATA[什么是 Ractor?]]></summary></entry><entry><title type="html">真的存在没有反光的眼镜吗？</title><link href="https://coderemixer.com/2020/11/11/how-anti-reflective-coating-works" rel="alternate" type="text/html" title="真的存在没有反光的眼镜吗？" /><published>2020-11-11T00:48:24+00:00</published><updated>2020-11-11T00:48:24+00:00</updated><id>https://coderemixer.com/2020/11/11/how-anti-reflective-coating-works</id><content type="html" xml:base="https://coderemixer.com/2020/11/11/how-anti-reflective-coating-works"><![CDATA[<p>前几天看某个 YouTuber 说因为眼镜反射很厉害，导致很难打光，想去眼睛店配一副新的眼镜，能减少反光。眼睛店老板号称富士的某款镜片可以「几乎」解决所有反光，花了好几万新台币，买回来发现除了反射从绿色变成了紫色，没有明显差异。</p>

<h2 id="原理">原理</h2>

<p>眼镜镜片减少反射的主要原理是利用镀膜。为什么镀膜可以减少反射呢？我们需要一些简单易懂的物理课。我们将光看成一束波（这里就先不讲量子力学里光的特性，太复杂了），当光打在镜片上时，大部分的光会透过去，少部分会发生反射。如果现在在镜片前还有一层镀膜，由于这是两个不同介质的物质，光线会先发生折射，再发生刚刚的透过和反射的过程。同时在镀膜的表面，还有可能再发生一次反射。于是我们得到了两束平行的反射光，反射 1 和反射 2，这两束光有一个相位差 φ，如果这个相位差恰好能使两束光线的波峰和波谷叠加（发生干涉），那么这部分能量就会被抵消，反射光减小；但是又由于能量守恒，所以透过镜片的光线就会增加。所以这一类镀膜也称为「增透膜」。</p>

<p><img src="/assets/images/ar-coating.jpg" alt="AR Coating" /></p>

<p>我们现在从原理上了解了增透膜如何减少反光，接下来的问题是，镀膜减少的反射光由什么决定？基本上就是膜层的折射率乘以厚度（即光学厚度）。因为这个光学厚度的两倍是光线 2 比光线 1 多走的路程，如果这个厚度恰好是半波长的一半（或者半波长的整倍数加 1/4 波长），那么这束光线就能被完全抵消。</p>

<h2 id="实践分析">实践分析</h2>

<p>那么问题来了，最常见的摄影灯光是白光，白光不是单一波长的光，显然不可能由一层增透膜抵消掉。事实上镜片会使用多层镀膜，多层镀膜的效果比较难计算，但要想抵消掉全部白光里各种波长的光也是困难重重。</p>

<p>那么为什么配了这个减少反光的眼镜后，反光从绿色变成了紫色呢？其实也很好理解，因为 400nm 波长的紫光，比 550nm 左右的绿光半波长更短，这要求镀膜材料的厚度和反射率都要更低。波长越短的光对于材料和镀膜的技术要求都更高，自然就更难处理。</p>

<p>事实上，像是相机镜头中，由于通常需要多组镜片，问题会叠加，提高透光率的要求更高。但随便拿哪个再贵的相机镜头出来，放在太阳地下还是能看到绿色、紫色或者红色的反光，没有能完全抵消掉反光的镜片。</p>

<h2 id="总结">总结</h2>

<p>不过平心而论，各个镜片厂商对于这个镀膜减反射特性的描述都是很详细的。比如说我随便找了一下蔡司的镀膜规格，说的是主要和传统镀膜比起来降低了 1% 左右的绿光反射率，由于人眼对绿光更敏感，所以比较有效果。但是看着这张图就知道在紫色光的 400nm 部分，反射率还是高达 5%，和传统镀膜并没有明显差异。</p>

<p><img src="/assets/images/zeiss-coating.jpg" alt="Zeiss Coating Sample" /></p>

<p>所以这个问题的最后，为什么这个几万元的眼镜明明只是降低了 1% 绿光反射，会让人觉得能降低大部分反射，最后花了冤枉钱呢？其实镜片厂没有骗人，详细的资料列得很清楚，但买镜片的客户并不是从镜片厂直接获取的资讯，经过了一层眼镜店老板。眼镜店老板又不用学习光学，他的职责就是怎么卖出更大的利润，结果就是被眼镜店老板骗了。</p>]]></content><author><name>CodeRemixer</name></author><category term="光学" /><summary type="html"><![CDATA[前几天看某个 YouTuber 说因为眼镜反射很厉害，导致很难打光，想去眼睛店配一副新的眼镜，能减少反光。眼睛店老板号称富士的某款镜片可以「几乎」解决所有反光，花了好几万新台币，买回来发现除了反射从绿色变成了紫色，没有明显差异。]]></summary></entry><entry><title type="html">Safari is Fast, but So What?</title><link href="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what-english" rel="alternate" type="text/html" title="Safari is Fast, but So What?" /><published>2020-10-21T11:52:13+00:00</published><updated>2020-10-21T11:52:13+00:00</updated><id>https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what-english</id><content type="html" xml:base="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what-english"><![CDATA[<p>中文版本<a href="/2020/10/21/safari-is-fast-but-so-what/">见此</a></p>

<h2 id="a-mysterious-bug">A Mysterious Bug</h2>

<p>In a day of 2016, we found that our users could not pass the CDN authentication with their iPhones. We then took several days to debug. The situation is that we need to upload three files at the same time. We use the token of the user to generate three random ids. The CDN server would use these ids to authenticate the upload of user files. In this case, we don’t have to transfer the files to CDN on our server.</p>

<p>But soon, iOS users found a weird problem. Users could only upload one of the three files. After debugging, we found that after uploading the first file, the next two ids become illegal. Furthermore, we found the three ids fetched by Safari are precisely the same?!</p>

<h2 id="reproduction">Reproduction</h2>

<p>I soon designed a reproduction of this bug:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
&lt;html&gt;
&lt;script type="text/javascript"&gt;
function reqListener () {
  console.log(this.responseText);
}

for (i = 0; i &lt; 3; i++) {
  var oReq = new XMLHttpRequest();
  oReq.addEventListener("load", reqListener);
  oReq.open("GET", "/count");
  oReq.send();
}
&lt;/script&gt;
&lt;/html&gt;
</span><span class="no">EOF</span>
<span class="k">end</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">get</span> <span class="s1">'/count'</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">count</span><span class="p">.</span><span class="nf">to_s</span>
<span class="k">end</span>

</code></pre></div></div>

<p>On Firefox, you would get 1 2 3, but on Safari, you would get three 1s.</p>

<p>For the same API request, if the parameters are identical. Safari may return same results of all these requests if they are sent asynchronously.</p>

<h2 id="analysis">Analysis</h2>

<p>In general, we may think that GET requests of HTTP/1.1 are Idempotent. If we treat x as the status of the server, and f is the GET request, we would have:</p>

\[f(f(x)) = f(x)\]

<p>The idempotence ensures that the side effects of multiple calls are identical to a single call. We could infer that all responses of the same GET request should also be exact.</p>

<p>But if we check <a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">rfc7231</a> carefully, the definition of the Idempotence is to ensure resend of a failure request safe instead of not allowing the backend to do any non-idempotent operations.</p>

<p>What if we change GET to POST?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
&lt;html&gt;
&lt;script type="text/javascript"&gt;
function reqListener () {
  console.log(this.responseText);
}

for (i = 0; i &lt; 3; i++) {
  var oReq = new XMLHttpRequest();
  oReq.addEventListener("load", reqListener);
  oReq.open("POST", "/count");
  oReq.send();
}
&lt;/script&gt;
&lt;/html&gt;
</span><span class="no">EOF</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/count'</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">count</span><span class="p">.</span><span class="nf">to_s</span>
<span class="k">end</span>
</code></pre></div></div>
<p>IT IS STILL THREE 1s! There’s not any HTTP spectification to define the Idempotence of POST action. This must cause serious problems due to the basic concepts of HTTP actions.</p>

<p>If we check the output from the backend, there is only one 1, which means the three POST requests are cached by Safari?!</p>

<p>If we assume the reliability of idempotence, we could hash the parameters to reduce the response time with cache and improve the performance of callbacks in the event engine of a browser. But apparently, this assumption is incorrect, and Safari does make such optimizations, which causes the bug.</p>

<h2 id="bug-report">Bug Report</h2>

<p><img src="/assets/images/safari-js-bug.png" alt="Screenshot" /></p>

<p>If we check this problem carefully on the Internet, people started asking questions about Safari cache POST requests and Safari cache GET requests with cache disabled from 2012.</p>

<p>I submitted this bug from Apple’s feedback system in 2016. After four years, the feedback system has evolved to Feedback Assistant; Mac OS X has been renamed to macOS; El Capitan has been upgraded to Big Sur. But this bug is still in the latest Safari (16610.2.8.1.1). My ticket is still open, with NO RESPONSE.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Safari is fast, efficient, and power-saving. But if Safari can’t keep essential compatibility with W3C Web API standards, how dare we using this browser? But due to the monopoly of iOS and App Store, iOS developers are not allowed to use third-party Webview, including Chrome and Firefox. Before iOS, nobody cares about Safari. But now, we, the web developers, have to compromise with the incorrect implementation of Safari. Even the evil IE, didn’t use the monopoly of the operating system to force users to accept the specification of a browser.</p>

<p>Safari is not only the new IE, but it is also more evil than IE. Apple is the destroyer of the free Internet system.</p>

<p>F**k you, Apple.</p>]]></content><author><name>CodeRemixer</name></author><category term="Safari" /><category term="Apple" /><category term="Web" /><category term="W3C" /><category term="JavaScript" /><summary type="html"><![CDATA[中文版本见此]]></summary></entry><entry><title type="html">如果 Safari 做不到对，快有何用？</title><link href="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what" rel="alternate" type="text/html" title="如果 Safari 做不到对，快有何用？" /><published>2020-10-21T11:52:12+00:00</published><updated>2020-10-21T11:52:12+00:00</updated><id>https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what</id><content type="html" xml:base="https://coderemixer.com/2020/10/21/safari-is-fast-but-so-what"><![CDATA[<p>For English version, click <a href="/2020/10/21/safari-is-fast-but-so-what-english/">here</a></p>

<h2 id="一个困扰了一周的-bug">一个困扰了一周的 bug</h2>

<p>2016 年的一天，当我们发现 iPhone 上的浏览器不能正确通过我们的 CDN 鉴权后，我们花了数天的时间来 debug。简单来说当时的情况是，我们需要同时上传 3 个文件，我们会用用户 token 来换 3 个独立的随机数 id，这三个 id 会被 CDN 服务器认为合法，用户可以直接上传到 CDN 上而无需在我们自己服务器上中转。</p>

<p>但 iOS 用户很快就出现了一个奇怪的问题，用户 3 个文件只能成功上传 1 个，剩下 2 个无法正常上传。再进一步调试后我们发现，在上传任意一个文件后，剩下两个 id 变成了非法。再进一步地，我们发现 Safari 获得的 3 个 id 竟然是完全相同的？！</p>

<h2 id="复现">复现</h2>

<p>我很快设计出了能够构建出这个问题的重现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
&lt;html&gt;
&lt;script type="text/javascript"&gt;
function reqListener () {
  console.log(this.responseText);
}

for (i = 0; i &lt; 3; i++) {
  var oReq = new XMLHttpRequest();
  oReq.addEventListener("load", reqListener);
  oReq.open("GET", "/count");
  oReq.send();
}
&lt;/script&gt;
&lt;/html&gt;
</span><span class="no">EOF</span>
<span class="k">end</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">get</span> <span class="s1">'/count'</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">count</span><span class="p">.</span><span class="nf">to_s</span>
<span class="k">end</span>

</code></pre></div></div>

<p>在 Firefox 上，你会得到 1 2 3 的输出，而在 Safari 上你会得到 3 个 1。</p>

<p>针对同一个 API 接口，只要请求参数完全一致，并且在一个请求返回前，相同的请求已经被发出，那么这些请求都会得到完全相同的结果。</p>

<h2 id="问题分析">问题分析</h2>

<p>HTTP/1.1 规格上 API 的 GET 是幂等的，如果我们把 x 当作服务器的状态，f 是 GET 请求操作，那么我们有：</p>

\[f(f(x)) = f(x)\]

<p>这确保了多次调用接口产生的副作用，和一次调用是一致的。我们似乎可以得到推论认为每次 GET 请求的返回都应该是一样的。</p>

<p>但如果我们仔细来看 <a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">rfc7231</a> 对于 HTTP 幂等的定义，其只是为了确保请求重新发送的可靠性，而不是不允许后端进行任何非幂等的操作。</p>

<p>如果我们把 GET 换成 POST 结果如何呢？</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="o">&lt;&lt;-</span><span class="no">EOF</span><span class="sh">
&lt;html&gt;
&lt;script type="text/javascript"&gt;
function reqListener () {
  console.log(this.responseText);
}

for (i = 0; i &lt; 3; i++) {
  var oReq = new XMLHttpRequest();
  oReq.addEventListener("load", reqListener);
  oReq.open("POST", "/count");
  oReq.send();
}
&lt;/script&gt;
&lt;/html&gt;
</span><span class="no">EOF</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/count'</span> <span class="k">do</span>
  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">count</span><span class="p">.</span><span class="nf">to_s</span>
<span class="k">end</span>
</code></pre></div></div>

<p>竟然得到的也是三个 1！任何关于 HTTP 的规格都没有这样的描述，这对于 HTTP 动词的基本概念相违背，显然会带来非常严重的问题。</p>

<p>我们检查一下后端的输出，只有一个 1。也就是这三个 POST 请求被 Safari 缓存了？！</p>

<p>一些接口必然无法满足幂等的要求，比如统计接口和随机数接口。</p>

<p>如果我们假设这个幂等的可靠性，那么我们自然可以把请求参数进行哈希，缓存降低响应时间，以及提高事件回调时事件引擎的处理速度。但是显然这个假设是错的。但显然 Safari 做了相关的优化，从而导致了问题。</p>

<h2 id="bug-report">Bug Report</h2>

<p><img src="/assets/images/safari-js-bug.png" alt="Screenshot" /></p>

<p>如果仔细找一下会发现，2012 年左右开始几乎每年都有人在网上问 Safari cache POST 请求和 Safari cache GET requests with cache disabled 的问题。</p>

<p>我在 2016 年通过 Apple 当时非常丑的 Feedback 系统提交了这个 bug。然而从这个 Feedback 系统升级到了 Feedback Assistant，Mac OS X 改名成了 macOS，从 El Capitan 升级到了 Big Sur，这个 Bug 不但在最新的 Safari 14.0.1 (16610.2.8.1.1) 依然存在。这个 Ticket 也没有得到任何回复。</p>

<h2 id="结论">结论</h2>

<p>Safari 很快，Safari 效率很高，Safari 很省电。但如果连基本的 W3C Web API 的兼容性、可靠性都不能保证，我们怎么敢使用这个浏览器？但好在由于 App Store 的垄断性，iOS 设备被要求不允许使用第三方 Webview，包括 iOS 上的 Chrome 和 Firefox。在 iOS 之前不会有人理 Safari 的，但现在我们这些 Web 开发者被迫为 Safari 的无下限进行妥协。就连邪恶的微软 IE，也没有敢利用操作系统的垄断来强制浏览器的规格。</p>

<p>Safari 何止是新的 IE，它比 IE 邪恶多了。Apple 根本就是自由互联网的摧毁者，这和中国开发者痛恨的微信浏览器又有什么本质上的区别呢？</p>

<p>F**k you, Apple.</p>]]></content><author><name>CodeRemixer</name></author><category term="Safari" /><category term="Apple" /><category term="Web" /><category term="W3C" /><category term="JavaScript" /><summary type="html"><![CDATA[For English version, click here]]></summary></entry><entry><title type="html">手写一个 LZW 压缩算法</title><link href="https://coderemixer.com/2020/09/26/write-lzw-manually" rel="alternate" type="text/html" title="手写一个 LZW 压缩算法" /><published>2020-09-26T16:05:10+00:00</published><updated>2020-09-26T16:05:10+00:00</updated><id>https://coderemixer.com/2020/09/26/write-lzw-manually</id><content type="html" xml:base="https://coderemixer.com/2020/09/26/write-lzw-manually"><![CDATA[<h2 id="起因">起因</h2>

<p>之前需要在某个单片机下塞点阵字库，为了能多覆盖一些字，准备在字库上做一点压缩。由于常用字相邻编码通常是按形码编码的，所以形状上有很多相似性，因此应该是比较可以压缩的。读取的时候，把一整块相邻编码解压塞到内存里，在内存里做个 LRU 缓存。由于常用字的编码也比较靠近，所以可以一定程度上在覆盖生僻字的同时，达到比较好的读取性能。</p>

<p>不过单片机上写个压缩算法比较麻烦。单片机本身的性能就很差，压缩算法本身约简单越好。最好实现的压缩算法恐怕就是 LZW 了。由于 LZW 的字典是自解释的，也不需要单独构建霍夫曼树，one-pass 一遍读完就解决。于是就考虑写个 LZW。</p>

<h2 id="lzw-基本原理">LZW 基本原理</h2>

<p>LZW 压缩需要两件东西，一个是字符集一个是字典。最常见的字符集就是 <code class="language-plaintext highlighter-rouge">0x00</code> 到 <code class="language-plaintext highlighter-rouge">0xff</code> 的 256 个字符当作字符集，即我们把所以 8-bit 数据看成一个单独字符。字典是这个字符集的组合。字典构成一个更大的空间，通常教科书上的例子的是 14-bit 的字典空间。也就是 <code class="language-plaintext highlighter-rouge">0x0000-0x1fff</code>，其中 <code class="language-plaintext highlighter-rouge">0x0000-0x00ff</code> 是基础字符集，<code class="language-plaintext highlighter-rouge">0x0100-0x1fff</code> 7935 个编号作为可编码的字典。这对于压缩率是比较好的，不过 14-bit 的读取实在太麻烦了，因为它不是 byte 的整倍数。于是我把可编码的字典空间放达到 2 个 bytes 也就是 <code class="language-plaintext highlighter-rouge">0x0100-0xffff</code> 65279 个字符，和字符集一起构成一个 65536 字符的空间。</p>

<h2 id="函数签名">函数签名</h2>

<p>头文件和函数签名非常简单：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">dictionary</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">entries_sizes</span><span class="p">[</span><span class="mi">65536</span><span class="p">];</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">entries</span><span class="p">[</span><span class="mi">65536</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="nf">dictionary_init</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">dictionary_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">dictionary_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// The string would be copied, be sure to free the word.</span>
<span class="kt">size_t</span> <span class="nf">dictionary_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">compress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">decompress</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">);</span>
</code></pre></div></div>

<p>维护字典大小、插入字典、根据字符查找在字典的位置、执行压缩和解压缩。</p>

<p>其中字典的创建、释放和插入是基本的 C 语言常识：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="nf">dictionary_init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="p">));</span>
    <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
        <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dict</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dictionary_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="nf">dictionary_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">65536</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>查找的一个比较好的实现方法是使用哈希（<code class="language-plaintext highlighter-rouge">unordered_map</code>）。不过由于我在使用 C 语言，没有炫酷的 C++ STL 标准库。考虑到字典最大就 65536 个，而且用 size 大小就能很好做初步的筛选，我还是整个遍历一遍算了。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">dictionary_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">word</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="压缩过程">压缩过程</h2>

<p>LZW 之所以不需要单独维护字典是因为 LZW 对于如何建立字典这件事情是 <strong>隐含</strong> 在算法中的。对于当前压缩过程，如果前一个字典字和当前的字符的组合没有出现在字典中，那么就插入到字典中。为了理解这个概念，我们先简化一下模型。我们假设基本字符集只有 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 两个字符，然后我们编码这个序列：<code class="language-plaintext highlighter-rouge">01001101</code></p>

<table>
  <thead>
    <tr>
      <th>前一个字典字</th>
      <th>当前字符</th>
      <th>构成的组合</th>
      <th>是否出现在字典中？</th>
      <th>输出</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-</td>
      <td>0</td>
      <td>0</td>
      <td>出现（基本字符 0 -&gt; 0）</td>
      <td>-</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>01</td>
      <td>没有（插入字典 2 -&gt; 01）</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>10</td>
      <td>没有（插入字典 3 -&gt; 10）</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>00</td>
      <td>没有（插入字典 4 -&gt; 00）</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>01</td>
      <td>出现（2 -&gt; 01）</td>
      <td>-</td>
    </tr>
    <tr>
      <td>01</td>
      <td>1</td>
      <td>011</td>
      <td>没有（插入字典 5 -&gt; 011）</td>
      <td>2</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>11</td>
      <td>没有（插入字典 6 -&gt; 11）</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>10</td>
      <td>出现（3 -&gt; 10）</td>
      <td>-</td>
    </tr>
    <tr>
      <td>10</td>
      <td>1</td>
      <td>101</td>
      <td>没有（插入字典 7 -&gt; 101）</td>
      <td>3</td>
    </tr>
    <tr>
      <td>1</td>
      <td>-</td>
      <td>1</td>
      <td> </td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>于是我们把 <code class="language-plaintext highlighter-rouge">01001101</code> 编码成了 <code class="language-plaintext highlighter-rouge">0102131</code>，这个序列的压缩率是非常糟糕的，因为 01 可以用一个 bit 表示，<code class="language-plaintext highlighter-rouge">01001101</code> 只有 1 byte，但压缩后的 <code class="language-plaintext highlighter-rouge">0102131</code> 至少需要 2 个 bit 来表示一个字符，虽然整体数量减少到了 7 个字符，但是实际上需要 14-bit（1.75 bytes）才能存储。但随着字符变长，字典覆盖会越来越好，压缩率也会越来越低。</p>

<p>我在实际实现的时候还标注了一个元信息，就是用第一个 <code class="language-plaintext highlighter-rouge">size_t</code> 来标注源文件的大小，以便于之后解压的时候申请内存。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">compress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s">"wb+"</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span> <span class="o">=</span> <span class="n">dictionary_init</span><span class="p">();</span>

    <span class="c1">// First size_t indicates the file size</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">p_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">ppc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">p_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// p + c</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">ppc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p_size</span><span class="p">);</span>
        <span class="n">ppc</span><span class="p">[</span><span class="n">p_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">dictionary_find</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">ppc</span><span class="p">,</span> <span class="n">p_size</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Found</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="p">}</span>
            <span class="n">p_size</span> <span class="o">=</span> <span class="n">p_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_size</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ppc</span><span class="p">,</span> <span class="n">p_size</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Not found</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">p_res</span> <span class="o">=</span> <span class="n">dictionary_find</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p_size</span><span class="p">);</span>
            <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_res</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">dictionary_insert</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">ppc</span><span class="p">,</span> <span class="n">p_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
            <span class="n">p_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">c_res</span> <span class="o">=</span> <span class="n">dictionary_find</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_res</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">free</span><span class="p">(</span><span class="n">ppc</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">dictionary_free</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="解压过程">解压过程</h2>

<p>LZW 的压缩是比较简单的，但是解压却是有点 tricky 的。如果我们顺着压缩的思路来解压，我们会认为，顺着我们解压的过程，我们会慢慢构建出我们需要的字典。我们考虑下面一个序列 <code class="language-plaintext highlighter-rouge">10101</code> 的压缩过程：</p>

<table>
  <thead>
    <tr>
      <th>前一个字典字</th>
      <th>当前字符</th>
      <th>构成的组合</th>
      <th>是否出现在字典中？</th>
      <th>输出</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-</td>
      <td>1</td>
      <td>1</td>
      <td>出现（基本字符 1 -&gt; 1）</td>
      <td>-</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>10</td>
      <td>没有（插入字典 3 -&gt; 10）</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>01</td>
      <td>没有（插入字典 4 -&gt; 01）</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>10</td>
      <td>出现（3 -&gt; 10）</td>
      <td>-</td>
    </tr>
    <tr>
      <td>10</td>
      <td>1</td>
      <td>101</td>
      <td>没有（插入字典 5 -&gt; 101）</td>
      <td>3</td>
    </tr>
    <tr>
      <td>1</td>
      <td>-</td>
      <td>1</td>
      <td> </td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>输出的结果是 <code class="language-plaintext highlighter-rouge">1031</code>。如果我们解压的话过程如下：</p>

<table>
  <thead>
    <tr>
      <th>前一个字典字</th>
      <th>当前字符</th>
      <th>构成的组合</th>
      <th>是否出现在字典中？</th>
      <th>输出</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-</td>
      <td>1</td>
      <td>1</td>
      <td>出现（基本字符 1 -&gt; 1）</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>10</td>
      <td>没有（插入字典 3 -&gt; 10）</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>3 (10)</td>
      <td>010</td>
      <td><strong>没有（4 -&gt; 010）</strong></td>
      <td>10</td>
    </tr>
  </tbody>
</table>

<p>显然我们把第四个字典的字符值插入错了，应该是 <code class="language-plaintext highlighter-rouge">01</code> 而我们却组合出了 <code class="language-plaintext highlighter-rouge">010</code>。这会进一步导致之后的解压出错。而且我们很容易思考到一个问题，在压缩过程中我们组合的都是前一个字典字和一个 <strong>单一字符</strong>，这里我们让 0 和 10 相加，后者显然不是单一字符。进一步思考我们会发现，在压缩过程中如果一个字典被创建，那么这个步骤的前一个插入字典的尾部，必然是这个匹配到的前缀，也就是这个字典值的第一个字符。所以这里的 <code class="language-plaintext highlighter-rouge">4</code> 应该是前一个字典字 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">10</code> 的第一个字符 1 的组合，也就是 <code class="language-plaintext highlighter-rouge">01</code>。</p>

<p>于是我们以此正确构建我们的解压代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">decompress</span><span class="p">(</span><span class="kt">size_t</span><span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">source</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">dictionary</span><span class="o">*</span> <span class="n">dict</span> <span class="o">=</span> <span class="n">dictionary_init</span><span class="p">();</span>

    <span class="c1">// First size_t indicates the file size</span>
    <span class="n">fread</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">));</span>
    <span class="kt">size_t</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dictionary_free</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">p_index</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">c_index</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">c_word</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">c_word_size</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p_word</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">p_word_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_index</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
    <span class="n">p_word</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">p_index</span><span class="p">];</span>
    <span class="n">p_word_size</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries_sizes</span><span class="p">[</span><span class="n">p_index</span><span class="p">];</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">result</span><span class="o">+</span><span class="n">counter</span><span class="p">,</span> <span class="n">p_word</span><span class="p">,</span> <span class="n">p_word_size</span><span class="p">);</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="n">p_word_size</span><span class="p">;</span>


    <span class="k">while</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_index</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c_index</span> <span class="o">&lt;</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Found</span>
            <span class="n">c_word</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">c_index</span><span class="p">];</span>
            <span class="n">c_word_size</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries_sizes</span><span class="p">[</span><span class="n">c_index</span><span class="p">];</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">result</span><span class="o">+</span><span class="n">counter</span><span class="p">,</span> <span class="n">c_word</span><span class="p">,</span> <span class="n">c_word_size</span><span class="p">);</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="n">c_word_size</span><span class="p">;</span>
            <span class="kt">char</span><span class="o">*</span> <span class="n">ppc</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">ppc</span><span class="p">,</span> <span class="n">p_word</span><span class="p">,</span> <span class="n">p_word_size</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">ppc</span><span class="o">+</span><span class="n">p_word_size</span><span class="p">,</span> <span class="n">c_word</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">dictionary_insert</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">ppc</span><span class="p">,</span> <span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">free</span><span class="p">(</span><span class="n">ppc</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">char</span><span class="o">*</span> <span class="n">ppc</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">ppc</span><span class="p">,</span> <span class="n">p_word</span><span class="p">,</span> <span class="n">p_word_size</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">ppc</span><span class="o">+</span><span class="n">p_word_size</span><span class="p">,</span> <span class="n">p_word</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">c_index</span> <span class="o">=</span> <span class="n">dictionary_insert</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">ppc</span><span class="p">,</span> <span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">result</span><span class="o">+</span><span class="n">counter</span><span class="p">,</span> <span class="n">ppc</span><span class="p">,</span> <span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">c_word</span> <span class="o">=</span> <span class="n">dict</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">c_index</span><span class="p">];</span>
            <span class="n">c_word_size</span> <span class="o">=</span> <span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="n">p_word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">ppc</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">p_word</span> <span class="o">=</span> <span class="n">c_word</span><span class="p">;</span>
        <span class="n">p_word_size</span> <span class="o">=</span> <span class="n">c_word_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dictionary_free</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="实验">实验</h2>

<p>我尝试用马丁路德金的《I have a dream》作为例子实验了一下这个实现：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/tmp/compressed.lzw"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">test</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"I am happy to ..."</span><span class="p">;</span>
    <span class="n">compress</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="n">path</span><span class="p">);</span>

    <span class="kt">size_t</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
    <span class="n">fseek</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span> <span class="c1">// seek to end of file</span>
    <span class="kt">size_t</span> <span class="n">file_size</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">res</span> <span class="o">=</span> <span class="n">decompress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"         Raw Text: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">test</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Decompressed Text: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" Compression Rate: %d%%</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">file_size</span> <span class="o">*</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后的输出如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/delton/CLionProjects/playgound/cmake-build-debug/playgound
         Raw Text: I am happy to ...
Decompressed Text: I am happy to ...
 Compression Rate: 73%
</code></pre></div></div>

<p>整体压缩率有 73%，对比了一下 zip 42% 的压缩率，实在是望尘莫及。</p>

<p>如果我们把文本重复 5 遍，压缩率能提升到 49%。不过这条件下，zip 能提高到 9% 的压缩率。果然还是不能和 DEFLATE 这种 LZW + 霍夫曼树这样的怪物比啊。不过简简单单 200 行代码就能实现一个性能上还不错的压缩、解压缩算法我已经比较满意了。</p>]]></content><author><name>CodeRemixer</name></author><category term="LZW" /><category term="C语言" /><category term="算法" /><category term="压缩" /><summary type="html"><![CDATA[起因]]></summary></entry><entry><title type="html">尝试使用 Ruby 3 调度器</title><link href="https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler-cn" rel="alternate" type="text/html" title="尝试使用 Ruby 3 调度器" /><published>2020-08-18T21:46:47+00:00</published><updated>2020-08-18T21:46:47+00:00</updated><id>https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler-cn</id><content type="html" xml:base="https://coderemixer.com/2020/08/18/a-walkthrough-of-ruby-3-scheduler-cn"><![CDATA[<h2 id="一次失败的提案">一次失败的提案</h2>

<p>在准备 RubyConf China 2020 的时候，我仔细检查了 <a href="https://github.com/ruby/ruby/pull/1870">Fiber 调度器</a> 提出的补丁。当我看调度器的样例代码的时候，我发现其调用的是 Ruby 中的 <code class="language-plaintext highlighter-rouge">IO.select</code> API。<code class="language-plaintext highlighter-rouge">IO.select</code> API 在 Ruby 内部有多种实现，它可能调用 <code class="language-plaintext highlighter-rouge">poll</code>、大尺寸 <code class="language-plaintext highlighter-rouge">select</code>、POSIX 兼容的 <code class="language-plaintext highlighter-rouge">select</code> 取决于不同的操作系统。于是我想用一些更快的 syscall 来实现，比如 <code class="language-plaintext highlighter-rouge">epoll</code> <code class="language-plaintext highlighter-rouge">kqueue</code> 和 <code class="language-plaintext highlighter-rouge">IOCP</code>。</p>

<p>我做了一个相关的<a href="https://bugs.ruby-lang.org/issues/17059">提案</a>但是被拒绝了。主要问题是 Ruby 的 <code class="language-plaintext highlighter-rouge">IO.select</code> API 是无状态的。如果没有含状态的注册，这些新 API 的性能甚至会不如 <code class="language-plaintext highlighter-rouge">poll</code>。在 <a href="https://bugs.ruby-lang.org/issues/17059#note-14">Koichi Sasada</a> 跑了 banchmark 证明了这一点后，提案被正式拒绝。在和 Samuel Williams 在 Twitter 上讨论后，它建议我从 <code class="language-plaintext highlighter-rouge">Scheduler</code> 的实现上来进行注入，因为 <code class="language-plaintext highlighter-rouge">Scheduler</code> 本身是有状态的。于是我开始写一个 <a href="https://github.com/dsh0416/evt">gem</a> 作为 Ruby 3 调度器接口的概念证明。</p>

<h2 id="实现调度器">实现调度器</h2>

<p>本文中的 Ruby 版本是：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby 2.8.0dev (2020-08-18T10:10:09Z master 172d44e809) [x86_64-linux]
</code></pre></div></div>

<p>基本的 Scheduler 例子来自于 Ruby 的<a href="https://github.com/ruby/ruby/blob/b2976a4fcab70bf9323180fd5ba6c29a5bca0747/test/fiber/test_scheduler.rb">单元测试</a>。这是 Ruby 3 调度器的测试，而不是真正用于生产的，因此是使用 <code class="language-plaintext highlighter-rouge">IO.select</code> 进行 I/O 多路复用。因此我们可以基于此，开发一个性能更好的 Ruby 调度器。</p>

<p>我们需要做一些 C 开发来支持其它 syscall，因此第一件事是兼容原始的实现。</p>

<h3 id="fallback-到-ruby-ioselect">Fallback 到 Ruby <code class="language-plaintext highlighter-rouge">IO.select</code></h3>

<p>对于 select/poll API, 不需要预先创建文件描述符，也不需要在运行时注册文件描述符。所以唯一要做的就是处理调度器触发时的行为。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// return IO.select(@readable.keys, @writable.keys, [], next_timeout)</span>
    <span class="n">VALUE</span> <span class="n">readable</span><span class="p">,</span> <span class="n">writable</span><span class="p">,</span> <span class="n">readable_keys</span><span class="p">,</span> <span class="n">writable_keys</span><span class="p">,</span> <span class="n">next_timeout</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_select</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"select"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_keys</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"keys"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>

    <span class="n">readable</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@readable"</span><span class="p">);</span>
    <span class="n">writable</span> <span class="o">=</span> <span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@writable"</span><span class="p">);</span>

    <span class="n">readable_keys</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">readable</span><span class="p">,</span> <span class="n">id_keys</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">writable_keys</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">writable</span><span class="p">,</span> <span class="n">id_keys</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">id_select</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">readable_keys</span><span class="p">,</span> <span class="n">writable_keys</span><span class="p">,</span> <span class="n">rb_ary_new</span><span class="p">(),</span> <span class="n">next_timeout</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们花了 10 行 C 干了原来 1 行 Ruby 就干好了的事。主要是这允许我们用 C 的宏定义来控制，从而使用其它 I/O 多路复用方法，例如 <code class="language-plaintext highlighter-rouge">epoll</code> and <code class="language-plaintext highlighter-rouge">kqueue</code>。我们需要实现 4 个 C 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Scheduler</span><span class="p">.</span><span class="nf">backend</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>

<span class="n">scheduler</span><span class="p">.</span><span class="nf">register</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">interest</span><span class="p">)</span>
<span class="n">scheduler</span><span class="p">.</span><span class="nf">deregister</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>
<span class="n">scheduler</span><span class="p">.</span><span class="nf">wait</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ruby.h&gt;</span><span class="cp">
</span>
<span class="n">VALUE</span> <span class="n">Evt</span> <span class="o">=</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="n">VALUE</span> <span class="n">Scheduler</span> <span class="o">=</span> <span class="n">Qnil</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Init_evt_ext</span><span class="p">();</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">);</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">);</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">);</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">);</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_backend</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">Init_evt_ext</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Evt</span> <span class="o">=</span> <span class="n">rb_define_module</span><span class="p">(</span><span class="s">"Evt"</span><span class="p">);</span>
    <span class="n">Scheduler</span> <span class="o">=</span> <span class="n">rb_define_class_under</span><span class="p">(</span><span class="n">Evt</span><span class="p">,</span> <span class="s">"Scheduler"</span><span class="p">,</span> <span class="n">rb_cObject</span><span class="p">);</span>
    <span class="n">rb_define_singleton_method</span><span class="p">(</span><span class="n">Scheduler</span><span class="p">,</span> <span class="s">"backend"</span><span class="p">,</span> <span class="n">method_scheduler_backend</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">rb_define_method</span><span class="p">(</span><span class="n">Scheduler</span><span class="p">,</span> <span class="s">"init_selector"</span><span class="p">,</span> <span class="n">method_scheduler_init</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">rb_define_method</span><span class="p">(</span><span class="n">Scheduler</span><span class="p">,</span> <span class="s">"register"</span><span class="p">,</span> <span class="n">method_scheduler_register</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">rb_define_method</span><span class="p">(</span><span class="n">Scheduler</span><span class="p">,</span> <span class="s">"deregister"</span><span class="p">,</span> <span class="n">method_scheduler_deregister</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">rb_define_method</span><span class="p">(</span><span class="n">Scheduler</span><span class="p">,</span> <span class="s">"wait"</span><span class="p">,</span> <span class="n">method_scheduler_wait</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Scheduler.backend</code> 是专门给调试用的，剩下 4 个 API 会注入到调度器的 <code class="language-plaintext highlighter-rouge">Scheduelr#run</code>, <code class="language-plaintext highlighter-rouge">Scheduelr#wait_readable</code>, <code class="language-plaintext highlighter-rouge">Scheduelr#wait_writable</code>, <code class="language-plaintext highlighter-rouge">Scheduelr#wait_any</code> 中。</p>

<h3 id="使用-epoll-和-kqueue">使用 <code class="language-plaintext highlighter-rouge">epoll</code> 和 <code class="language-plaintext highlighter-rouge">kqueue</code></h3>

<p>epoll 的三个核心 API 是 <code class="language-plaintext highlighter-rouge">epoll_create</code> <code class="language-plaintext highlighter-rouge">epoll_ctl</code> <code class="language-plaintext highlighter-rouge">epoll_wait</code>。很好理解，我们只要在调度器初始化的时候初始化 <code class="language-plaintext highlighter-rouge">epoll</code> fd，然后在注册 I/O 事件的时候调用 <code class="language-plaintext highlighter-rouge">epoll_ctl</code>，最后用 <code class="language-plaintext highlighter-rouge">epoll_wait</code> 替换掉 <code class="language-plaintext highlighter-rouge">IO.select</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(__linux__) // TODO: Do more checks for using epoll
#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
#define EPOLL_MAX_EVENTS 64
</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@epfd"</span><span class="p">,</span> <span class="n">INT2NUM</span><span class="p">(</span><span class="n">epoll_create</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span> <span class="c1">// Size of epoll is ignored after Linux 2.6.8.</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@epfd"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WAIT_READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WAIT_WRITABLE"</span><span class="p">)));</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">io</span><span class="p">;</span>

    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@epfd"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// Require Linux 2.6.9 for NULL event.</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">event_flag</span><span class="p">,</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="n">VALUE</span> <span class="n">next_timeout</span><span class="p">,</span> <span class="n">obj_io</span><span class="p">,</span> <span class="n">readables</span><span class="p">,</span> <span class="n">writables</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_push</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"push"</span><span class="p">);</span>
    
    <span class="n">epfd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@epfd"</span><span class="p">));</span>
    <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">readables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>
    <span class="n">writables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">next_timeout</span> <span class="o">==</span> <span class="n">Qnil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">next_timeout</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">epoll_event</span><span class="o">*</span> <span class="n">events</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span> <span class="o">*</span> <span class="n">EPOLL_MAX_EVENTS</span><span class="p">);</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">EPOLL_MAX_EVENTS</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
    <span class="c1">// TODO: Check if n &gt;= 0</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flag</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event_flag</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">obj_io</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span><span class="p">)</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
            <span class="n">rb_funcall</span><span class="p">(</span><span class="n">readables</span><span class="p">,</span> <span class="n">id_push</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">obj_io</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event_flag</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">obj_io</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span><span class="p">)</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
            <span class="n">rb_funcall</span><span class="p">(</span><span class="n">writables</span><span class="p">,</span> <span class="n">id_push</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">obj_io</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">rb_ary_new2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readables</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">writables</span><span class="p">);</span>

    <span class="n">xfree</span><span class="p">(</span><span class="n">events</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_backend</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_str_new_cstr</span><span class="p">(</span><span class="s">"epoll"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">kqueue</code> 是类似的。唯一不同的是，BSD 的注册和等待用的是同一个 API，只是参数不同，所以有点难懂。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__APPLE__)
#include</span> <span class="cpf">&lt;sys/event.h&gt;</span><span class="cp">
#define KQUEUE_MAX_EVENTS 64
</span>
<span class="n">VALUE</span> <span class="nf">method_scheduler_init</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rb_iv_set</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">,</span> <span class="n">INT2NUM</span><span class="p">(</span><span class="n">kqueue</span><span class="p">()));</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_register</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">interest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">kevent</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">u_short</span> <span class="n">event_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">ruby_interest</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">interest</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">readable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WAIT_READABLE"</span><span class="p">)));</span>
    <span class="kt">int</span> <span class="n">writable</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cIO</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"WAIT_WRITABLE"</span><span class="p">)));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">readable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_READ</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ruby_interest</span> <span class="o">&amp;</span> <span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">|=</span> <span class="n">EVFILT_WRITE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">EV_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event_flags</span><span class="p">,</span> <span class="n">EV_ADD</span><span class="o">|</span><span class="n">EV_ENABLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">io</span><span class="p">);</span>
    <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// TODO: Check the return value</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_deregister</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">io</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">kevent</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_fileno</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"fileno"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">id_fileno</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">EV_SET</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">EV_DELETE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// TODO: Check the return value</span>
    <span class="k">return</span> <span class="n">Qnil</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_wait</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">kq</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">u_short</span> <span class="n">event_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">kevent</span><span class="o">*</span> <span class="n">events</span><span class="p">;</span> <span class="c1">// Event Triggered</span>
    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">timeout</span><span class="p">;</span>
    <span class="n">VALUE</span> <span class="n">next_timeout</span><span class="p">,</span> <span class="n">obj_io</span><span class="p">,</span> <span class="n">readables</span><span class="p">,</span> <span class="n">writables</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">ID</span> <span class="n">id_next_timeout</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"next_timeout"</span><span class="p">);</span>
    <span class="n">ID</span> <span class="n">id_push</span> <span class="o">=</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"push"</span><span class="p">);</span>

    <span class="n">kq</span> <span class="o">=</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">rb_iv_get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">"@kq"</span><span class="p">));</span>
    <span class="n">next_timeout</span> <span class="o">=</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">id_next_timeout</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">readables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>
    <span class="n">writables</span> <span class="o">=</span> <span class="n">rb_ary_new</span><span class="p">();</span>

   <span class="n">events</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kevent</span><span class="o">*</span><span class="p">)</span> <span class="n">xmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kevent</span><span class="p">)</span> <span class="o">*</span> <span class="n">KQUEUE_MAX_EVENTS</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">next_timeout</span> <span class="o">==</span> <span class="n">Qnil</span> <span class="o">||</span> <span class="n">NUM2INT</span><span class="p">(</span><span class="n">next_timeout</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">KQUEUE_MAX_EVENTS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">timeout</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">next_timeout</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="n">timeout</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">next_timeout</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">kevent</span><span class="p">(</span><span class="n">kq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">KQUEUE_MAX_EVENTS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// TODO: Check if n &gt;= 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_flags</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">filter</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event_flags</span> <span class="o">&amp;</span> <span class="n">EVFILT_READ</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">obj_io</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span><span class="p">)</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">udata</span><span class="p">;</span>
            <span class="n">rb_funcall</span><span class="p">(</span><span class="n">readables</span><span class="p">,</span> <span class="n">id_push</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">obj_io</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event_flags</span> <span class="o">&amp;</span> <span class="n">EVFILT_WRITE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">obj_io</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span><span class="p">)</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">udata</span><span class="p">;</span>
            <span class="n">rb_funcall</span><span class="p">(</span><span class="n">writables</span><span class="p">,</span> <span class="n">id_push</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">obj_io</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">rb_ary_new2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readables</span><span class="p">);</span>
    <span class="n">rb_ary_store</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">writables</span><span class="p">);</span>

    <span class="n">xfree</span><span class="p">(</span><span class="n">events</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">method_scheduler_backend</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">rb_str_new_cstr</span><span class="p">(</span><span class="s">"kqueue"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<h2 id="使用调度器的-http-服务器例子">使用调度器的 HTTP 服务器例子</h2>

<p>在实现好调度器后，我们要测试调度器的性能。因此我写了一个简单的 HTTP 服务器 <a href="https://github.com/dsh0416/evt-server-benchmark">benchmark</a>。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'evt'</span>

<span class="nb">puts</span> <span class="s2">"Using Backend: </span><span class="si">#{</span><span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">backend</span><span class="si">}</span><span class="s2">"</span>
<span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">scheduler</span> <span class="o">=</span> <span class="no">Evt</span><span class="o">::</span><span class="no">Scheduler</span><span class="p">.</span><span class="nf">new</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_INET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">bind</span> <span class="no">Addrinfo</span><span class="p">.</span><span class="nf">tcp</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="mi">3002</span>
<span class="vi">@server</span><span class="p">.</span><span class="nf">listen</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOMAXCONN</span>
<span class="vi">@scheduler</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">scheduler</span>

<span class="k">def</span> <span class="nf">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
  <span class="k">until</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">"</span><span class="se">\r\n</span><span class="s2">"</span> <span class="o">||</span> <span class="n">line</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">gets</span>
  <span class="k">end</span>
  <span class="n">socket</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s2">Content-Length: 0</span><span class="se">\r\n\r\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="n">socket</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>

<span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">blocking: </span><span class="kp">false</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">while</span> <span class="kp">true</span>
    <span class="n">socket</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">accept</span>
    <span class="no">Fiber</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">blocking: </span><span class="kp">false</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">handle_socket</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">resume</span>
  <span class="k">end</span>
<span class="k">end</span><span class="p">.</span><span class="nf">resume</span>

<span class="vi">@scheduler</span><span class="p">.</span><span class="nf">run</span>
</code></pre></div></div>

<p>比起原先阻塞的 I/O，使用 Ruby 3 非阻塞 I/O 后可以达到 3.33x 的性能，而使用 <code class="language-plaintext highlighter-rouge">epoll</code> 后可以达到 4.21x。服务器的例子很简单，所以当 JIT 启动时，不容易造成 ICache 不命中，因此性能进一步提升到了 4.54x。</p>

<p><img src="/assets/images/ruby-scheduler-benchmark.png" alt="Benchmark Result" /></p>

<p>测试是基于 Intel(R) Xeon(R) CPU E3-1220L V2 @ 2.30GHz CPU 的，而且程序是单线程的。如果有更好的 CPU，<code class="language-plaintext highlighter-rouge">epoll</code> 和 <code class="language-plaintext highlighter-rouge">poll</code> 的差距会更大。欢迎尝试，相关 gem 代码已开源。</p>

<h2 id="未来工作">未来工作</h2>

<p>未来工作主要是两部分。一个是提升现有 API 的稳定性，还有就是加入 <code class="language-plaintext highlighter-rouge">io_uring</code> 和 <code class="language-plaintext highlighter-rouge">IOCP</code> 的支持。<code class="language-plaintext highlighter-rouge">io_uring</code> 倒是还好，但我是一点都不懂 Windows 开发。所以欢迎大家来提供意见和贡献。</p>

<h2 id="源码">源码</h2>

<p><a href="https://github.com/dsh0416/evt">dsh0416/evt</a></p>]]></content><author><name>CodeRemixer</name></author><category term="Ruby" /><category term="编程" /><summary type="html"><![CDATA[一次失败的提案]]></summary></entry></feed>